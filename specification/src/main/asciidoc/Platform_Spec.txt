= Version: 8.0

[#50581505_pgfId-107871]## 

[#50581506_pgfId-652943]##Specification: JSR-366 Java Platform,
Enterprise Edition 8 Specification ("Specification")

======= [#50581506_pgfId-653217]##Version: 8.0

[#50581506_pgfId-653218]##Status: Final Release

[#50581506_pgfId-653309]## 

[#50581506_pgfId-653219]##Specification Lead: Oracle America, Inc.
("Specification Lead")

[#50581506_pgfId-653415]## 

[#50581506_pgfId-653220]##Release: August 2017

[#50581506_pgfId-653221]## 

[#50581506_pgfId-653222]##Copyright 2017 Oracle America, Inc. ("Oracle")

[#50581506_pgfId-653314]##500 Oracle Parkway, Redwood City, CA 94065,
U.S.A.

[#50581506_pgfId-653223]##All rights reserved.

{empty}[#50581507_pgfId-235913]##link:titlepage.htm#50581505_pgfId-108776[Java™
Platform, Enterprise Edition (Java EE) Specification, v8 i]

====== [#50581507_pgfId-235915]## _link:JavaEE_Platform_Spec.htm#50581510_pgfId-6959[EE.1 Introduction]_ __ _._ 1

{empty}[#50581507_pgfId-235917]##link:JavaEE_Platform_Spec.htm#50581510_pgfId-7060[EE.1.1
Acknowledgements for the Initial Version 2]

{empty}[#50581507_pgfId-235919]##link:JavaEE_Platform_Spec.htm#50581510_pgfId-7076[EE.1.2
Acknowledgements for Version 1.3 2]

{empty}[#50581507_pgfId-235921]##link:JavaEE_Platform_Spec.htm#50581510_pgfId-1000631[EE.1.3
Acknowledgements for Version 1.4 2]

{empty}[#50581507_pgfId-235923]##link:JavaEE_Platform_Spec.htm#50581510_pgfId-1000729[EE.1.4
Acknowledgements for Version 5 3]

{empty}[#50581507_pgfId-235925]##link:JavaEE_Platform_Spec.htm#50581510_pgfId-1001477[EE.1.5
Acknowledgements for Version 6 4]

{empty}[#50581507_pgfId-235927]##link:JavaEE_Platform_Spec.htm#50581510_pgfId-1001652[EE.1.6
Acknowledgements for Version 7 4]

{empty}[#50581507_pgfId-235929]##link:JavaEE_Platform_Spec.htm#50581510_pgfId-1011287[EE.1.7
Acknowledgements for Version 8 5]

====== [#50581507_pgfId-235931]## _link:JavaEE_Platform_Spec.htm#50581512_pgfId-14708[EE.2 Platform Overview]_ __ _._ 7

{empty}[#50581507_pgfId-235933]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-16457[EE.2.1
Architecture 7]

{empty}[#50581507_pgfId-235935]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-31527[EE.2.2
Profiles 8]

{empty}[#50581507_pgfId-235937]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-15508[EE.2.3
Application Components 10]

{empty}[#50581507_pgfId-235939]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-15513[EE.2.3.1
Java EE Server Support for Application Components 11]

{empty}[#50581507_pgfId-235941]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-15547[EE.2.4
Containers 11]

{empty}[#50581507_pgfId-235943]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-15577[EE.2.4.1
Container Requirements 12]

{empty}[#50581507_pgfId-235945]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-15586[EE.2.4.2
Java EE Servers 12]

{empty}[#50581507_pgfId-235947]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-7107[EE.2.5
Resource Adapters 12]

{empty}[#50581507_pgfId-235949]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-9935[EE.2.6
Database 13]

{empty}[#50581507_pgfId-235951]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-15619[EE.2.7
Java EE Standard Services 13]

{empty}[#50581507_pgfId-235953]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-7612[EE.2.7.1
HTTP 13]

{empty}[#50581507_pgfId-235955]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-7613[EE.2.7.2
HTTPS 13]

{empty}[#50581507_pgfId-235957]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-7614[EE.2.7.3
Java™ Transaction API (JTA) 13]

{empty}[#50581507_pgfId-235959]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-9951[EE.2.7.4
RMI-IIOP (Proposed Optional) 14]

{empty}[#50581507_pgfId-235961]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-41378[EE.2.7.5
Java IDL (Proposed Optional) 14]

{empty}[#50581507_pgfId-235963]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-7118[EE.2.7.6
JDBC™ API 15]

{empty}[#50581507_pgfId-235965]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-30379[EE.2.7.7
Java™ Persistence API 15]

{empty}[#50581507_pgfId-235967]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-7120[EE.2.7.8
Java™ Message Service (JMS) 15]

{empty}[#50581507_pgfId-235969]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-9847[EE.2.7.9
Java Naming and Directory Interface™ (JNDI) 15]

{empty}[#50581507_pgfId-235971]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-7215[EE.2.7.10
JavaMail™ 16]

{empty}[#50581507_pgfId-235973]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-8955[EE.2.7.11
JavaBeans™ Activation Framework (JAF) 16]

{empty}[#50581507_pgfId-235975]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-11785[EE.2.7.12
XML Processing 16]

{empty}[#50581507_pgfId-235977]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-11786[EE.2.7.13
Java EE™ Connector Architecture 16]

{empty}[#50581507_pgfId-235979]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-11789[EE.2.7.14
Security Services 17]

{empty}[#50581507_pgfId-235981]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-22085[EE.2.7.15
Web Services 18]

{empty}[#50581507_pgfId-235983]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-22883[EE.2.7.16
Concurrency Utilities 18]

{empty}[#50581507_pgfId-235985]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-39401[EE.2.7.17
Batch 19]

{empty}[#50581507_pgfId-235987]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-39384[EE.2.7.18
Management 19]

{empty}[#50581507_pgfId-235989]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-22897[EE.2.7.19
Deployment 19]

{empty}[#50581507_pgfId-235991]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-41388[EE.2.8
Interoperability 19]

{empty}[#50581507_pgfId-235993]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-7220[EE.2.9
Flexibility of Product Requirements 20]

{empty}[#50581507_pgfId-235995]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-9779[EE.2.10
Java EE Product Packaging 21]

{empty}[#50581507_pgfId-235997]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-41298[EE.2.11
Java EE Product Extensions 22]

{empty}[#50581507_pgfId-235999]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-32443[EE.2.12
Platform Roles 22]

{empty}[#50581507_pgfId-236001]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-9495[EE.2.12.1
Java EE Product Provider 23]

{empty}[#50581507_pgfId-236003]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-9544[EE.2.12.2
Application Component Provider 23]

{empty}[#50581507_pgfId-236005]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-11392[EE.2.12.3
Application Assembler 23]

{empty}[#50581507_pgfId-236007]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-16306[EE.2.12.4
Deployer 24]

{empty}[#50581507_pgfId-236009]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-9565[EE.2.12.5
System Administrator 24]

{empty}[#50581507_pgfId-236011]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-9827[EE.2.12.6
Tool Provider 25]

{empty}[#50581507_pgfId-236013]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-24707[EE.2.12.7
System Component Provider 25]

{empty}[#50581507_pgfId-236015]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-32930[EE.2.13
Platform Contracts 25]

{empty}[#50581507_pgfId-236017]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-9423[EE.2.13.1
Java EE APIs 25]

{empty}[#50581507_pgfId-236019]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-11908[EE.2.13.2
Java EE Service Provider Interfaces (SPIs) 26]

{empty}[#50581507_pgfId-236021]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-9459[EE.2.13.3
Network Protocols 26]

{empty}[#50581507_pgfId-236023]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-11200[EE.2.13.4
Deployment Descriptors and Annotations 26]

{empty}[#50581507_pgfId-236025]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-25225[EE.2.14
Changes in J2EE 1.3 27]

{empty}[#50581507_pgfId-236027]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-25229[EE.2.15
Changes in J2EE 1.4 27]

{empty}[#50581507_pgfId-236029]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-25371[EE.2.16
Changes in Java EE 5 28]

{empty}[#50581507_pgfId-236031]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-30704[EE.2.17
Changes in Java EE 6 29]

{empty}[#50581507_pgfId-236033]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-32562[EE.2.18
Changes in Java EE 7 29]

{empty}[#50581507_pgfId-236035]##link:JavaEE_Platform_Spec.htm#50581512_pgfId-41473[EE.2.19
Changes in Java EE 8 30]

====== [#50581507_pgfId-236037]## _link:JavaEE_Platform_Spec.htm#50581514_pgfId-5529[EE.3 Security]_ __ _._ 33

{empty}[#50581507_pgfId-236039]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-20726[EE.3.1
Introduction 33]

{empty}[#50581507_pgfId-236041]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-13487[EE.3.2
A Simple Example 34]

{empty}[#50581507_pgfId-236043]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-13485[EE.3.3
Security Architecture 37]

{empty}[#50581507_pgfId-236045]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-12305[EE.3.3.1
Goals 37]

{empty}[#50581507_pgfId-236047]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-8167[EE.3.3.2
Non Goals 38]

{empty}[#50581507_pgfId-236049]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-11170[EE.3.3.3
Terminology 38]

{empty}[#50581507_pgfId-236051]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-10319[EE.3.3.4
Container Based Security 39]

{empty}[#50581507_pgfId-236053]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-13075[EE.3.3.5
Distributed Security 41]

{empty}[#50581507_pgfId-236055]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-13072[EE.3.3.6
Authorization Model 41]

{empty}[#50581507_pgfId-236057]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-12959[EE.3.3.7
HTTP Login Gateways 43]

{empty}[#50581507_pgfId-236059]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-12214[EE.3.3.8
User Authentication 43]

{empty}[#50581507_pgfId-236061]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-12393[EE.3.3.9
Lazy Authentication 45]

{empty}[#50581507_pgfId-236063]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-20762[EE.3.4
User Authentication Requirements 46]

{empty}[#50581507_pgfId-236065]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-12814[EE.3.4.1
Login Sessions 46]

{empty}[#50581507_pgfId-236067]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-12472[EE.3.4.2
Required Login Mechanisms 46]

{empty}[#50581507_pgfId-236069]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-15875[EE.3.4.3
Unauthenticated Users 48]

{empty}[#50581507_pgfId-236071]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-10253[EE.3.4.4
Application Client User Authentication 49]

{empty}[#50581507_pgfId-236073]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-9979[EE.3.4.5
Resource Authentication Requirements 50]

{empty}[#50581507_pgfId-236075]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-9985[EE.3.5
Authorization Requirements 51]

{empty}[#50581507_pgfId-236077]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-15342[EE.3.5.1
Code Authorization 51]

{empty}[#50581507_pgfId-236079]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-9989[EE.3.5.2
Caller Authorization 51]

{empty}[#50581507_pgfId-236081]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-15394[EE.3.5.3
Propagated Caller Identities. 52]

{empty}[#50581507_pgfId-236083]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-19349[EE.3.5.4
Run As Identities 52]

{empty}[#50581507_pgfId-236085]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-15863[EE.3.6
Deployment Requirements 52]

{empty}[#50581507_pgfId-236087]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-28792[EE.3.7
Future Directions 53]

{empty}[#50581507_pgfId-236089]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-10014[EE.3.7.1
Auditing 53]

{empty}[#50581507_pgfId-236091]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-20883[EE.3.7.2
Instance-based Access Control 54]

{empty}[#50581507_pgfId-236093]##link:JavaEE_Platform_Spec.htm#50581514_pgfId-10992[EE.3.7.3
User Registration 54]

====== [#50581507_pgfId-236095]## _link:JavaEE_Platform_Spec.htm#50581513_pgfId-5529[EE.4 Transaction Management]_ __ _._ 55

{empty}[#50581507_pgfId-236097]##link:JavaEE_Platform_Spec.htm#50581513_pgfId-6976[EE.4.1
Overview 55]

{empty}[#50581507_pgfId-236099]##link:JavaEE_Platform_Spec.htm#50581513_pgfId-9993[EE.4.2
Requirements 57]

{empty}[#50581507_pgfId-236101]##link:JavaEE_Platform_Spec.htm#50581513_pgfId-19442[EE.4.2.1
Web Components 57]

{empty}[#50581507_pgfId-236103]##link:JavaEE_Platform_Spec.htm#50581513_pgfId-23021[EE.4.2.2
Transactions in Web Component Life Cycles 58]

{empty}[#50581507_pgfId-236105]##link:JavaEE_Platform_Spec.htm#50581513_pgfId-19530[EE.4.2.3
Transactions and Threads 59]

{empty}[#50581507_pgfId-236107]##link:JavaEE_Platform_Spec.htm#50581513_pgfId-16739[EE.4.2.4
Enterprise JavaBeans™ Components 60]

{empty}[#50581507_pgfId-236109]##link:JavaEE_Platform_Spec.htm#50581513_pgfId-16743[EE.4.2.5
Application Clients 60]

{empty}[#50581507_pgfId-236111]##link:JavaEE_Platform_Spec.htm#50581513_pgfId-16403[EE.4.2.6
Applet Clients 60]

{empty}[#50581507_pgfId-236113]##link:JavaEE_Platform_Spec.htm#50581513_pgfId-7008[EE.4.2.7
Transactional JDBC™ Technology Support 60]

{empty}[#50581507_pgfId-236115]##link:JavaEE_Platform_Spec.htm#50581513_pgfId-17254[EE.4.2.8
Transactional JMS Support 61]

{empty}[#50581507_pgfId-236117]##link:JavaEE_Platform_Spec.htm#50581513_pgfId-17296[EE.4.2.9
Transactional Resource Adapter (Connector) Support 61]

{empty}[#50581507_pgfId-236119]##link:JavaEE_Platform_Spec.htm#50581513_pgfId-17291[EE.4.3
Transaction Interoperability 61]

{empty}[#50581507_pgfId-236121]##link:JavaEE_Platform_Spec.htm#50581513_pgfId-17292[EE.4.3.1
Multiple Java EE Platform Interoperability 61]

{empty}[#50581507_pgfId-236123]##link:JavaEE_Platform_Spec.htm#50581513_pgfId-16529[EE.4.3.2
Support for Transactional Resource Managers 62]

{empty}[#50581507_pgfId-236125]##link:JavaEE_Platform_Spec.htm#50581513_pgfId-17729[EE.4.4
Local Transaction Optimization 62]

{empty}[#50581507_pgfId-236127]##link:JavaEE_Platform_Spec.htm#50581513_pgfId-17880[EE.4.4.1
Requirements 62]

{empty}[#50581507_pgfId-236129]##link:JavaEE_Platform_Spec.htm#50581513_pgfId-17881[EE.4.4.2
A Possible Design 62]

{empty}[#50581507_pgfId-236131]##link:JavaEE_Platform_Spec.htm#50581513_pgfId-17736[EE.4.5
Connection Sharing 63]

{empty}[#50581507_pgfId-236133]##link:JavaEE_Platform_Spec.htm#50581513_pgfId-23086[EE.4.6
JDBC and JMS Deployment Issues 64]

{empty}[#50581507_pgfId-236135]##link:JavaEE_Platform_Spec.htm#50581513_pgfId-25470[EE.4.7
Two-Phase Commit Support 65]

{empty}[#50581507_pgfId-236137]##link:JavaEE_Platform_Spec.htm#50581513_pgfId-17725[EE.4.8
System Administration Tools 65]

====== [#50581507_pgfId-236139]## _link:JavaEE_Platform_Spec.htm#50581511_pgfId-1007216[EE.5 Resources, Naming, and Injection]_ __ _._ 67

{empty}[#50581507_pgfId-236141]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-7675[EE.5.1
Overview 67]

{empty}[#50581507_pgfId-236143]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-7679[EE.5.1.1
Chapter Organization 68]

{empty}[#50581507_pgfId-236145]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-12928[EE.5.1.2
Required Access to the JNDI Naming Environment 70]

{empty}[#50581507_pgfId-236147]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-7693[EE.5.2
JNDI Naming Context 71]

{empty}[#50581507_pgfId-236149]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-16471[EE.5.2.1
The Application Component’s Environment 71]

{empty}[#50581507_pgfId-236151]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-997238[EE.5.2.2
Application Component Environment Namespaces 72]

{empty}[#50581507_pgfId-236153]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-998528[EE.5.2.3
Accessibility of Environment Entry Types 74]

{empty}[#50581507_pgfId-236155]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-16470[EE.5.2.4
Sharing of Environment Entries 74]

{empty}[#50581507_pgfId-236157]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-16472[EE.5.2.5
Annotations and Injection 75]

{empty}[#50581507_pgfId-236159]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-16495[EE.5.2.6
Annotations and Deployment Descriptors 79]

{empty}[#50581507_pgfId-236161]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-997486[EE.5.2.7
Other Naming Context Entries 80]

{empty}[#50581507_pgfId-236163]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-16732[EE.5.3
Responsibilities by Java EE Role 80]

{empty}[#50581507_pgfId-236165]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-16728[EE.5.3.1
Application Component Provider’s Responsibilities 81]

{empty}[#50581507_pgfId-236167]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-16702[EE.5.3.2
Application Assembler’s Responsibilities 81]

{empty}[#50581507_pgfId-236169]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-16704[EE.5.3.3
Deployer’s Responsibilities 81]

{empty}[#50581507_pgfId-236171]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-16711[EE.5.3.4
Java EE Product Provider’s Responsibilities 82]

{empty}[#50581507_pgfId-236173]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-16397[EE.5.4
Simple Environment Entries 83]

{empty}[#50581507_pgfId-236175]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-7705[EE.5.4.1
Application Component Provider’s Responsibilities 83]

{empty}[#50581507_pgfId-236177]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-7814[EE.5.5
Enterprise JavaBeans™ (EJB) References 89]

{empty}[#50581507_pgfId-236179]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-7818[EE.5.5.1
Application Component Provider’s Responsibilities 89]

{empty}[#50581507_pgfId-236181]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-7894[EE.5.5.2
Application Assembler’s Responsibilities 94]

{empty}[#50581507_pgfId-236183]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-7930[EE.5.5.3
Deployer’s Responsibilities 96]

{empty}[#50581507_pgfId-236185]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-7935[EE.5.5.4
Java EE Product Provider’s Responsibilities 97]

{empty}[#50581507_pgfId-236187]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-7941[EE.5.6
Web Service References 98]

{empty}[#50581507_pgfId-236189]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-997061[EE.5.7
Resource Manager Connection Factory References 98]

{empty}[#50581507_pgfId-236191]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-7945[EE.5.7.1
Application Component Provider’s Responsibilities 98]

{empty}[#50581507_pgfId-236193]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-8019[EE.5.7.2
Deployer’s Responsibilities 104]

{empty}[#50581507_pgfId-236195]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-8027[EE.5.7.3
Java EE Product Provider’s Responsibilities 105]

{empty}[#50581507_pgfId-236197]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-8037[EE.5.7.4
System Administrator’s Responsibilities 106]

{empty}[#50581507_pgfId-236199]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-9520[EE.5.8
Resource Environment References 106]

{empty}[#50581507_pgfId-236201]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-997165[EE.5.8.1
Application Component Provider’s Responsibilities 106]

{empty}[#50581507_pgfId-236203]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-16318[EE.5.8.2
Deployer’s Responsibilities 108]

{empty}[#50581507_pgfId-236205]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-9622[EE.5.8.3
Java EE Product Provider’s Responsibilities 109]

{empty}[#50581507_pgfId-236207]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-15880[EE.5.9
Message Destination References 109]

{empty}[#50581507_pgfId-236209]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-15882[EE.5.9.1
Application Component Provider’s Responsibilities 109]

{empty}[#50581507_pgfId-236211]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-16056[EE.5.9.2
Application Assembler’s Responsibilities 112]

{empty}[#50581507_pgfId-236213]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-15919[EE.5.9.3
Deployer’s Responsibilities 114]

{empty}[#50581507_pgfId-236215]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-16100[EE.5.9.4
Java EE Product Provider’s Responsibilities 114]

{empty}[#50581507_pgfId-236217]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-8519[EE.5.10
UserTransaction References 114]

{empty}[#50581507_pgfId-236219]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-8529[EE.5.10.1
Application Component Provider’s Responsibilities 116]

{empty}[#50581507_pgfId-236221]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-8531[EE.5.10.2
Java EE Product Provider’s Responsibilities 116]

{empty}[#50581507_pgfId-236223]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-18736[EE.5.11
TransactionSynchronizationRegistry References 116]

{empty}[#50581507_pgfId-236225]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-18778[EE.5.11.1
Application Component Provider’s Responsibilities 117]

{empty}[#50581507_pgfId-236227]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-18787[EE.5.11.2
Java EE Product Provider’s Responsibilities 117]

{empty}[#50581507_pgfId-236229]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-15769[EE.5.12
ORB References 117]

{empty}[#50581507_pgfId-236231]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-15792[EE.5.12.1
Application Component Provider’s Responsibilities 118]

{empty}[#50581507_pgfId-236233]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-15803[EE.5.12.2
Java EE Product Provider’s Responsibilities 118]

{empty}[#50581507_pgfId-236235]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-18915[EE.5.13
Persistence Unit References 119]

{empty}[#50581507_pgfId-236237]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-18920[EE.5.13.1
Application Component Provider’s Responsibilities 119]

{empty}[#50581507_pgfId-236239]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-19392[EE.5.13.2
Application Assembler’s Responsibilities 122]

{empty}[#50581507_pgfId-236241]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-19056[EE.5.13.3
Deployer’s Responsibility 123]

{empty}[#50581507_pgfId-236243]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-19065[EE.5.13.4
Java EE Product Provider’s Responsibility 123]

{empty}[#50581507_pgfId-236245]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-19074[EE.5.13.5
System Administrator’s Responsibility 123]

{empty}[#50581507_pgfId-236247]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-19080[EE.5.14
Persistence Context References 124]

{empty}[#50581507_pgfId-236249]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-19085[EE.5.14.1
Application Component Provider’s Responsibilities 124]

{empty}[#50581507_pgfId-236251]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-19183[EE.5.14.2
Application Assembler’s Responsibilities 127]

{empty}[#50581507_pgfId-236253]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-19214[EE.5.14.3
Deployer’s Responsibility 128]

{empty}[#50581507_pgfId-236255]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-19223[EE.5.14.4
Java EE Product Provider’s Responsibility 129]

{empty}[#50581507_pgfId-236257]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-19232[EE.5.14.5
System Administrator’s Responsibility 129]

{empty}[#50581507_pgfId-236259]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-997557[EE.5.15
Application Name and Module Name References 129]

{empty}[#50581507_pgfId-236261]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-997610[EE.5.15.1
Application Component Provider’s Responsibilities 130]

{empty}[#50581507_pgfId-236263]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-997664[EE.5.15.2
Java EE Product Provider’s Responsibilities 130]

{empty}[#50581507_pgfId-236265]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-1006014[EE.5.16
Application Client Container Property 130]

{empty}[#50581507_pgfId-236267]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-1006016[EE.5.16.1
Application Component Provider’s Responsibilities 130]

{empty}[#50581507_pgfId-236269]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-1006021[EE.5.16.2
Java EE Product Provider’s Responsibilities 130]

{empty}[#50581507_pgfId-236271]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-1005970[EE.5.17
Validator and Validator Factory References 130]

{empty}[#50581507_pgfId-236273]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-997914[EE.5.17.1
Application Component Provider’s Responsibilities 131]

{empty}[#50581507_pgfId-236275]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-997919[EE.5.17.2
Java EE Product Provider’s Responsibilities 132]

{empty}[#50581507_pgfId-236277]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-998088[EE.5.18
Resource Definition and Configuration 132]

{empty}[#50581507_pgfId-236279]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-1003712[EE.5.18.1
Guidelines 134]

{empty}[#50581507_pgfId-236281]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-1003609[EE.5.18.2
Requirements Common to All Resource Definition Types 134]

{empty}[#50581507_pgfId-236283]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-1002353[EE.5.18.3
DataSource Resource Definition 135]

{empty}[#50581507_pgfId-236285]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-1000968[EE.5.18.4
JMS Connection Factory Resource Definition 138]

{empty}[#50581507_pgfId-236287]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-1003145[EE.5.18.5
JMS Destination Definition 140]

{empty}[#50581507_pgfId-236289]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-1001473[EE.5.18.6
Mail Session Definition 142]

{empty}[#50581507_pgfId-236291]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-1001718[EE.5.18.7
Connector Connection Factory Definition 144]

{empty}[#50581507_pgfId-236293]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-1004520[EE.5.18.8
Connector Administered Object Definition 146]

{empty}[#50581507_pgfId-236295]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-1002994[EE.5.19
Default Data Source 147]

{empty}[#50581507_pgfId-236297]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-1004937[EE.5.19.1
Java EE Product Provider's Responsibilities 148]

{empty}[#50581507_pgfId-236299]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-1004873[EE.5.20
Default JMS Connection Factory 148]

{empty}[#50581507_pgfId-236301]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-1005023[EE.5.20.1
Java EE Product Provider's Responsibilities 149]

{empty}[#50581507_pgfId-236303]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-1007467[EE.5.21
Default Concurrency Utilities Objects 149]

{empty}[#50581507_pgfId-236305]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-1007488[EE.5.21.1
Java EE Product Provider's Responsibilities 150]

{empty}[#50581507_pgfId-236307]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-1004869[EE.5.22
Managed Bean References 151]

{empty}[#50581507_pgfId-236309]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-998764[EE.5.22.1
Application Component Provider’s Responsibilities 152]

{empty}[#50581507_pgfId-236311]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-998766[EE.5.22.2
Java EE Product Provider’s Responsibilities 152]

{empty}[#50581507_pgfId-236313]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-1007314[EE.5.23
Bean Manager References 152]

{empty}[#50581507_pgfId-236315]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-1000286[EE.5.23.1
Application Component Provider’s Responsibilities 153]

{empty}[#50581507_pgfId-236317]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-1000292[EE.5.23.2
Java EE Product Provider’s Responsibilities 153]

{empty}[#50581507_pgfId-236319]##link:JavaEE_Platform_Spec.htm#50581511_pgfId-1000182[EE.5.24
Support for Dependency Injection 153]

====== [#50581507_pgfId-236321]## _link:JavaEE_Platform_Spec.htm#50581515_pgfId-1019297[EE.6 Application Programming Interface]_ __ _._ 157

{empty}[#50581507_pgfId-236323]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1020146[EE.6.1
Required APIs 157]

{empty}[#50581507_pgfId-236325]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1005972[EE.6.1.1
Java Compatible APIs 157]

{empty}[#50581507_pgfId-236327]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1005973[EE.6.1.2
Required Java Technologies 158]

{empty}[#50581507_pgfId-236329]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1019577[EE.6.1.3
Pruned Java Technologies 161]

{empty}[#50581507_pgfId-236331]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-6979[EE.6.2
Java Platform, Standard Edition (Java SE) Requirements 161]

{empty}[#50581507_pgfId-236333]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-6980[EE.6.2.1
Programming Restrictions 161]

{empty}[#50581507_pgfId-236335]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1006088[EE.6.2.2
Java EE Security Manager Related Requirements 162]

{empty}[#50581507_pgfId-236337]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1025274[EE.6.2.3
Additional Requirements 168]

{empty}[#50581507_pgfId-236339]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1004138[EE.6.3
Enterprise JavaBeans™ (EJB) 3.2 Requirements 177]

{empty}[#50581507_pgfId-236341]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1004198[EE.6.4
Servlet 4.0 Requirements 178]

{empty}[#50581507_pgfId-236343]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-7546[EE.6.5
JavaServer Pages™ (JSP) 2.3 Requirements 179]

{empty}[#50581507_pgfId-236345]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1020057[EE.6.6
Expression Language (EL) 3.0 Requirements 179]

{empty}[#50581507_pgfId-236347]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1002556[EE.6.7
Java™ Message Service (JMS) 2.0 Requirements 179]

{empty}[#50581507_pgfId-236349]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-7559[EE.6.8
Java™ Transaction API (JTA) 1.2 Requirements 181]

{empty}[#50581507_pgfId-236351]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-7560[EE.6.9
JavaMail™ 1.6 Requirements 182]

{empty}[#50581507_pgfId-236353]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1004369[EE.6.10
Java EE™ Connector Architecture 1.7 Requirements 183]

{empty}[#50581507_pgfId-236355]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1016883[EE.6.11
Web Services for Java EE 1.4 Requirements 184]

{empty}[#50581507_pgfId-236357]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1016885[EE.6.12
Java™ API for XML-based RPC (JAX-RPC) 1.1 Requirements (Optional) 184]

{empty}[#50581507_pgfId-236359]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1027333[EE.6.13
Java™ API for RESTful Web Services (JAX-RS) 2.1 Requirements 184]

{empty}[#50581507_pgfId-236361]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1020103[EE.6.14
Java API for WebSocket 1.1 (WebSocket) Requirements 185]

{empty}[#50581507_pgfId-236363]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1025650[EE.6.15
Java API for JSON Processing 1.1 (JSON-P) Requirements 185]

{empty}[#50581507_pgfId-236365]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1026970[EE.6.16
Java API for JSON Binding 1.0 (JSON-B) Requirements 185]

{empty}[#50581507_pgfId-236367]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1025665[EE.6.17
Concurrency Utilities for Java EE 1.0 (Concurrency Utilities)
Requirements 186]

{empty}[#50581507_pgfId-236369]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1026001[EE.6.18
Batch Applications for the Java Platform 1.0 (Batch) Requirements 186]

{empty}[#50581507_pgfId-236371]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1016891[EE.6.19
Java™ API for XML Registries (JAXR) 1.0 Requirements (Optional) 186]

{empty}[#50581507_pgfId-236373]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1016893[EE.6.20
Java™ Platform, Enterprise Edition Management API 1.1 Requirements 187]

{empty}[#50581507_pgfId-236375]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1016895[EE.6.21
Java™ Platform, Enterprise Edition Deployment API 1.2 Requirements
(Optional) 187]

{empty}[#50581507_pgfId-236377]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1016897[EE.6.22
Java™ Authorization Contract for Containers (JACC) 1.5 Requirements 187]

{empty}[#50581507_pgfId-236379]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1020051[EE.6.23
Java™ Authentication Service Provider Interface for Containers (JASPIC)
1.1 Requirements 188]

{empty}[#50581507_pgfId-236381]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1027367[EE.6.24
Java EE Security API 1.0 Requirements 188]

{empty}[#50581507_pgfId-236383]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1027389[EE.6.25
Debugging Support for Other Languages (JSR-45) Requirements 188]

{empty}[#50581507_pgfId-236385]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1017738[EE.6.26
Standard Tag Library for JavaServer Pages™ (JSTL) 1.2 Requirements 189]

{empty}[#50581507_pgfId-236387]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1017744[EE.6.27
Web Services Metadata for the Java™ Platform 2.1 Requirements 189]

{empty}[#50581507_pgfId-236389]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1017750[EE.6.28
JavaServer Faces™ 2.3 Requirements 189]

{empty}[#50581507_pgfId-236391]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1017756[EE.6.29
Common Annotations for the Java™ Platform 1.3 Requirements 190]

{empty}[#50581507_pgfId-236393]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1018477[EE.6.30
Java™ Persistence API 2.2 Requirements 191]

{empty}[#50581507_pgfId-236395]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1022287[EE.6.31
Bean Validation 2.0 Requirements 191]

{empty}[#50581507_pgfId-236397]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1021600[EE.6.32
Managed Beans 1.0 Requirements 191]

{empty}[#50581507_pgfId-236399]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1021809[EE.6.33
Interceptors 1.2 Requirements 192]

{empty}[#50581507_pgfId-236401]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1020020[EE.6.34
Contexts and Dependency Injection for the Java EE Platform 2.0
Requirements 192]

{empty}[#50581507_pgfId-236403]##link:JavaEE_Platform_Spec.htm#50581515_pgfId-1021755[EE.6.35
Dependency Injection for Java 1.0 Requirements 192]

====== [#50581507_pgfId-236405]## _link:JavaEE_Platform_Spec.htm#50581517_pgfId-7065[EE.7 Interoperability]_ __ _._ 193

{empty}[#50581507_pgfId-236407]##link:JavaEE_Platform_Spec.htm#50581517_pgfId-7563[EE.7.1
Introduction to Interoperability 193]

{empty}[#50581507_pgfId-236409]##link:JavaEE_Platform_Spec.htm#50581517_pgfId-7572[EE.7.2
Interoperability Protocols 194]

{empty}[#50581507_pgfId-236411]##link:JavaEE_Platform_Spec.htm#50581517_pgfId-7578[EE.7.2.1
Internet and Web Protocols 194]

{empty}[#50581507_pgfId-236413]##link:JavaEE_Platform_Spec.htm#50581517_pgfId-7585[EE.7.2.2
OMG Protocols (Proposed Optional) 195]

{empty}[#50581507_pgfId-236415]##link:JavaEE_Platform_Spec.htm#50581517_pgfId-10195[EE.7.2.3
Java Technology Protocols 196]

{empty}[#50581507_pgfId-236417]##link:JavaEE_Platform_Spec.htm#50581517_pgfId-7593[EE.7.2.4
Data Formats 196]

====== [#50581507_pgfId-236419]## _link:JavaEE_Platform_Spec.htm#50581519_pgfId-18730[EE.8 Application Assembly and Deployment]_ __ _._ 199

{empty}[#50581507_pgfId-236421]##link:JavaEE_Platform_Spec.htm#50581519_pgfId-14189[EE.8.1
Application Development Life Cycle 200]

{empty}[#50581507_pgfId-236423]##link:JavaEE_Platform_Spec.htm#50581519_pgfId-14270[EE.8.1.1
Component Creation 201]

{empty}[#50581507_pgfId-236425]##link:JavaEE_Platform_Spec.htm#50581519_pgfId-1010849[EE.8.1.2
Application Assembly 203]

{empty}[#50581507_pgfId-236427]##link:JavaEE_Platform_Spec.htm#50581519_pgfId-14354[EE.8.1.3
Deployment 204]

{empty}[#50581507_pgfId-236429]##link:JavaEE_Platform_Spec.htm#50581519_pgfId-1080312[EE.8.2
Library Support 205]

{empty}[#50581507_pgfId-236431]##link:JavaEE_Platform_Spec.htm#50581519_pgfId-1053033[EE.8.2.1
Bundled Libraries 205]

{empty}[#50581507_pgfId-236433]##link:JavaEE_Platform_Spec.htm#50581519_pgfId-1053113[EE.8.2.2
Installed Libraries 206]

{empty}[#50581507_pgfId-236435]##link:JavaEE_Platform_Spec.htm#50581519_pgfId-1053089[EE.8.2.3
Library Conflicts 207]

{empty}[#50581507_pgfId-236437]##link:JavaEE_Platform_Spec.htm#50581519_pgfId-1053090[EE.8.2.4
Library Resources 207]

{empty}[#50581507_pgfId-236439]##link:JavaEE_Platform_Spec.htm#50581519_pgfId-1059341[EE.8.2.5
Dynamic Class Loading 208]

{empty}[#50581507_pgfId-236441]##link:JavaEE_Platform_Spec.htm#50581519_pgfId-1059430[EE.8.2.6
Examples 209]

{empty}[#50581507_pgfId-236443]##link:JavaEE_Platform_Spec.htm#50581519_pgfId-14365[EE.8.3
Class Loading Requirements 210]

{empty}[#50581507_pgfId-236445]##link:JavaEE_Platform_Spec.htm#50581519_pgfId-1065499[EE.8.3.1
Web Container Class Loading Requirements 211]

{empty}[#50581507_pgfId-236447]##link:JavaEE_Platform_Spec.htm#50581519_pgfId-1065569[EE.8.3.2
EJB Container Class Loading Requirements 212]

{empty}[#50581507_pgfId-236449]##link:JavaEE_Platform_Spec.htm#50581519_pgfId-1065633[EE.8.3.3
Application Client Container Class Loading Requirements 214]

{empty}[#50581507_pgfId-236451]##link:JavaEE_Platform_Spec.htm#50581519_pgfId-1065678[EE.8.3.4
Applet Container Class Loading Requirements 215]

{empty}[#50581507_pgfId-236453]##link:JavaEE_Platform_Spec.htm#50581519_pgfId-1065477[EE.8.4
Application Assembly 215]

{empty}[#50581507_pgfId-236455]##link:JavaEE_Platform_Spec.htm#50581519_pgfId-17877[EE.8.4.1
Assembling a Java EE Application 215]

{empty}[#50581507_pgfId-236457]##link:JavaEE_Platform_Spec.htm#50581519_pgfId-17548[EE.8.4.2
Adding and Removing Modules 218]

{empty}[#50581507_pgfId-236459]##link:JavaEE_Platform_Spec.htm#50581519_pgfId-14430[EE.8.5
Deployment 219]

{empty}[#50581507_pgfId-236461]##link:JavaEE_Platform_Spec.htm#50581519_pgfId-1015864[EE.8.5.1
Deploying a Stand-Alone Java EE Module 221]

{empty}[#50581507_pgfId-236463]##link:JavaEE_Platform_Spec.htm#50581519_pgfId-14484[EE.8.5.2
Deploying a Java EE Application 223]

{empty}[#50581507_pgfId-236465]##link:JavaEE_Platform_Spec.htm#50581519_pgfId-1010784[EE.8.5.3
Deploying a Library 225]

{empty}[#50581507_pgfId-236467]##link:JavaEE_Platform_Spec.htm#50581519_pgfId-1067048[EE.8.5.4
Module Initialization 225]

{empty}[#50581507_pgfId-236469]##link:JavaEE_Platform_Spec.htm#50581519_pgfId-1005616[EE.8.6
Java EE Application XML Schema 226]

{empty}[#50581507_pgfId-236471]##link:JavaEE_Platform_Spec.htm#50581519_pgfId-1080172[EE.8.7
Common Java EE XML Schema Definitions 229]

====== [#50581507_pgfId-236473]## _link:JavaEE_Platform_Spec.htm#50581543_pgfId-1066273[EE.9 Profiles]_ __ _._ 231

{empty}[#50581507_pgfId-236475]##link:JavaEE_Platform_Spec.htm#50581543_pgfId-14189[EE.9.1
Introduction 231]

{empty}[#50581507_pgfId-236477]##link:JavaEE_Platform_Spec.htm#50581543_pgfId-1066306[EE.9.2
Profile Definition 232]

{empty}[#50581507_pgfId-236479]##link:JavaEE_Platform_Spec.htm#50581543_pgfId-1066305[EE.9.3
General Rules for Profiles 232]

{empty}[#50581507_pgfId-236481]##link:JavaEE_Platform_Spec.htm#50581543_pgfId-1066320[EE.9.4
Expression of Requirements 233]

{empty}[#50581507_pgfId-236483]##link:JavaEE_Platform_Spec.htm#50581543_pgfId-1066327[EE.9.5
Requirements for All Java EE Profiles 233]

{empty}[#50581507_pgfId-236485]##link:JavaEE_Platform_Spec.htm#50581543_pgfId-1066583[EE.9.6
Optional Features for Java EE Profiles 234]

{empty}[#50581507_pgfId-236487]##link:JavaEE_Platform_Spec.htm#50581543_pgfId-1066339[EE.9.7
Full Java EE Product Requirements 234]

====== [#50581507_pgfId-236489]## _link:JavaEE_Platform_Spec.htm#50581520_pgfId-7065[EE.10 Application Clients]_ __ _._ 237

{empty}[#50581507_pgfId-236491]##link:JavaEE_Platform_Spec.htm#50581520_pgfId-7672[EE.10.1
Overview 237]

{empty}[#50581507_pgfId-236493]##link:JavaEE_Platform_Spec.htm#50581520_pgfId-7747[EE.10.2
Security 237]

{empty}[#50581507_pgfId-236495]##link:JavaEE_Platform_Spec.htm#50581520_pgfId-999845[EE.10.3
Transactions 238]

{empty}[#50581507_pgfId-236497]##link:JavaEE_Platform_Spec.htm#50581520_pgfId-999827[EE.10.4
Resources, Naming, and Injection 239]

{empty}[#50581507_pgfId-236499]##link:JavaEE_Platform_Spec.htm#50581520_pgfId-7798[EE.10.5
Application Programming Interfaces 239]

{empty}[#50581507_pgfId-236501]##link:JavaEE_Platform_Spec.htm#50581520_pgfId-7686[EE.10.6
Packaging and Deployment 239]

{empty}[#50581507_pgfId-236503]##link:JavaEE_Platform_Spec.htm#50581520_pgfId-1001328[EE.10.7
Java EE Application Client XML Schema 242]

====== [#50581507_pgfId-236505]## _link:JavaEE_Platform_Spec.htm#50581516_pgfId-5529[EE.11 Service Provider Interface]_ __ _._ 245

{empty}[#50581507_pgfId-236507]##link:JavaEE_Platform_Spec.htm#50581516_pgfId-10572[EE.11.1
Java™ EE Connector Architecture 245]

{empty}[#50581507_pgfId-236509]##link:JavaEE_Platform_Spec.htm#50581516_pgfId-10528[EE.11.2
Java™ Authorization Service Provider Contract for Containers 245]

{empty}[#50581507_pgfId-236511]##link:JavaEE_Platform_Spec.htm#50581516_pgfId-10549[EE.11.3
Java™ Transaction API 246]

{empty}[#50581507_pgfId-236513]##link:JavaEE_Platform_Spec.htm#50581516_pgfId-10591[EE.11.4
Java™ Persistence 246]

{empty}[#50581507_pgfId-236515]##link:JavaEE_Platform_Spec.htm#50581516_pgfId-10623[EE.11.5
JavaMail™ 246]

====== [#50581507_pgfId-236517]## _link:JavaEE_Platform_Spec.htm#50581541_pgfId-5529[EE.12 Compatibility and Migration]_ __ _._ 247

{empty}[#50581507_pgfId-236519]##link:JavaEE_Platform_Spec.htm#50581541_pgfId-10545[EE.12.1
Compatibility 247]

{empty}[#50581507_pgfId-236521]##link:JavaEE_Platform_Spec.htm#50581541_pgfId-10552[EE.12.2
Migration 248]

{empty}[#50581507_pgfId-236523]##link:JavaEE_Platform_Spec.htm#50581541_pgfId-10557[EE.12.2.1
Java Persistence 248]

{empty}[#50581507_pgfId-236525]##link:JavaEE_Platform_Spec.htm#50581541_pgfId-10560[EE.12.2.2
JAX-WS 248]

====== [#50581507_pgfId-236527]## _link:JavaEE_Platform_Spec.htm#50581518_pgfId-6957[EE.13 Future Directions]_ __ _._ 249

{empty}[#50581507_pgfId-236529]##link:JavaEE_Platform_Spec.htm#50581518_pgfId-7538[EE.13.1
Java EE SPI 249]

===== [#50581507_pgfId-236531]##link:JavaEE_Platform_Spec.htm#50581522_pgfId-13916[Appendix EE.A: Previous Version Deployment Descriptors 251]

{empty}[#50581507_pgfId-236533]##link:JavaEE_Platform_Spec.htm#50581522_pgfId-45747[EE.A.1
Java EE 7 Application XML Schema 251]

{empty}[#50581507_pgfId-236535]##link:JavaEE_Platform_Spec.htm#50581522_pgfId-46502[EE.A.2
Common Java EE XML Schema Definitions 255]

{empty}[#50581507_pgfId-236537]##link:JavaEE_Platform_Spec.htm#50581522_pgfId-46505[EE.A.3
Java EE 7 Application Client XML Schema 255]

{empty}[#50581507_pgfId-236539]##link:JavaEE_Platform_Spec.htm#50581522_pgfId-45741[EE.A.4
Java EE 6 Application XML Schema 258]

{empty}[#50581507_pgfId-236541]##link:JavaEE_Platform_Spec.htm#50581522_pgfId-31197[EE.A.5
Common Java EE XML Schema Definitions 261]

{empty}[#50581507_pgfId-236543]##link:JavaEE_Platform_Spec.htm#50581522_pgfId-32998[EE.A.6
Java EE 6 Application Client XML Schema 261]

{empty}[#50581507_pgfId-236545]##link:JavaEE_Platform_Spec.htm#50581522_pgfId-30990[EE.A.7
Java EE 5 Application XML Schema 263]

{empty}[#50581507_pgfId-236547]##link:JavaEE_Platform_Spec.htm#50581522_pgfId-30176[EE.A.8
Common Java EE 5 XML Schema Definitions 264]

{empty}[#50581507_pgfId-236549]##link:JavaEE_Platform_Spec.htm#50581522_pgfId-30178[EE.A.9
Java EE 5 Application Client XML Schema 264]

{empty}[#50581507_pgfId-236551]##link:JavaEE_Platform_Spec.htm#50581522_pgfId-30035[EE.A.10
J2EE 1.4 Application XML Schema 266]

{empty}[#50581507_pgfId-236553]##link:JavaEE_Platform_Spec.htm#50581522_pgfId-26246[EE.A.11
Common J2EE 1.4 XML Schema Definitions 267]

{empty}[#50581507_pgfId-236555]##link:JavaEE_Platform_Spec.htm#50581522_pgfId-25505[EE.A.12
J2EE:application 1.3 XML DTD 267]

{empty}[#50581507_pgfId-236557]##link:JavaEE_Platform_Spec.htm#50581522_pgfId-22711[EE.A.13
J2EE:application 1.2 XML DTD 268]

{empty}[#50581507_pgfId-236559]##link:JavaEE_Platform_Spec.htm#50581522_pgfId-27702[EE.A.14
J2EE 1.4 Application Client XML Schema 268]

{empty}[#50581507_pgfId-236561]##link:JavaEE_Platform_Spec.htm#50581522_pgfId-24230[EE.A.15
J2EE:application-client 1.3 XML DTD 271]

{empty}[#50581507_pgfId-236563]##link:JavaEE_Platform_Spec.htm#50581522_pgfId-18100[EE.A.16
J2EE:application-client 1.2 XML DTD 272]

===== [#50581507_pgfId-236565]##link:JavaEE_Platform_Spec.htm#50581508_pgfId-9484[Appendix EE.B: Revision History 273]

{empty}[#50581507_pgfId-236567]##link:JavaEE_Platform_Spec.htm#50581508_pgfId-6948[EE.B.1
Changes in Early Draft 273]

{empty}[#50581507_pgfId-236569]##link:JavaEE_Platform_Spec.htm#50581508_pgfId-22025[EE.B.1.1
Additional Requirements 273]

{empty}[#50581507_pgfId-236571]##link:JavaEE_Platform_Spec.htm#50581508_pgfId-22086[EE.B.1.2
Editorial Changes 273]

{empty}[#50581507_pgfId-236573]##link:JavaEE_Platform_Spec.htm#50581508_pgfId-22118[EE.B.2
Changes in Early Draft 2 273]

{empty}[#50581507_pgfId-236575]##link:JavaEE_Platform_Spec.htm#50581508_pgfId-22125[EE.B.2.1
Additional Requirements 273]

{empty}[#50581507_pgfId-236577]##link:JavaEE_Platform_Spec.htm#50581508_pgfId-22141[EE.B.2.2
Removed Requirements 274]

{empty}[#50581507_pgfId-236579]##link:JavaEE_Platform_Spec.htm#50581508_pgfId-22169[EE.B.2.3
Editorial Changes 274]

{empty}[#50581507_pgfId-236581]##link:JavaEE_Platform_Spec.htm#50581508_pgfId-22220[EE.B.3
Changes in Public Review Draft 274]

{empty}[#50581507_pgfId-236583]##link:JavaEE_Platform_Spec.htm#50581508_pgfId-22261[EE.B.3.1
Additional Requirements 274]

{empty}[#50581507_pgfId-236585]##link:JavaEE_Platform_Spec.htm#50581508_pgfId-22227[EE.B.3.2
Editorial Changes 274]

{empty}[#50581507_pgfId-236587]##link:JavaEE_Platform_Spec.htm#50581508_pgfId-22360[EE.B.4
Changes in Proposed Final Draft 275]

{empty}[#50581507_pgfId-236589]##link:JavaEE_Platform_Spec.htm#50581508_pgfId-22386[EE.B.4.1
Additional Requirements 275]

{empty}[#50581507_pgfId-236591]##link:JavaEE_Platform_Spec.htm#50581508_pgfId-22366[EE.B.4.2
Editorial Changes 275]

{empty}[#50581507_pgfId-236593]##link:JavaEE_Platform_Spec.htm#50581508_pgfId-22412[EE.B.5
Changes in Final Release Draft 275]

{empty}[#50581507_pgfId-236595]##link:JavaEE_Platform_Spec.htm#50581508_pgfId-22427[EE.B.5.1
Additional Requirements 275]

{empty}[#50581507_pgfId-236597]##link:JavaEE_Platform_Spec.htm#50581508_pgfId-22418[EE.B.5.2
Editorial Changes 275]

===== [#50581507_pgfId-236599]##link:JavaEE_Platform_Spec.htm#50581521_pgfId-14963[Appendix EE.C: Related Documents 277]

======= [#50581510_pgfId-874]## _CHAPTER_ __ [#50581510_32725]##

[#50581510_pgfId-6959]##Introduction

[#50581510_pgfId-999128]## _E_ nterprises today need to extend their
reach, reduce their costs, and lower the response times of their
services to customers, employees, and suppliers.

[#50581510_pgfId-6990]##Typically, applications that provide these
services must combine existing enterprise information systems (EISs)
with new business functions that deliver services to a broad range of
users. The services need to be:

* [#50581510_pgfId-6991]##Highly available, to meet the needs of today’s
global business environment.
* [#50581510_pgfId-6992]##Secure, to protect the privacy of users and
the integrity of the enterprise.
* [#50581510_pgfId-6993]##Reliable and scalable, to ensure that business
transactions are accurately and promptly processed.

[#50581510_pgfId-997557]##In most cases, enterprise services are
implemented as multitier __ applications. The middle tiers integrate
existing EISs with the business functions and data of the new service.
Maturing web technologies are used to provide first tier users with easy
access to business complexities, and eliminate or drastically reduce
user administration and training.

[#50581510_pgfId-997525]##The Java™ Platform, Enterprise Edition (Java™
EE) reduces the cost and complexity of developing multitier, enterprise
services. Java EE applications can be rapidly deployed and easily
enhanced as the enterprise responds to competitive pressures.

[#50581510_pgfId-7002]##Java EE achieves these benefits by defining a
standard architecture with the following elements:

* [#50581510_pgfId-7013]## _Java EE Platform_ - A standard platform for
hosting Java EE applications.
* [#50581510_pgfId-7020]## _Java EE Compatibility Test Suite_ - A suite
of compatibility tests for verifying that a Java EE platform product
complies with the Java EE platform standard.
* [#50581510_pgfId-999097]## _Java EE Reference Implementation_ - A
reference implementation for prototyping Java EE applications and for
providing an operational definition of the Java EE platform.

[#50581510_pgfId-999107]##This document is the Java EE platform
specification. It sets out the requirements that a Java EE platform
product must meet.

==== [#50581510_pgfId-7060]##Acknowledgements for the Initial Version

[#50581510_pgfId-7069]##This specification is the work of many people.
Vlada Matena wrote the first draft as well as the Transaction Management
and Naming chapters. Sekhar Vajjhala, Kevin Osborn, and Ron Monzillo
wrote the Security chapter. Hans Hrasna wrote the Application Assembly
and Deployment chapter. Seth White wrote the JDBC API requirements. Jim
Inscore, Eric Jendrock, and Beth Stearns provided editorial assistance.
Shel Finkelstein, Mark Hapner, Danny Coward, Tom Kincaid, and Tony Ng
provided feedback on many drafts. And of course this specification was
formed and molded based on conversations with and review feedback from
our many industry partners.

==== [#50581510_pgfId-7076]##Acknowledgements for Version 1.3

[#50581510_pgfId-7081]##Version 1.3 of this specification grew out of
discussions with our partners during the creation of version 1.2, as
well as meetings with those partners subsequent to the final release of
version 1.2. Version 1.3 was created under the Java Community Process as
JSR-058. The JSR-058 Expert Group included representatives from the
following companies and organizations: Allaire, BEA Systems, Bluestone
Software, Borland, Bull S.A., Exoffice, Fujitsu Limited, GemStone
Systems, Inc., IBM, Inline Software, IONA Technologies, iPlanet,
jGuru.com, Orion Application Server, Persistence, POET Software,
SilverStream, Sun, and Sybase. In addition, most of the people who
helped with the previous version continued to help with this version,
along with Jon Ellis and Ram Jeyaraman. Alfred Towell provided
significant editorial assistance with this version.

==== [#50581510_pgfId-1000631]##Acknowledgements for Version 1.4

[#50581510_pgfId-1000703]##Version 1.4 of this specification was created
under the Java Community Process as JSR-151. The JSR-151 Expert Group
included the following members: Larry W. Allen (SilverStream Software),
Karl Avedal (Individual), Charlton Barreto (Borland Software
Corporation), Edward Cobb (BEA), Alan Davies (SeeBeyond Technology
Corporation), Sreeram Duvvuru (iPlanet), B.J. Fesq (Individual), Mark
Field (Macromedia), Mark Hapner (Sun Microsystems, Inc.), Pierce Hickey
(IONA), Hemant Khandelwal (Pramati Technologies), Jim Knutson (IBM),
Elika S. Kohen (Individual), Ramesh Loganathan (Pramati Technologies),
Jasen Minton (Oracle Corporation), Jeff Mischkinsky (Oracle
Corporation), Richard Monson-Haefel (Individual), Sean Neville
(Macromedia), Bill Shannon (Sun Microsystems, Inc.), Simon Tuffs (Lutris
Technologies), Jeffrey Wang (Persistence Software, Inc.), and Ingo Zenz
(SAP AG). My colleagues at Sun provided invaluable assistance: Umit
Yalcinalp converted the deployment descriptors to XML Schema; Tony Ng
and Sanjeev Krishnan helped with transaction requirements; Jonathan
Bruce helped with JDBC requirements; Suzette Pelouch, Eric Jendrock, and
Ian Evans provided editorial assistance. Thanks also to all the external
reviewers, including Jeff Estefan (Adecco Technical Services).

==== [#50581510_pgfId-1000729]##Acknowledgements for Version 5

[#50581510_pgfId-1000734]##Version 5 (originally known as version 1.5)
of this specification was created under the Java Community Process as
JSR-244. The JSR-244 Expert Group included the following members: Kilinc
Alkan (Individual), Rama Murthy Amar Pratap (Individual), Charlton
Barreto (Individual), Michael Bechauf (SAP AG), Florent Benoit (INRIA),
Bill Burke (JBoss, Inc.), Muralidharan Chandrasekaran (Individual),
Yongmin Chen (Novell, Inc.), Jun Ho Cho (TmaxSoft), Ed Cobb (BEA), Ugo
Corda (SeeBeyond Technology Corporation), Scott Crawford (Individual),
Arulazi Dhesiaseelan (Hewlett-Packard Company), Bill Dudney
(Individual), Francois Exertier (INRIA), Jeff Genender (The Apache
Software Foundation), Evan Ireland (Sybase, Inc.), Vishy Kasar (Borland
Software Corporation), Michael Keith (Oracle Corporation), Wonseok Kim
(TmaxSoft, Inc.), Jim Knutson (IBM), Elika Kohen (Individual), Felipe
Leme (Individual), Geir Magnusson Jr. (The Apache Software Foundation),
Scott Marlow (Novell, Inc.), Jasen Minton (Oracle Corporation), Jishnu
Mitra (Borland Software Corp), David Morandi (E.piphany), Nathan Pahucki
(Novell, Inc.), David Morandi (E.piphany, Inc.), Ricardo Morin (Intel
Corporation), Nathan Pahucki (Novell, Inc.), Matt Raible (Individual),
Dirk Reinshagen (Individual), Narinder Sahota (Cap Gemini), Suneet Shah
(Individual), Bill Shannon (Sun Microsystems, Inc.), Rajiv Shivane
(Pramati Technologies), Scott Stark (Jboss, Inc), Hani Suleiman
(Ironflare AB), Kresten Krab Thorup (Trifork), Ashish Kumar Tiwari
(Individual), Sivasundaram Umapathy (Individual), Steve Weston (Cap
Gemini), Seth White (BEA Systems), and Umit Yalcinalp (SAP AG). Once
again, my colleagues at Sun provided invaluable assistance: Roberto
Chinnici provided draft proposals for many issues related to dependency
injection.

==== [#50581510_pgfId-1001477]##Acknowledgements for Version 6

[#50581510_pgfId-1001478]##Version 6 of this specification was created
under the Java Community Process as JSR-316. The spec leads for the
JSR-316 Expert Group were Bill Shannon (Sun Microsystems, Inc.) and
Roberto Chinnici (Sun Microsystems, Inc.). The expert group included the
following members: Florent Benoit (Inria), Adam Bien (Individual), David
Blevins (Individual), Bill Burke (Red Hat Middleware LLC), Larry Cable
(BEA Systems), Bongjae Chang (Tmax Soft, Inc.), Rejeev Divakaran
(Individual), Francois Exertier (Inria), Jeff Genender (Individual),
Antonio Goncalves (Individual), Jason Greene (Red Hat Middleware LLC),
Gang Huang (Peking University), Rod Johnson (SpringSource), Werner Keil
(Individual), Michael Keith (Oracle), Wonseok Kim (Tmax Soft, Inc.), Jim
Knutson (IBM), Elika S. Kohen (Individual), Peter Kristiansson (Ericsson
AB), Changshin Lee (NCsoft Corporation), Felipe Leme (Individual), Ming
Li (TongTech Ltd.), Vladimir Pavlov (SAP AG), Dhanji R. Prasanna
(Google), Reza Rahman (Individual), Rajiv Shivane (Pramati
Technologies), Hani Suleiman (Individual).

==== [#50581510_pgfId-1001652]##Acknowledgements for Version 7

[#50581510_pgfId-1001658]##Version 7 of this specification was created
under the Java Community Process as JSR-342. The Expert Group work for
this specification was conducted by means of the
_http://javaee-spec.java.net_ project in order to provide transparency
to the Java community. The specification leads for the JSR-342 Expert
Group were Bill Shannon (Oracle) and Linda DeMichiel (Oracle). The
expert group included the following members: Deepak Anupalli (Pramati
Technologies), Anton Arhipov (ZeroTurnaround), Florent Benoit (OW2),
Adam Bien (Individual), David Blevins (Individual), Markus Eisele
(Individual), Jeff Genender (Individual), Antonio Goncalves
(Individual), Jason Greene (Red Hat, Inc.), Alex Heneveld (Individual),
Minehiko Iida (Fujitsu), Jevgeni Kabanov (Individual), Ingyu Kang (Tmax
Soft, Inc.), Werner Keil (Individual), Jim Knutson (IBM), Ming Li
(TongTech Ltd.), Pete Muir (Red Hat, Inc.), Minoru Nitta (Fujitsu), Reza
Rahman (Caucho Technology, Inc), Kristoffer Sjogren (Ericsson AB), Kevin
Sutter (IBM), Spike Washburn (Individual), Kyung Koo Yoon (TmaxSoft).

[#50581510_pgfId-1001656]## 

==== [#50581510_pgfId-1011287]##Acknowledgements for Version 8

[#50581510_pgfId-1011288]##Version 8 of this specification was created
under the Java Community Process as JSR-366. The Expert Group work for
this specification was conducted by means of the
_http://javaee-spec.java.net_ and _https:javaee.github.io/javaee-spec_
projects in order to provide transparency to the Java community. The
specification leads for the JSR-366 Expert Group were Bill Shannon
(Oracle) and Linda DeMichiel (Oracle). The expert group included the
following members: Florent Benoit (OW2), David Blevins (Tomitribe), Jeff
Genender (Savoir Technologies), Antonio Goncalves (Individual), Jason
Greene (Red Hat), Werner Keil (Individual), Moon Namkoong (TmaxSoft,
Inc.) Antoine Sabot-Durand (Red Hat), Kevin Sutter (IBM), Ruslan
Synytsky (Jelastic, Inc.), Markus Winkler (oparco - open architectures &
consulting). Reza Rahman (Individual) participated as a contributor.

[#50581510_pgfId-1011285]## 

[#50581510_pgfId-1011230]## 

======= [#50581512_pgfId-874]##CHApTER[#50581512_32725]##

[#50581512_pgfId-14708]##[#50581512_33788]##[#50581512_47053]##Platform
Overview

[#50581512_pgfId-6955]## _T_ his chapter provides an overview of the
Java™ Platform, Enterprise Edition (Java EE™).

==== [#50581512_pgfId-16457]##Architecture

[#50581512_pgfId-16455]##The required relationships of architectural
elements of the Java EE platform are shown in
_link:JavaEE_Platform_Spec.htm#50581512_16561[See Java EE Architecture
Diagram]_ . Note that this figure shows the logical relationships of the
elements; it is not meant to imply a physical partitioning of the
elements into separate machines, processes, address spaces, or virtual
machines.

[#50581512_pgfId-16473]##The Containers, denoted by the separate
rectangles, are Java EE runtime environments that provide required
services to the application components represented in the upper half of
the rectangle. The services provided are denoted by the boxes in the
lower half of the rectangle. For example, the Application Client
Container provides Java Message Service (JMS) APIs to Application
Clients, as well as the other services represented. All these services
are explained below. See
link:JavaEE_Platform_Spec.htm#50581512_31166[See Java EE Standard
Services]”.

[#50581512_pgfId-16482]##The arrows represent required access to other
parts of the Java EE platform. The Application Client Container provides
Application Clients with direct access to the Java EE required Database
through the Java API for connectivity with database systems, the JDBC
_TM_ API. Similar access to databases is provided to JSP pages, JSF
applications, and servlets by the Web Container, and to enterprise beans
by the EJB Container.

[#50581512_pgfId-26614]##As indicated, the APIs of the Java _TM_
Platform, Standard Edition (Java SE), are supported by Java SE runtime
environments for each type of application component.

[#50581512_pgfId-26623]## 

[#50581512_pgfId-31388]## 

image:JavaEE_Platform_Spec-1.gif[image]

[#50581512_pgfId-31386]## 

======= [#50581512_pgfId-26619]##[#50581512_16561]##Java EE Architecture Diagram

[#50581512_pgfId-25386]##The following sections describe the Java EE
Platform requirements for each kind of Java EE platform element.

==== [#50581512_pgfId-31527]##Profiles

[#50581512_pgfId-31531]##The Java EE 6 specification introduced the
notion of “profiles” (see
link:JavaEE_Platform_Spec.htm#50581543_19278[See Profiles]”).

[#50581512_pgfId-31468]##A profile is a configuration of the Java EE
platform targeted at a specific class of applications.

[#50581512_pgfId-31419]##Profiles are not a new concept, nor are they
unique to the Java EE platform. The Java Community Process Document
(version 2.10) gives the following definition of a profile: “A
Specification that references one of the Platform Edition Specifications
and zero or more other JCP Specifications (that are not already a part
of a Platform Edition Specification). APIs from the referenced Platform
Edition must be included according to the referencing rules set out in
that Platform Edition Specification. Other referenced specifications
must be referenced in their entirety.”

[#50581512_pgfId-31422]##All Java EE profiles share a set of common
features, such as naming and resource injection, packaging rules,
security requirements, etc. This guarantees a degree of uniformity
across all products and, indirectly, applications that fall under the
“Java EE platform” umbrella. This also ensures that developers who are
familiar with a certain profile, or with the full platform, can move
easily to other profiles, avoiding excessive compartmentalization of
skills and experience.

[#50581512_pgfId-31423]##Beyond the basic functionality outlined above,
profiles are free to include any set of technologies that are part of
the platform, provided that all rules in the present specification that
pertain to the included technologies—either alone or in combination with
others—are followed.

[#50581512_pgfId-31424]##This last point is worth stressing. If profiles
only included pointwise technologies, they would be little more than
bundles of APIs with few or no tie-ins. Instead, the definition of
profiles adopted here guarantees that whenever this specification
defines requirements on combinations of technologies, these requirements
will be honored in all products based on Java EE profiles.

[#50581512_pgfId-31432]##As a concrete example, consider the use of
transactions in a servlet container. In isolation, neither the Servlet
specification nor the Java Transaction API specification defines a
complete programming model for portable applications. This specification
fills that gap by introducing its own set of requirements that pertain
to the combination of Servlets and JTA. These requirements must be
satisfied by any Java EE profile-based product that includes those two
technologies, thus offering application developers a more complete
programming model shared across all relevant Java EE profiles.

[#50581512_pgfId-31440]##A separate specification, the Java EE Web
Profile Specification, defines the Java EE Web Profile, the first
profile of the Java EE platform.

[#50581512_pgfId-31441]##Additional profiles may be defined in
accordance with the rules of the Java Community Process and those
contained in the present specification. In particular, profiles are
initiated by submitting a Java Specification Request and are released at
completion on their own schedule, independently of any concurrent
revision of the platform itself or of other profiles. This ensures
maximum flexibility in defining and releasing a new profile or an
updated version of an existing one.

[#50581512_pgfId-31442]##In accordance with the definition of profiles
given above, a profile may end up being either a proper subset or a
proper superset of the platform, or it may overlap with it to a certain
extent. This flexibility guarantees that future profiles will be able to
cover uses well beyond those originally envisioned by the platform
specification.

[#50581512_pgfId-31443]##As the previous paragraphs made clear, creating
a new profile is a significant undertaking. The decision to create a
profile should take into account its potential drawbacks, especially in
terms of fragmentation and developer confusion. In general, a profile
should be created only when there is a natural developer constituency
and a well-understood class of applications that can benefit from it. It
is also recommended that a profile cast a comprehensive net on its area
of interest, to minimize the occurrence of overlapping or competing
profiles. Java EE platform features such as optional components and
extensibility can be used by profiles to achieve a better fit to their
intended target.

==== [#50581512_pgfId-15508]##[#50581512_30791]##Application Components

[#50581512_pgfId-8712]##The Java EE runtime environment defines four
application component types that a Java EE product must support:

* [#50581512_pgfId-9831]##Application clients are Java programming
language programs that are typically GUI programs that execute on a
desktop computer. Application clients offer a user experience similar to
that of native applications and have access to all of the facilities of
the Java EE middle tier.
* [#50581512_pgfId-7236]##Applets are GUI components that typically
execute in a web browser, but can execute in a variety of other
applications or devices that support the applet programming model.
Applets can be used to provide a powerful user interface for Java EE
applications. (Simple HTML pages can also be used to provide a more
limited user interface for Java EE applications.)
* [#50581512_pgfId-7238]##Servlets, JSP pages, JSF applications,
filters, and web event listeners typically execute in a web container
and may respond to HTTP requests from web clients. Servlets, JSP pages,
JSF applications, and filters may be used to generate HTML pages that
are an application’s user interface. They may also be used to generate
XML or other format data that is consumed by other application
components. A special kind of servlet provides support for web services
using the SOAP/HTTP protocol. Servlets, pages created with the
JavaServer Pages™ technology or JavaServer™ Faces technology, web
filters, and web event listeners are referred to collectively in this
specification as “web components.” Web applications are composed of web
components and other data such as HTML pages. Web components execute in
a web container. A web server includes a web container and other
protocol support, security support, and so on, as required by Java EE
specifications.
* [#50581512_pgfId-7240]##Enterprise JavaBeans™ (EJB) components execute
in a managed environment that supports transactions. Enterprise beans
typically contain the business logic for a Java EE application.
Enterprise beans may directly provide web services using the SOAP/HTTP
protocol.

======= [#50581512_pgfId-15513]##Java EE Server Support for Application Components

[#50581512_pgfId-16351]##The Java EE servers provide deployment,
management, and execution support for conforming application components.
Application components can be divided into three categories according to
their dependence on a Java EE server:

* [#50581512_pgfId-16378]##Components that are deployed, managed, and
executed on a Java EE server. These components include web components
and Enterprise JavaBeans components. See the separate specifications for
these components.
* [#50581512_pgfId-16383]##Components that are deployed and managed on a
Java EE server, but are loaded to and executed on a client machine.
These components include web resources such as HTML pages and applets
embedded in HTML pages.
* [#50581512_pgfId-16365]##Components whose deployment and management is
not completely defined by this specification. Application Clients fall
into this category. Future versions of this specification may more fully
define deployment and management of Application Clients. See
link:JavaEE_Platform_Spec.htm#50581520_24744[See Application Clients],”
for a description of Application Clients.

==== [#50581512_pgfId-15547]##Containers

[#50581512_pgfId-16394]##Containers provide the runtime support for Java
EE application components. Containers provide a federated view of the
underlying Java EE APIs to the application components. Java EE
application components never interact directly with other Java EE
application components. They use the protocols and methods of the
container for interacting with each other and with platform services.
Interposing a container between the application components and the Java
EE services allows the container to transparently inject the services
required by the component, such as declarative transaction management,
security checks, resource pooling, and state management.

[#50581512_pgfId-15574]##A typical Java EE product will provide a
container for each application component type: application client
container, applet container, web component container, and enterprise
bean container.

======= [#50581512_pgfId-15577]##Container Requirements

[#50581512_pgfId-7262]##This specification requires that containers
provide a Java Compatible™ runtime environment, as defined by the Java
Platform, Standard Edition, v8 specification (Java SE). The applet
container may use the Java Plugin product to provide this environment,
or it may provide it natively. The use of applet containers providing
JDK™ 1.1 APIs is outside the scope of this specification.

[#50581512_pgfId-7103]##The container tools must understand the file
formats for the packaging of application components for deployment.

[#50581512_pgfId-16411]##The containers are implemented by a Java EE
Product Provider. See the description of the Product Provider role in
link:JavaEE_Platform_Spec.htm#50581512_21486[See Java EE Product
Provider]”.

[#50581512_pgfId-9886]##This specification defines a set of standard
services that each Java EE product must support. These standard services
are described below. The Java EE containers provide the APIs that
application components use to access these services. This specification
also describes standard ways to extend Java EE services with connectors
to other non-Java EE application systems, such as mainframe systems and
ERP systems.

======= [#50581512_pgfId-15586]##Java EE Servers

[#50581512_pgfId-16263]##Underlying a Java EE container is the server of
which it is a part. A Java EE Product Provider typically implements the
Java EE server-side functionality using an existing transaction
processing infrastructure in combination with Java Platform, Standard
Edition (Java SE) technology. The Java EE client functionality is
typically built on Java SE technology.

==== [#50581512_pgfId-7107]##[#50581512_98007]##Resource Adapters

[#50581512_pgfId-15593]##A resource adapter is a system-level software
component that typically implements network connectivity to an external
resource manager. A resource adapter can extend the functionality of the
Java EE platform either by implementing one of the Java EE standard
service APIs (such as a JDBC™ driver), or by defining and implementing a
resource adapter for a connector to an external application system.
Resource adapters may also provide services that are entirely local,
perhaps interacting with native resources. Resource adapters interface
with the Java EE platform through the Java EE service provider
interfaces (Java EE SPI). A resource adapter that uses the Java EE SPIs
to attach to the Java EE platform will be able to work with all Java EE
products.

==== [#50581512_pgfId-9935]##[#50581512_26144]##Database

[#50581512_pgfId-15594]##The Java EE platform requires a database,
accessible through the JDBC API, for the storage of business data. The
database is accessible from web components, enterprise beans, and
application client components. The database need not be accessible from
applets. The Java EE Product Provider must also provide a preconfigured,
default data source for use by the application in accessing this
database. See link:JavaEE_Platform_Spec.htm#50581511_90595[See Default
Data Source]”.

==== [#50581512_pgfId-15619]##[#50581512_31166]##Java EE Standard Services

[#50581512_pgfId-13142]##The Java EE standard services include the
following (specified in more detail later in this document). Some of
these standard services are actually provided by Java SE.

======= [#50581512_pgfId-7612]##HTTP

[#50581512_pgfId-15620]##The HTTP client-side API is defined by the
_java.net_ package. The HTTP server-side API is defined by the servlet,
JSP, and JSF interfaces and by the web services support that is a part
of the Java EE platform.

======= [#50581512_pgfId-7613]##HTTPS

[#50581512_pgfId-15621]##Use of the HTTP protocol over the SSL protocol
is supported by the same client and server APIs as HTTP.

======= [#50581512_pgfId-7614]##Java™ Transaction API (JTA)

[#50581512_pgfId-15622]##The Java Transaction API consists of two parts:

* [#50581512_pgfId-7114]##An application-level demarcation interface
that is used by the container and application components to demarcate
transaction boundaries.
* [#50581512_pgfId-7115]##An interface between the transaction manager
and a resource manager used at the Java EE SPI level.

======= [#50581512_pgfId-9951]##[#50581512_57988]##RMI-IIOP (Proposed Optional)

[#50581512_pgfId-15623]##The RMI-IIOP subsystem is composed of APIs that
allow for the use of RMI-style programming that is independent of the
underlying protocol, as well as an implementation of those APIs that
supports both the Java SE native RMI protocol (JRMP) and the CORBA IIOP
protocol. Java EE applications can use RMI-IIOP, with IIOP protocol
support, to access CORBA services that are compatible with the RMI
programming restrictions (see the RMI-IIOP specification for details).
Such CORBA services would typically be defined by components that live
outside of a Java EE product, usually in a legacy system. Only Java EE
application clients are required to be able to define their own CORBA
services directly, using the RMI-IIOP APIs. Typically such CORBA objects
would be used for callbacks when accessing other CORBA objects.

[#50581512_pgfId-11497]##Java EE products must be capable of exporting
Enterprise JavaBeans components using the IIOP protocol and accessing
enterprise beans using the IIOP protocol, as specified in the EJB
specification. The ability to use the IIOP protocol is required to
enable interoperability between Java EE products, however a Java EE
product may also use other protocols. Requirements for use of the
RMI-IIOP APIs when accessing Enterprise JavaBeans components have been
relaxed as of EJB 3.0. See the Enterprise JavaBeans specification for
details.

[#50581512_pgfId-41374]##Support for CORBA, including use of IIOP and
Java IDL, is Proposed Optional as of Java EE 8. See
link:JavaEE_Platform_Spec.htm#50581515_20153[See Pruned Java
Technologies].”

======= [#50581512_pgfId-41378]##Java IDL (Proposed Optional)

[#50581512_pgfId-15624]##Java IDL allows Java EE application components
to invoke external CORBA objects using the IIOP protocol. These CORBA
objects may be written in any language and typically live outside a Java
EE product. Java EE applications may use Java IDL to act as clients of
CORBA services, but only Java EE application clients are required to be
allowed to use Java IDL directly to present CORBA services themselves.

======= [#50581512_pgfId-7118]##JDBC™ API

[#50581512_pgfId-15625]##The JDBC API is the API for connectivity with
relational database systems. The JDBC API has two parts: an
application-level interface used by the application components to access
a database, and a service provider interface to attach a JDBC driver to
the Java EE platform. Support for the service provider interface is not
required in Java EE products. Instead, JDBC drivers should be packaged
as resource adapters that use the facilities of the Connector API to
interface with a Java EE product. The JDBC API is included in Java SE,
but this specification includes additional requirements on JDBC device
drivers.

======= [#50581512_pgfId-30379]##Java™ Persistence API

[#50581512_pgfId-30497]##The Java Persistence API is the standard API
for the management of persistence and object/relational mapping. It
provides an object/relational mapping facility for application
developers using a Java domain model to manage a relational database.
The Java Persistence API is required to be supported in Java EE. It can
also be used in Java SE environments.

======= [#50581512_pgfId-7120]##[#50581512_83297]##Java™ Message Service (JMS)

[#50581512_pgfId-15629]##The Java Message Service is a standard API for
messaging that supports reliable point-to-point messaging as well as the
publish-subscribe model. This specification requires a JMS provider that
implements both point-to-point messaging as well as publish-subscribe
messaging. The Java EE Product Provider must also provide a
preconfigured, default JMS connection factory for use by the application
in accessing this JMS provider. See
link:JavaEE_Platform_Spec.htm#50581511_52679[See Default JMS Connection
Factory]”.

======= [#50581512_pgfId-9847]##Java Naming and Directory Interface™ (JNDI)

[#50581512_pgfId-15630]##The JNDI API is the standard API for naming and
directory access. The JNDI API has two parts: an application-level
interface used by the application components to access naming and
directory services and a service provider interface to attach a provider
of a naming and directory service. The JNDI API is included in Java SE,
but this specification defines additional requirements.

======= [#50581512_pgfId-7215]##JavaMail™

[#50581512_pgfId-15631]##Many Internet applications require the ability
to send email notifications, so the Java EE platform includes the
JavaMail API along with a JavaMail service provider that allows an
application component to send Internet mail. The JavaMail API has two
parts: an application-level interface used by the application components
to send mail, and a service provider interface used at the Java EE SPI
level.

======= [#50581512_pgfId-8955]##JavaBeans™ Activation Framework (JAF)

[#50581512_pgfId-15633]##The JAF API provides a framework for handling
data in different MIME types, originating in different formats and
locations. The JavaMail API makes use of the JAF API. The JAF API is
included in Java SE and so is available to Java EE applications.

======= [#50581512_pgfId-11785]##XML Processing

[#50581512_pgfId-15634]##The Java™ API for XML Processing (JAXP)
provides support for the industry standard SAX and DOM APIs for parsing
XML documents, as well as support for XSLT transform engines. The
Streaming API for XML (StAX) provides a pull-parsing API for XML. The
JAXP and StAX APIs are included in Java SE and so are available to Java
EE applications.

======= [#50581512_pgfId-11786]##Java EE™ Connector Architecture

[#50581512_pgfId-15635]##The Connector architecture is a Java EE SPI
that allows resource adapters that support access to Enterprise
Information Systems to be plugged in to any Java EE product. The
Connector architecture defines a standard set of system-level contracts
between a Java EE server and a resource adapter. The standard contracts
include:

* [#50581512_pgfId-13032]##A connection management contract that lets a
Java EE server pool connections to an underlying EIS, and lets
application components connect to an EIS. This leads to a scalable
application environment that can support a large number of clients
requiring access to EIS systems.
* [#50581512_pgfId-13062]##A transaction management contract between the
transaction manager and an EIS that supports transactional access to EIS
resource managers. This contract lets a Java EE server use a transaction
manager to manage transactions across multiple resource managers. This
contract also supports transactions that are managed internal to an EIS
resource manager without the necessity of involving an external
transaction manager.
* [#50581512_pgfId-13104]##A security contract that enables secure
access to an EIS. This contract provides support for a secure
application environment, which reduces security threats to the EIS and
protects valuable information resources managed by the EIS.
* [#50581512_pgfId-24686]##A thread management contract that allows a
resource adapter to delegate work to other threads and allows the
application server to manage a pool of threads. The resource adapter can
control the security context and transaction context used by the worker
thread.
* [#50581512_pgfId-24687]##A contract that allows a resource adapter to
deliver messages to message driven beans independent of the specific
messaging style, messaging semantics, and messaging infrastructure used
to deliver messages. This contract also serves as the standard message
provider pluggability contract that allows a message provider to be
plugged into any Java EE server via a resource adapter.
* [#50581512_pgfId-24728]##A contract that allows a resource adapter to
propagate an imported transaction context to the Java EE server such
that its interactions with the server and any application components are
part of the imported transaction. This contract preserves the ACID
(atomicity, consistency, isolation, durability) properties of the
imported transaction.
* [#50581512_pgfId-24688]##An optional contract providing a generic
command interface between an application program and a resource adapter.

======= [#50581512_pgfId-11789]##[#50581512_98611]##Security Services

[#50581512_pgfId-15636]##The Java™ Authentication and Authorization
Service (JAAS) enables services to authenticate and enforce access
controls upon users. It implements a Java technology version of the
standard Pluggable Authentication Module (PAM) framework and supports
user-based authorization. The Java™ Authorization Service Provider
Contract for Containers (JACC) defines a contract between a Java EE
application server and an authorization service provider, allowing
custom authorization service providers to be plugged into any Java EE
product. The Java™ Authentication Service Provider Interface for
Containers (JASPIC) defines an SPI by which authentication providers
implementing message authentication mechanisms may be integrated in
client or server message processing containers or runtimes. The Java EE
Security API leverages JASPIC, but provides an easier to use SPI for
authentication of users of web applications and defines identity store
APIs for authentication and authorization.

======= [#50581512_pgfId-22085]##Web Services

[#50581512_pgfId-22086]##Java EE provides full support for both clients
of web services as well as web service endpoints. Several Java
technologies work together to provide support for web services. The Java
API for XML Web Services (JAX-WS) and the Java API for XML-based RPC
(JAX-RPC) both provide support for web service calls using the SOAP/HTTP
protocol. JAX-WS, which is included in Java SE, is the primary API for
web services and is a follow-on to JAX-RPC. JAX-WS offers extensive web
services functionality, with support for multiple bindings/protocols.
JAX-WS and JAX-RPC are fully interoperable when using the SOAP 1.1 over
HTTP protocol as constrained by the WS-I Basic Profile specification.
Support for JAX-RPC has been made optional as of Java EE 7. See
link:JavaEE_Platform_Spec.htm#50581515_20153[See Pruned Java
Technologies]”.

[#50581512_pgfId-28948]##JAX-WS and the Java Architecture for XML
Binding (JAXB) define the mapping between Java classes and XML as used
in SOAP calls, and provide support for 100% of XML Schema. JAXB is
included in Java SE. The SOAP with Attachments API for Java (SAAJ),
which is also included in Java SE, provides support for manipulating low
level SOAP messages. The Web Services for Java EE specification fully
defines the deployment of web service clients and web service endpoints
in Java EE, as well as the implementation of web service endpoints using
enterprise beans. The Web Services Metadata specification defines Java
language annotations that make it easier to develop web services. The
Java API for XML Registries (JAXR) provides client access to XML
registry servers. Support for JAXR has been made optional as of Java EE
7. See link:JavaEE_Platform_Spec.htm#50581515_20153[See Pruned Java
Technologies]”.

[#50581512_pgfId-39400]##The Java API for JSON Processing (JSON-P)
provides a convenient way to process (parse, generate, transform, and
query) JSON text. The Java API for JSON Binding (JSON-B) provides a
convenient way to convert between JSON text and Java objects. The Java
API for WebSocket (WebSocket) is a standard API for creating WebSocket
applications.

[#50581512_pgfId-30730]##The Java API for RESTful Web Services (JAX-RS)
provides support for web services using the REST style. RESTful web
services better match the design style of the web and are often easier
to access using a wide variety of programming languages. JAX-RS provides
a simple high-level API for writing such web services as well as a
low-level API that can be used to control the details of the web service
interaction.

======= [#50581512_pgfId-22883]##Concurrency Utilities

[#50581512_pgfId-39385]##The Concurrency Utilities for Java EE is a
standard API for providing asynchronous capabilities to Java EE
application components through the following types of objects: managed
executor service, managed scheduled executor service, managed thread
factory, and context service.

======= [#50581512_pgfId-39401]##Batch

[#50581512_pgfId-39408]##The Batch Applications for the Java Platform
API (Batch) provides a programming model for batch applications and a
runtime for scheduling and executing jobs.

======= [#50581512_pgfId-39384]##Management

[#50581512_pgfId-22884]##The Java 2 Platform, Enterprise Edition
Management Specification defines APIs for managing Java EE servers using
a special management enterprise bean. The Java™ Management Extensions
(JMX) API is also used to provide some management support.

======= [#50581512_pgfId-22897]##Deployment

[#50581512_pgfId-30733]##The Java 2 Platform, Enterprise Edition
Deployment Specification defines a contract between deployment tools and
Java EE products. The Java EE products provide plug-in components that
run in the deployment tool and allow the deployment tool to deploy
applications into the Java EE product. The deployment tool provides
services used by these plug-in components. Support for the Deployment
Specification has been made optional as of Java EE 7. See
link:JavaEE_Platform_Spec.htm#50581515_20153[See Pruned Java
Technologies].”

==== [#50581512_pgfId-41388]##Interoperability

[#50581512_pgfId-41389]##Many of the APIs described above provide
interoperability with components that are not a part of the Java EE
platform, such as external web or CORBA services.

[#50581512_pgfId-41399]##
_link:JavaEE_Platform_Spec.htm#50581512_23777[See Java EE
Interoperability]_ illustrates the interoperability facilities of the
Java EE platform. (The directions of the arrows indicate the
client/server relationships of the components.)

[#50581512_pgfId-41384]##.

======= [#50581512_pgfId-32763]##[#50581512_23777]##Java EE Interoperability

[#50581512_pgfId-32757]## 

image:JavaEE_Platform_Spec-2.gif[image]

[#50581512_pgfId-23850]## 

==== [#50581512_pgfId-7220]##Flexibility of Product Requirements

[#50581512_pgfId-7221]##This specification doesn’t require that a Java
EE product be implemented by a single program, a single server, or even
a single machine. In general, this specification doesn’t describe the
partitioning of services or functions between machines, servers, or
processes. As long as the requirements in this specification are met,
Java EE Product Providers can partition the functionality however they
see fit. A Java EE product must be able to deploy application components
that execute with the semantics described by this specification.

[#50581512_pgfId-32431]##A typical low end Java EE product will support
applets using the Java Plugin in one of the popular browsers,
application clients each in their own Java virtual machine, and will
provide a single server that supports both web components and enterprise
beans. A high end Java EE product might split the server components into
multiple servers, each of which can be distributed and load-balanced
across a collection of machines. While such machines might exist on-site
in an enterprise, they might also reside, for example, in a public
cloud. This specification does not prescribe or preclude any of these
configurations.

[#50581512_pgfId-11902]##A wide variety of Java EE product
configurations and implementations, all of which meet the requirements
of this specification, are possible. A portable Java EE application will
function correctly when successfully deployed in any of these products.

==== [#50581512_pgfId-9779]##[#50581512_65413]##Java EE Product Packaging

[#50581512_pgfId-41301]##This specification doesn't include requirements
for the packaging of a Java EE product. A Java EE product might be
provided on distribution media, for download on the web, or as a service
available only on the web, for example. A Java EE product must include
implementations of all the APIs required by this specification. These
implementations might depend on other software or services not included
in the Java EE product. The customer may be required to combine or
configure the product with other software or services that are necessary
to meet the requirements of this specification. The documentation for
the Java EE product must fully describe all the required software and
configuration.

[#50581512_pgfId-41303]##For example, a Java EE product might depend on
a database server, a naming service, a mail service, and/or a messaging
service. All configurations in which the product is defined to operate
must include all the software and services necessary to meet the
requirements of this specification.

[#50581512_pgfId-41305]##Whether these services are available (running,
accessible on the network, properly configured, operating correctly,
etc.) may be controlled independently of the Java EE product — they may
be unavailable when the Java EE server is started, or they may fail
while the Java EE server is running. This specification does not require
the Java EE product to assure the availability of these services.
However, if such a service is needed to meet the requirements of this
specification, the Java EE product must ensure that the service has been
configured for use and will be usable when it is available.

[#50581512_pgfId-41299]##For example, this specification requires that
applications can use a database. If the Java EE product requires a
database server to be separately installed, and requires the Java EE
product to be configured to use that database, such configuration must
be done before applications are deployed. This ensures that the
operational environment of applications includes all the required
services.

==== [#50581512_pgfId-41298]##Java EE Product Extensions

[#50581512_pgfId-9787]##This specification describes a minimum set of
facilities available to all Java EE products. A Java EE profile may
include some or all of these facilities, as described in
link:JavaEE_Platform_Spec.htm#50581543_19278[See Profiles]”. Products
implementing the full Java EE platform must provide all of them (see
link:JavaEE_Platform_Spec.htm#50581543_34148[See Full Java EE Product
Requirements]”). Most Java EE products will provide facilities beyond
the minimum required by this specification. This specification includes
only a few limits to the ability of a product to provide extensions. In
particular, it includes the same restrictions as Java SE on extensions
to Java APIs. A Java EE product must not add classes to the Java
programming language packages included in this specification, and must
not add methods or otherwise alter the signatures of the specified
classes.

[#50581512_pgfId-9798]##However, many other extensions are allowed. A
Java EE product may provide additional Java APIs, either other Java
optional packages or other (appropriately named) packages. A Java EE
product may include support for additional protocols or services not
specified here. A Java EE product may support applications written in
other languages, or may support connectivity to other platforms or
applications.

[#50581512_pgfId-11191]##Of course, portable applications will not make
use of any platform extensions. Applications that do make use of
facilities not required by this specification will be less portable.
Depending on the facility used, the loss of portability may be minor or
it may be significant.

[#50581512_pgfId-11197]##We expect Java EE products to vary widely and
compete vigorously on various aspects of quality of service. Products
will provide different levels of performance, scalability, robustness,
availability, and security. In some cases this specification requires
minimum levels of service. Future versions of this specification may
allow applications to describe their requirements in these areas.

==== [#50581512_pgfId-32443]##Platform Roles

[#50581512_pgfId-9489]##This section describes typical Java Platform,
Enterprise Edition roles. In an actual instance, an organization may
divide role functionality differently to match that organization’s
application development and deployment workflow.

[#50581512_pgfId-9490]##The roles are described in greater detail in
later sections of this specification.

======= [#50581512_pgfId-9495]##[#50581512_21486]##Java EE Product Provider

[#50581512_pgfId-11348]##A Java EE Product Provider is the implementor
and supplier of a Java EE product that includes the component
containers, Java EE platform APIs, and other features defined in this
specification. A Java EE Product Provider is typically an application
server vendor, a web server vendor, a database system vendor, or an
operating system vendor. A Java EE Product Provider must make available
the Java EE APIs to the application components through containers. A
Product Provider frequently bases their implementation on an existing
infrastructure.

[#50581512_pgfId-9515]##A Java EE Product Provider must provide the
mapping of the application components to the network protocols as
specified by this specification. A Java EE product is free to implement
interfaces that are not specified by this specification in an
implementation-specific way.

[#50581512_pgfId-9528]##A Java EE Product Provider must provide
application deployment and management tools. Deployment tools enable a
Deployer (see link:JavaEE_Platform_Spec.htm#50581512_16702[See
Deployer]”) to deploy application components on the Java EE product.
Management tools allow a System Administrator (see
link:JavaEE_Platform_Spec.htm#50581512_25875[See System Administrator]”)
to manage the Java EE product and the applications deployed on the Java
EE product. The form of these tools is not prescribed by this
specification.

======= [#50581512_pgfId-9544]##Application Component Provider

[#50581512_pgfId-9545]##There are multiple roles for Application
Component Providers, including, for example, HTML document designers,
document programmers, and enterprise bean developers. These roles use
tools to produce Java EE applications and components.

======= [#50581512_pgfId-11392]##Application Assembler

[#50581512_pgfId-16304]##The Application Assembler takes a set of
components developed by Application Component Providers and assembles
them into a complete Java EE application delivered in the form of an
Enterprise Archive ( _.ear_ ) file. The Application Assembler will
generally use GUI tools provided by either a Platform Provider or Tool
Provider. The Application Assembler is responsible for providing
assembly instructions describing external dependencies of the
application that the Deployer must resolve in the deployment process.

======= [#50581512_pgfId-16306]##[#50581512_16702]##Deployer

[#50581512_pgfId-16307]##The Deployer is responsible for deploying
application clients, web applications, and Enterprise JavaBeans
components into a specific operational environment. The Deployer uses
tools supplied by the Java EE Product Provider to carry out deployment
tasks. Deployment is typically a three-stage process:

. [#50581512_pgfId-9553]##During Installation the Deployer moves
application media to the server, generates the additional
container-specific classes and interfaces that enable the container to
manage the application components at runtime, and installs application
components, and additional classes and interfaces, into the appropriate
Java EE containers.
. [#50581512_pgfId-9557]##During Configuration, external dependencies
declared by the Application Component Provider are resolved and
application assembly instructions defined by the Application Assembler
are followed. For example, the Deployer is responsible for mapping
security roles defined by the Application Assembler onto user groups and
accounts that exist in the target operational environment.
. [#50581512_pgfId-9558]##Finally, the Deployer starts up Execution of
the newly installed and configured application.

[#50581512_pgfId-9559]##In some cases, a specially qualified Deployer
may customize the business logic of the application’s components at
deployment time. For example, using tools provided with a Java EE
product, the Deployer may provide simple application code that wraps an
enterprise bean’s business methods, or customizes the appearance of a
JSP or JSF page.

[#50581512_pgfId-9560]##The Deployer’s output is web applications,
enterprise beans, applets, and application clients that have been
customized for the target operational environment and are deployed in a
specific Java EE container.

[#50581512_pgfId-32493]##For example, in the case of cloud deployments,
the Deployer would be responsible for configuring the application to run
in the cloud environment. The Deployer would install the application
into the cloud environment, configure its external dependencies, and
might handle aspects of provisioning its required resources.

======= [#50581512_pgfId-9565]##[#50581512_25875]##System Administrator

[#50581512_pgfId-9566]##The System Administrator is responsible for the
configuration and administration of the enterprise’s computing and
networking infrastructure. The System Administrator is also responsible
for overseeing the runtime well-being of the deployed Java EE
applications. The System Administrator typically uses runtime monitoring
and management tools provided by the Java EE Product Provider to
accomplish these tasks.

[#50581512_pgfId-32494]##For example, in a cloud scenario, the System
Administrator would be responsible for installing, configuring,
managing, and maintaining the cloud environment, including the resources
that are made available to applications running in the environment.

======= [#50581512_pgfId-9827]##Tool Provider

[#50581512_pgfId-9828]##A Tool Provider provides tools used for the
development and packaging of application components. A variety of tools
are anticipated, corresponding to the types of application components
supported by the Java EE platform. Platform independent tools can be
used for all phases of development through the deployment of an
application and the management and monitoring of an application server.

======= [#50581512_pgfId-24707]##System Component Provider

[#50581512_pgfId-24708]##A variety of system level components may be
provided by System Component Providers. The Connector Architecture
defines the primary APIs used to provide resource adapters of many
types. These resource adapters may connect to existing enterprise
information systems of many types, including databases and messaging
systems. Another type of system component is an authorization policy
provider as defined by the Java Authorization Service Provider Contract
for Containers specification.

==== [#50581512_pgfId-32930]##Platform Contracts

[#50581512_pgfId-9416]##This section describes the Java Platform,
Enterprise Edition contracts that must be fulfilled by a Java EE Product
Provider implementing the full Java EE platform. Java EE profiles may
include some or all of these facilities, as described in
link:JavaEE_Platform_Spec.htm#50581543_19278[See Profiles]”.

======= [#50581512_pgfId-9423]##Java EE APIs

[#50581512_pgfId-9430]##The Java EE APIs define the contract between the
Java EE application components and the Java EE platform. The contract
specifies both the runtime and deployment interfaces.

[#50581512_pgfId-9440]##The Java EE Product Provider must implement the
Java EE APIs in a way that supports the semantics and policies described
in this specification. The Application Component Provider provides
components that conform to these APIs and policies.

======= [#50581512_pgfId-11908]##Java EE Service Provider Interfaces (SPIs)

[#50581512_pgfId-11909]##The Java EE Service Provider Interfaces (SPIs)
define the contract between the Java EE platform and service providers
that may be plugged into a Java EE product. The Connector APIs define
service provider interfaces for integrating resource adapters with a
Java EE application server. Resource adapter components implementing the
Connector APIs are called Connectors. The Java EE Authorization APIs
define service provider interfaces for integrating security
authorization mechanisms with a Java EE application server.

[#50581512_pgfId-11910]##The Java EE Product Provider must implement the
Java EE SPIs in a way that supports the semantics and policies described
in this specification. A provider of Service Provider components (for
example, a Connector Provider) should provide components that conform to
these SPIs and policies.

======= [#50581512_pgfId-9459]##Network Protocols

[#50581512_pgfId-9463]##This specification defines the mapping of
application components to industry-standard network protocols. The
mapping allows client access to the application components from systems
that have not installed Java EE product technology. See
link:JavaEE_Platform_Spec.htm#50581517_85284[See Interoperability],” for
details on the network protocol support required for interoperability.

[#50581512_pgfId-9410]##The Java EE Product Provider is required to
publish the installed application components on the industry-standard
protocols. This specification defines the mapping of servlets and JSP
pages to the HTTP and HTTPS protocols, and the mapping of EJB components
to IIOP and SOAP protocols.

======= [#50581512_pgfId-11200]##Deployment Descriptors and Annotations

[#50581512_pgfId-11201]##Deployment descriptors and Java language
annotations are used to communicate the needs of application components
to the Deployer. The deployment descriptor and class file annotations
are a contract between the Application Component Provider or Assembler
and the Deployer. The Application Component Provider or Assembler is
required to specify the application component’s external resource
requirements, security requirements, environment parameters, and so
forth in the component’s deployment descriptor or through class file
annotations. The Java EE Product Provider is required to provide a
deployment tool that interprets the Java EE deployment descriptors and
class file annotations and allows the Deployer to map the application
component’s requirements to the capabilities of a specific Java EE
product and environment.

==== [#50581512_pgfId-25225]##Changes in J2EE 1.3

[#50581512_pgfId-25311]##The J2EE 1.3 specification extends the J2EE
platform with additional enterprise integration facilities. The
Connector API supports integration with external enterprise information
systems. A JMS provider is now required. The JAXP API provides support
for processing XML documents. The JAAS API provides security support for
the Connector API. The EJB specification now requires support for
interoperability using the IIOP protocol.

[#50581512_pgfId-25312]##Significant changes have been made to the EJB
specification. The EJB specification has a new container-managed
persistence model, support for message driven beans, and support for
local enterprise beans.

[#50581512_pgfId-25324]##Other existing J2EE APIs have been updated as
well. See the individual API specifications for details. Finally, J2EE
1.3 requires support for J2SE 1.3.

==== [#50581512_pgfId-25229]##Changes in J2EE 1.4

[#50581512_pgfId-25233]##The primary focus of J2EE 1.4 is support for
web services. The JAX-RPC and SAAJ APIs provide the basic web services
interoperability support. The Web Services for J2EE specification
describes the packaging and deployment requirements for J2EE
applications that provide and use web services. The EJB specification
was also extended to support implementing web services using stateless
session beans. The JAXR API supports access to registries and
repositories.

[#50581512_pgfId-25241]##Several other APIs have been added to J2EE 1.4.
The J2EE Management and J2EE Deployment APIs enable enhanced tool
support for J2EE products. The JMX API supports the J2EE Management API.
The J2EE Authorization Contract for Containers provides an SPI for
security providers.

[#50581512_pgfId-25247]##Many of the existing J2EE APIs have been
enhanced in J2EE 1.4. J2EE 1.4 builds on J2SE 1.4. The JSP specification
has been enhanced to simplify the development of web applications. The
Connector API now supports integration with asynchronous messaging
systems, including the ability to plug in JMS providers.

[#50581512_pgfId-25253]##Changes in this J2EE platform specification
include support for deploying class libraries independently of any
application and the conversion of deployment descriptor DTDs to XML
Schemas.

[#50581512_pgfId-25257]##Other J2EE APIs have been enhanced as well. For
additional details, see each of the referenced specifications.

==== [#50581512_pgfId-25371]##Changes in Java EE 5

[#50581512_pgfId-30542]##With this release, the platform has a new name
– Java Platform, Enterprise Edition, or Java EE for short. This new name
gets rid of the confusing “2” while emphasizing even in the short name
that this is a Java platform. Previous versions are still referred to
using the old name “J2EE”.

[#50581512_pgfId-25372]##The focus of Java EE 5 is ease of development.
To simplify the development process for programmers just starting with
Java EE, or developing small to medium applications, Java EE 5 makes
extensive use of Java language annotations, which were introduced by
J2SE 5.0. Annotations reduce or eliminate the need to deal with Java EE
deployment descriptors in many cases. Even large applications can
benefit from the simplifications provided by annotations.

[#50581512_pgfId-25519]##One of the major uses of annotations is to
specify injection of resources and other dependencies into Java EE
components. Injection augments the existing JNDI lookup capability to
provide a new simplified model for applications to gain access to the
resources needed from the operational environment. Injection also works
with deployment descriptors to allow the deployer to customize or
override resource settings specified in the application’s source code.

[#50581512_pgfId-25528]##The use of annotations is made even more
effective by providing better defaults. Better default behavior and
better default configuration allows most applications to get the
behavior they want most of the time, without the use of either
annotations or deployment descriptors in many cases. When the default is
not what the application wants, a simple annotation can be used to
specify the required behavior or configuration.

[#50581512_pgfId-30550]##The combination of annotations and better
defaults has greatly simplified the development of applications using
Enterprise JavaBeans technology and applications defining or using web
services. Enterprise beans are now dramatically simpler to develop. Web
services are much easier to develop using the annotations defined by the
Web Services Metadata specification.

[#50581512_pgfId-30523]##The area of web services continues to evolve at
a rapid pace. To provide the latest web services support, the JAX-RPC
technology has evolved into the JAX-WS technology, which makes heavy use
of the JAXB technology to bind Java objects to XML data. Both JAX-WS and
JAXB are new to this version of the platform.

[#50581512_pgfId-30556]##Major additions to Java EE 5 include the JSTL
and JSF technologies that simplify development of web applications, and
the Java Persistence API developed by the EJB 3.0 expert group, which
greatly simplifies mapping Java objects to databases.

[#50581512_pgfId-30549]##Minor additions include the StAX API for XML
parsing. Most APIs from previous versions have been updated with small
to medium improvements.

==== [#50581512_pgfId-30704]##[#50581512_80074]##Changes in Java EE 6

[#50581512_pgfId-32565]##Java EE 6 continues the “ease of development”
focus of Java EE 5.

[#50581512_pgfId-32566]##One of the major improvements introduced in
Java EE 6 is the Contexts and Dependency Injection (CDI) technology,
which provides a uniform framework for the dependency injection and
lifecycle management of “managed beans”.

[#50581512_pgfId-32567]##The Java EE 6 Managed Bean specification
defines the commonalities across the spectrum of Java EE managed
objects, extending from basic managed beans through EJB components.

[#50581512_pgfId-32568]##The Bean Validation specification, introduced
in this release, provides a facility for validation of managed objects.
Bean Validation is integrated into the Java Persistence API, where it
provides an automated facility for the validation of JPA entities.

[#50581512_pgfId-32570]##Java EE 6 adds the JAX-RS API as a required
technology of the Java EE Platform. JAX-RS is the API for the
development of Web services built according to the Representational
State Transfer (REST) architectural style.

[#50581512_pgfId-32575]##Java EE 6 also introduces the Java EE Web
Profile, the first new profile of the Java EE Platform.

==== [#50581512_pgfId-32562]##Changes in Java EE 7

[#50581512_pgfId-38720]##Since its inception, the Java EE platform has
been targeted at offloading the developer from common infrastructure
tasks through its container-based model and abstraction of resource
access. In recent releases the platform has considerably simplified the
APIs for access to container services while broadening the range of the
services available. In this release we continue the direction of
improved simplification, while extending the range of the Java EE
platform to encompass emerging technologies in the web space.

[#50581512_pgfId-38722]##The Java EE 7 platform adds first-class support
for recent developments in web standards, including Web Sockets and
JSON, which provide the underpinnings for HTML 5 support in Java EE.
Java EE 7 also adds a modern HTTP client API as defined by JAX-RS 2.0.

[#50581512_pgfId-39409]##Also new in the Java EE 7 platform is the Batch
API, which provides a programming model for batch applications and a
runtime for scheduling and executing jobs, and the Concurrency Utilities
API, which provides asynchronous capabilities by means of managed
executor service, managed scheduled executor service, managed thread
factory, and context service.

[#50581512_pgfId-38724]##The CDI dependency injection facility
introduced in Java EE 6 is enhanced as well as more broadly utilized by
the Java EE 7 platform technologies, and the managed bean model is
further aligned to remove inconsistencies among Java EE component
classes in aspects of CDI injection and interceptor support. The
declarative transaction functionality introduced by EJB is been made
available in a more general way through CDI interceptors, so that it may
be leveraged by other managed beans. The Bean Validation facility is
extended to the automatic validation of method invocations and likewise
made available via CDI interceptors.

[#50581512_pgfId-38726]##Java EE 7 also continues the "ease of
development" focus of Java EE 5 and Java EE 6. Most notably, Java EE 7
includes a revised and greatly simplified JMS 2.0 API. Ease of
development encompasses ease of configuration as well. To that end, Java
EE 7 broadens the resource definition facilities introduced in Java EE 6
to encompass more of the standard platform resource types, and also
provides default database and JMS connection factory resources. It also
improves the configuration of application security, including new
descriptors for security permissions. Java EE 7 further simplifies the
platform by making optional the technologies that were identified as
candidates for pruning in Java EE 6, namely: EJB Entity Beans, JAX-RPC
1.1, JAXR 1.0, and JSR-88 1.2.

[#50581512_pgfId-38728]##Finally, Java EE 7 lays groundwork for
enhancements to the platform for use in cloud environments in a future
release. Such features include resource definition metadata, improved
security configuration, and support for database schema generation via
the Java Persistence API.

==== [#50581512_pgfId-41473]##[#50581512_96204]##Changes in Java EE 8

[#50581512_pgfId-41478]##Java EE 8 continues the focus on modern web
applications of Java EE 7 and broadening the range of such applications.
Java EE 8 introduces the JSON Binding API (JSON-B) for mapping between
JSON text and Java objects, building on the JSON Processing API (JSON-P)
introduced in Java EE 7. The JSON Processing API itself is updated to
reflect additional JSON standards. Servlet undergoes major enhancement
with the addition of support for the new HTTP/2 protocol. JAX-RS adds
support for server-sent events and, building on concurrency facilities
added in Java SE 8, a reactive client API. The new Java EE Security API
provides enhanced support for authentication and authorization in web
modules, and also introduces APIs for access to identity stores. The
Bean Validation facility is updated to reflect enhancements made in Java
SE 8 and to extend the range of validated objects. While the focus of
CDI in this release is to extend its scope beyond Java EE with the
introduction of a bootstrapping API, CDI also includes enhancements for
event processing and alignment on Java SE 8 features.

[#50581512_pgfId-38745]## 

======= [#50581514_pgfId-874]##CHAPTER

[#50581514_pgfId-5529]##[#50581514_20029]##Security

[#50581514_pgfId-13257]## _T_ his chapter describes the security
requirements for the Java™ Platform, Enterprise Edition (Java EE) that
must be satisfied by Java EE products.

[#50581514_pgfId-11522]##In addition to the Java EE requirements, each
Java EE Product Provider will determine the level of security and
security assurances that will be provided by their implementation.

==== [#50581514_pgfId-20726]##Introduction

[#50581514_pgfId-20727]##Almost every enterprise has security
requirements and specific mechanisms and infrastructure to meet them.
Sensitive resources that can be accessed by many users or that often
traverse unprotected open networks (such as the Internet) need to be
protected.

[#50581514_pgfId-18737]##Although the quality assurances and
implementation details may vary, they all share some of the following
characteristics:

* [#50581514_pgfId-8143]## _Authentication_ : The means by which
communicating entities (for example, client and server) prove to one
another that they are acting on behalf of specific identities that are
authorized for access.
* [#50581514_pgfId-18570]## _Access control for resources_ : The means
by which interactions with resources are limited to collections of users
or programs for the purpose of enforcing integrity, confidentiality, or
availability constraints.
* [#50581514_pgfId-14340]## _Data integrity_ : The means used to prove
that information has not been modified by a third party (some entity
other than the source of the information). For example, a recipient of
data sent over an open network must be able to detect and discard
messages that were modified after they were sent.
* [#50581514_pgfId-8146]## _Confidentiality or Data Privacy_ : The means
used to ensure that information is made available only to users who are
authorized to access it.
* [#50581514_pgfId-8147]## _Non-repudiation_ : The means used to prove
that a user performed some action such that the user cannot reasonably
deny having done so.
* [#50581514_pgfId-18555]## _Auditing_ : The means used to capture a
tamper-resistant record of security related events for the purpose of
being able to evaluate the effectiveness of security policies and
mechanisms.

[#50581514_pgfId-18559]##This chapter specifies how Java EE platform
requirements address security requirements, and identifies requirements
that may be addressed by Java EE Product Providers. Finally, issues
being considered for future versions of this specification are briefly
mentioned in link:JavaEE_Platform_Spec.htm#50581514_28962[See Future
Directions]”.

==== [#50581514_pgfId-13487]##A Simple Example

[#50581514_pgfId-18759]##The security behavior of a Java EE environment
may be better understood by examining what happens in a simple
application with a web client, a JSP user interface, and enterprise bean
business logic. (The example is not meant to specify requirements.)

[#50581514_pgfId-18760]##In this example, the web client relies on the
web server to act as its authentication proxy by collecting user
authentication data from the client and using it to establish an
authenticated session.

======= [#50581514_pgfId-16886]##Initial Request

[#50581514_pgfId-19524]##The web client requests the main application
URL, shown in _link:JavaEE_Platform_Spec.htm#50581514_20931[See Initial
Request]_ .

image:JavaEE_Platform_Spec-3.gif[image]

======= [#50581514_pgfId-19546]##[#50581514_20931]##Initial Request

[#50581514_pgfId-13519]##Since the client has not yet authenticated
itself to the application environment, the server responsible for
delivering the web portion of the application (hereafter referred to as
“web server”) detects this and invokes the appropriate authentication
mechanism for this resource.

======= [#50581514_pgfId-13520]##Initial Authentication

[#50581514_pgfId-13521]##The web server returns a form that the web
client uses to collect authentication data (for example, username and
password) from the user. The web client forwards the authentication data
to the web server, where it is validated by the web server, as shown in
_link:JavaEE_Platform_Spec.htm#50581514_13056[See Initial
Authentication]_ .

image:JavaEE_Platform_Spec-4.gif[image]

======= [#50581514_pgfId-13553]##[#50581514_13056]##Initial Authentication

[#50581514_pgfId-16918]##The validation mechanism may be local to the
server, or it may leverage the underlying security services. On the
basis of the validation, the web server sets a credential for the user.

======= [#50581514_pgfId-16919]##URL Authorization

[#50581514_pgfId-16920]##The credential is used for future
determinations of whether the user is authorized to access restricted
resources it may request. The web server consults the security policy
(derived from the deployment descriptor) associated with the web
resource to determine the security roles that are permitted access to
the resource. The web container then tests the user’s credential against
each role to determine if it can map the user to the role.
_link:JavaEE_Platform_Spec.htm#50581514_28520[See URL Authorization]_
shows this process.

image:JavaEE_Platform_Spec-5.gif[image]

======= [#50581514_pgfId-13598]##[#50581514_28520]##URL Authorization

[#50581514_pgfId-13599]##The web server’s evaluation stops with an “is
authorized” outcome when the web server is able to map the user to a
role. A “not authorized” outcome is reached if the web server is unable
to map the user to any of the permitted roles.

======= [#50581514_pgfId-13600]##Fulfilling the Original Request

[#50581514_pgfId-22571]##If the user is authorized, the web server
returns the result of the original URLrequest, as shown in
_link:JavaEE_Platform_Spec.htm#50581514_34034[See Fulfilling the
Original Request]_ .

image:JavaEE_Platform_Spec-6.gif[image]

======= [#50581514_pgfId-25100]##[#50581514_34034]##Fulfilling the Original Request

[#50581514_pgfId-19751]##In our example, the response URL of a JSP page
is returned, enabling the user to post form data that needs to be
handled by the business logic component of the application.

======= [#50581514_pgfId-14074]##Invoking Enterprise Bean Business Methods

[#50581514_pgfId-13644]##The JSP page performs the remote method call to
the enterprise bean, using the user’s credential to establish a secure
association between the JSP page and the enterprise bean (as shown in
_link:JavaEE_Platform_Spec.htm#50581514_15268[See Invoking an Enterprise
Bean Business Method]_ ). The association is implemented as two related
security contexts, one in the web server and one in the EJB container.

image:JavaEE_Platform_Spec-7.gif[image]

======= [#50581514_pgfId-13708]##[#50581514_15268]##Invoking an Enterprise Bean Business Method

[#50581514_pgfId-18844]##The EJB container is responsible for enforcing
access control on the enterprise bean method. It consults the security
policy (derived from the deployment descriptor) associated with the
enterprise bean to determine the security roles that are permitted
access to the method. For each role, the EJB container uses the security
context associated with the call to determine if it can map the caller
to the role.

[#50581514_pgfId-18933]##The container’s evaluation stops with an “is
authorized” outcome when the container is able to map the caller’s
credential to a role. A “not authorized” outcome is reached if the
container is unable to map the caller to any of the permitted roles. A
“not authorized” result causes an exception to be thrown by the
container, and propagated back to the calling JSP page.

[#50581514_pgfId-18934]##If the call “is authorized”, the container
dispatches control to the enterprise bean method. The result of the
bean’s execution of the call is returned to the JSP, and ultimately to
the user by the web server and the web client.

==== [#50581514_pgfId-13485]##Security Architecture

[#50581514_pgfId-12303]##This section describes the Java EE security
architecture on which the security requirements defined by this
specification are based.

======= [#50581514_pgfId-12305]##[#50581514_15151]##Goals

[#50581514_pgfId-19818]##The following are goals for the Java EE
security architecture:

. [#50581514_pgfId-8154]##Portability: The Java EE security architecture
must support the Write Once, Run Anywhere™ application property.
. [#50581514_pgfId-8155]##Transparency: Application Component Providers
should not have to know anything about security to write an application.
. [#50581514_pgfId-8156]##Isolation: The Java EE platform should be able
to perform authentication and access control according to instructions
established by the Deployer using deployment attributes, and managed by
the System Administrator.

[#50581514_pgfId-8157]##Note that divorcing the application from
responsibility for security ensures greater portability of Java EE
applications.

. [#50581514_pgfId-8158]##Extensibility: The use of platform services by
security-aware applications must not compromise application portability.

[#50581514_pgfId-18875]##This specification provides APIs in the
component programming model for interacting with container/server
security information. Applications that restrict their interactions to
the provided APIs will retain portability.

. [#50581514_pgfId-8159]##Flexibility: The security mechanisms and
declarations used by applications under this specification should not
impose a particular security policy, but facilitate the implementation
of security policies specific to the particular Java EE installation or
application.
. [#50581514_pgfId-8163]##Abstraction: An application component’s
security requirements will be logically specified using Java language
annotations or deployment descriptors. Java language annotations or
deployment descriptors will specify how security roles and access
requirements are to be mapped into environment-specific security roles,
users, and policies. A Deployer may choose to modify the security
properties in ways consistent with the deployment environment. The
annotations or deployment descriptor should document which security
properties can be modified and which cannot.
. [#50581514_pgfId-8164]##Independence: Required security behaviors and
deployment contracts should be implementable using a variety of popular
security technologies.
. [#50581514_pgfId-8165]##Compatibility testing: The Java EE security
requirements architecture must be expressed in a manner that allows for
an unambiguous determination of whether or not an implementation is
compatible.
. [#50581514_pgfId-16064]##Secure interoperability: Application
components executing in a Java EE product must be able to invoke
services provided in a Java EE product from a different vendor, whether
with the same or a different security policy. The services may be
provided by web components or enterprise beans.

======= [#50581514_pgfId-8167]##[#50581514_14197]##Non Goals

[#50581514_pgfId-19817]##The following are not goals for the Java EE
security architecture:

. [#50581514_pgfId-8168]##This specification does not dictate a specific
security policy. Security policies for applications and for enterprise
information systems vary for many reasons unconnected with this
specification. Product Providers can provide the technology needed to
implement and administer desired security policies while adhering to the
requirements of this specification.
. [#50581514_pgfId-8169]##This specification does not mandate a specific
security technology, such as Kerberos, PK, NIS+, or NTLM.
. [#50581514_pgfId-8173]##This specification does not require that the
Java EE security behaviors be universally implementable using any or all
security technologies.
. [#50581514_pgfId-8174]##This specification does not provide any
warranty or assurance of the effective security of a Java EE product.

======= [#50581514_pgfId-11170]##Terminology

[#50581514_pgfId-11171]##This section introduces the terminology that is
used to describe the security requirements of the Java EE platform.

======= [#50581514_pgfId-11175]##Principal

[#50581514_pgfId-11176]##A principal is an entity that can be
authenticated by an authentication protocol in a security service that
is deployed in an enterprise. A principal is identified using a
principal name and authenticated using authentication data. The content
and format of the principal name and the authentication data can vary
depending upon the authentication protocol.

======= [#50581514_pgfId-11177]##Security Policy Domain

[#50581514_pgfId-11178]##A security policy domain, also referred to as a
security domain, is a scope over which a common security policy is
defined and enforced by the security administrator of the security
service.

[#50581514_pgfId-18601]##A security policy domain is also sometimes
referred to as a realm. This specification uses the security policy
domain, or security domain, terminology.

======= [#50581514_pgfId-11179]##Security Technology Domain

[#50581514_pgfId-14897]##A security technology domain is the scope over
which the same security mechanism (for example Kerberos) is used to
enforce a security policy.

[#50581514_pgfId-18604]##A single security technology domain may include
multiple security policy domains, for example.

======= [#50581514_pgfId-11181]##Security Attributes

[#50581514_pgfId-11182]##A set of security attributes is associated with
every principal. The security attributes have many uses (for example,
access to protected resources and auditing of users). Security
attributes can be associated with a principal by an authentication
protocol and/or by the Java EE Product Provider.

[#50581514_pgfId-11189]##The Java EE platform does not specify what
security attributes are associated with a principal.

======= [#50581514_pgfId-11190]##Credential

[#50581514_pgfId-11191]##A credential contains or references information
(security attributes) used to authenticate a principal for Java EE
product services. A principal acquires a credential upon authentication,
or from another principal that allows its credential to be used
(delegation).

[#50581514_pgfId-11288]##This specification does not specify the
contents or the format of a credential. The contents and format of a
credential can vary widely.

======= [#50581514_pgfId-10319]##Container Based Security

[#50581514_pgfId-18961]##Security for components is provided by their
containers in order to achieve the goals for security specified above in
a Java EE environment. A container provides two kinds of security
(discussed in the following sections):

* [#50581514_pgfId-10376]##Declarative security
* [#50581514_pgfId-10397]##Programmatic security

======= [#50581514_pgfId-10317]##[#50581514_37053]##Declarative Security

[#50581514_pgfId-10413]##Declarative security refers to the means of
expressing an application’s security structure, including security
roles, access control, and authentication requirements in
non-programmatic form. Java language annotations and the deployment
descriptor are the primary vehicles for declarative security in the Java
EE platform.

[#50581514_pgfId-11601]##Java language annotations and the deployment
descriptor are a contract between an Application Component Provider and
a Deployer or Application Assembler. They can be used by an application
programmer to represent an application’s security related environmental
requirements. A deployment descriptor can be associated with groups of
components.

[#50581514_pgfId-11607]##A Deployer maps the declarative representation
of the application’s security policy to a security structure specific to
the particular environment. A Deployer uses a deployment tool to process
the annotations and deployment descriptor.

[#50581514_pgfId-11610]##At runtime, the container uses the security
policy security structure derived from the declarative security
information expressed in annotations and the deployment descriptor and
configured by the Deployer to enforce authorization (see
link:JavaEE_Platform_Spec.htm#50581514_27030[See Authorization Model]”).

======= [#50581514_pgfId-11540]##[#50581514_25869]##Programmatic Security

[#50581514_pgfId-11545]##Programmatic security refers to security
decisions made by security aware applications. Programmatic security is
useful when declarative security alone is not sufficient to express the
security model of the application. The API for programmatic security
consists of methods of the Java EE Security API _SecurityContext_
interface, and methods of the EJB _EJBContext_ interface and the servlet
_HttpServletRequest_ interface. The methods of the Java EE Security API
_SecurityContext_ interface are intended to supersede the corresponding
methods of the _EJBContext_ and _HttpServletRequest_ interfaces.

[#50581514_pgfId-29042]##These methods allow components to make business
logic decisions based on the security role of the caller or remote user.
For example they allow the component to determine the principal name of
the caller or remote user to use as a database key. (Note that the form
and content of principal names will vary widely between products and
enterprises, and portable components will not depend on the actual
contents of a principal name. Due to principal name mapping, the same
logical principal may have different names in different containers,
although usually it will be possible to configure a single product to
use consistent principal names. In particular, if a principal name is
used as a key into a database table, and that database table is accessed
from multiple components, containers, or products, the same logical
principal may map to different entries in the database.)

======= [#50581514_pgfId-13075]##Distributed Security

[#50581514_pgfId-13079]##Some Product Providers may produce Java EE
products in which the containers for various component types are
distributed. In a distributed environment, communication between Java EE
components can be subject to security attacks (for example, data
modification and replay attacks).

[#50581514_pgfId-13083]##Such threats can be countered by using a secure
association to secure communications. A secure association is shared
security state information that establishes the basis of a secure
communication between components. Establishing a secure association
could involve several steps, such as:

. [#50581514_pgfId-13084]##Authenticating the target principal to the
client and/or authenticating the client to the target principal.
. [#50581514_pgfId-13085]##Negotiating a quality of protection, such as
confidentiality or integrity.
. [#50581514_pgfId-13086]##Setting up a security context for the
association between the components.

[#50581514_pgfId-13090]##Since a container provides security in Java EE,
secure associations for a component are typically established by a
container. Secure associations for web access are specified here. Secure
associations for access to enterprise beans are described in the EJB
specification.

[#50581514_pgfId-13160]##Product Providers may allow for control over
the quality of protection or other aspects of secure association at
deployment time. Applications can specify their requirements for access
to web resources using annotations or elements in their deployment
descriptor.

[#50581514_pgfId-18625]##This specification does not define mechanisms
that an Application Component Provider can use to communicate
requirements for secure associations with an enterprise bean.

======= [#50581514_pgfId-13072]##[#50581514_27030]##Authorization Model

[#50581514_pgfId-11738]##The Java EE authorization model is based on the
concept of security roles. A security role is a logical grouping of
users that is defined by an Application Component Provider or Assembler.
A Deployer maps roles to security identities (for example principals,
and groups) in the operational environment. Security roles are used with
both declarative security and programmatic security.

[#50581514_pgfId-11758]##Declarative authorization can be used to
control access to an enterprise bean method and is specified in
annotations or in the enterprise bean deployment descriptor. The
_RolesAllows_ , _PermitAll_ , and _DenyAll_ annotations are used to
specify method permissions. An enterprise bean method can also be
associated with a _method-permission_ element in the deployment
descriptor. The _method-permission_ element contains a list of methods
that can be accessed by a given security role. If the calling principal
is in one of the security roles allowed access to a method, the
principal is allowed to execute the method. Conversely, if the calling
principal is in none of the roles, the caller is not allowed to execute
the method. Access to web resources can be protected in a similar
manner.

[#50581514_pgfId-18673]##Security roles are used in the
_SecurityContext_ method _isCallerInRole_ , the _EJBContext_ method
_isCallerInRole_ , and the _HttpServletRequest_ method _isUserInRole_ .
Each method returns _true_ if the calling principal is in the specified
security role.

======= [#50581514_pgfId-18674]##Role Mapping

[#50581514_pgfId-18675]##Enforcement of security constraints on web
resources or enterprise beans, whether programmatic or declarative,
depends upon determination of whether the principal associated with an
incoming request is in a given security role. A container makes this
determination based on the security attributes of the calling principal.
For example,

. [#50581514_pgfId-11013]##A Deployer may have mapped a security role to
a user group in the operational environment or may depend on the default
mapping of security roles to user groups as defined by the Java EE
Security API specification. In this case, the user group of the calling
principal is retrieved from its security attributes. The principal is in
the security role if the principal’s user group matches a user group to
which the security role has been mapped.
. [#50581514_pgfId-11014]##A Deployer may have mapped a security role to
a principal name in a security policy domain. In this case, the
principal name of the calling principal is retrieved from its security
attributes. If this principal name is the same as a principal name to
which the security role was mapped, the calling principal is in the
security role.

[#50581514_pgfId-11015]##The source of security attributes may vary
across implementations of the Java EE platform. Security attributes may
be transmitted in the calling principal’s credential or in the security
context. In other cases, security attributes may be retrieved from an
identity store, or from a trusted third party, such as a directory
service or a security service.

======= [#50581514_pgfId-12959]##HTTP Login Gateways

[#50581514_pgfId-13718]##Secure interoperability between enterprise
beans in different security policy domains is addressed in the EJB
specification. In addition, a component may choose to log in to a
foreign server via HTTP. An application component can be configured to
use SSL mutual authentication for security when accessing a remote
resource using HTTP. Applications using HTTP in this way may choose to
use XML or some other structured format, rather than HTML.

[#50581514_pgfId-14440]##We call the use of HTTP with SSL mutual
authentication to access a remote service an HTTP Login Gateway.
Requirements in this area are specified in
link:JavaEE_Platform_Spec.htm#50581514_48062[See Authentication by Web
Clients].”

======= [#50581514_pgfId-12214]##User Authentication

[#50581514_pgfId-12269]##User authentication is the process by which a
user proves his or her identity to the system. This authenticated
identity is then used to perform authorization decisions for accessing
Java EE application components. An end user can authenticate using
either of the two supported client types:

* [#50581514_pgfId-11897]##Web client
* [#50581514_pgfId-12941]##Application client

======= [#50581514_pgfId-12943]##[#50581514_48062]##Authentication by Web Clients

[#50581514_pgfId-20806]##It is required that a web client be able to
authenticate a user to a web server using any of the following
mechanisms. The Deployer or System Administrator determines which method
to apply to an application or to a group of applications.

* [#50581514_pgfId-12223]##HTTP Basic Authentication

[#50581514_pgfId-20776]##HTTP Basic Authentication is the authentication
mechanism supported by the HTTP protocol. This mechanism is based on a
username and password. A web server requests a web client to
authenticate the user. As part of the request, the web server passes the
realm in which the user is to be authenticated. The web client obtains
the username and the password from the user and transmits them to the
web server. The web server then authenticates the user in the specified
realm (referred to as HTTP Realm in this document).

[#50581514_pgfId-20777]##HTTP Basic Authentication is not secure.
Passwords are sent in simple base64 encoding. The target server is not
authenticated. Additional protection can be applied to overcome these
weaknesses. The password may be protected by applying security at the
transport layer (for example HTTPS) or at the network layer (for
example, IPSEC or VPN).

[#50581514_pgfId-20778]##Despite its limitations, the HTTP Basic
Authentication mechanism is included in this specification because it is
widely used in form based applications.

* [#50581514_pgfId-12224]##HTTPS Client Authentication

[#50581514_pgfId-20787]##End user authentication using HTTPS (HTTP over
SSL) is a strong authentication mechanism. This mechanism requires the
user to possess a Public Key Certificate (PKC). Currently, a PKC is
rarely used by end users on the Internet. However, it is useful for
e-commerce applications and also for a single-signon from within the
browser. For these reasons, HTTPS client authentication is a required
feature of the Java EE platform.

======= [#50581514_pgfId-12225]##Form Based Authentication

[#50581514_pgfId-20797]##The look and feel of a login screen cannot be
varied using the web browser’s built-in authentication mechanisms. This
specification introduces the ability to package standard HTML or
servlet/JSP/JSF based forms for logging in, allowing customization of
the user interface. The form based authentication mechanism introduced
by this specification is described in the Servlet specification.

[#50581514_pgfId-20800]##HTTP Digest Authentication is not widely
supported by web browsers and hence is not required.

[#50581514_pgfId-19042]##A web client can employ a web server as its
authentication proxy. In this case, a client’s credential is established
in the server, where it may be used by the server for various purposes:
to perform authorization decisions, to act as the client in calls to
enterprise beans, or to negotiate secure associations with resources.
Current web browsers commonly rely on proxy authentication.

======= [#50581514_pgfId-12660]##Web Single Signon

[#50581514_pgfId-18611]##HTTP is a stateless protocol. However, many web
applications need support for sessions that can maintain state across
multiple requests from a client. Therefore, it is desirable to:

. [#50581514_pgfId-12799]##Make login mechanisms and policies a property
of the environment the web application is deployed in.
. [#50581514_pgfId-12800]##Be able to use the same login session to
represent a user to all the applications that he or she accesses.
. [#50581514_pgfId-12801]##Require re-authentication of users only when
a security policy domain boundary has been crossed.

[#50581514_pgfId-12894]##Credentials that are acquired through a web
login process are associated with a session. The container uses the
credentials to establish a security context for the session. The
container uses the security context to determine authorization for
access to web resources and for the establishment of secure associations
with other components (including enterprise beans).

======= [#50581514_pgfId-12713]##Login Session

{empty}[#50581514_pgfId-18612]##In the Java EE platform, login session
support is provided by a web container. When a user successfully
authenticates with a web server, the container establishes a login
session context for the user. The login session contains the credentials
associated with the user.link:#pgfId-12877[1]

======= [#50581514_pgfId-12853]##Authentication by Application Clients

[#50581514_pgfId-18613]##Application clients (described in detail in
link:JavaEE_Platform_Spec.htm#50581520_24744[See Application Clients]”)
are client programs that may interact with enterprise beans directly
(that is, without the help of a web browser and without traversing a web
server). Application clients may also access web resources.

[#50581514_pgfId-12860]##Application clients, like the other Java EE
application component types, execute in a managed environment that is
provided by an appropriate container. Application clients are expected
to have access to a graphical display and input device, and are expected
to communicate with a human user.

[#50581514_pgfId-14860]##Application clients are used to authenticate
end users to the Java EE platform, when the users access protected web
resources or enterprise beans.

======= [#50581514_pgfId-12393]##Lazy Authentication

[#50581514_pgfId-12394]##There is a cost associated with authentication.
For example, an authentication process may require exchanging multiple
messages across the network. Therefore, it is desirable to use lazy
authentication, that is, to perform authentication only when it is
needed. With lazy authentication, a user is not required to authenticate
until there is a request to access a protected resource.

[#50581514_pgfId-20761]##Lazy authentication can be used with first-tier
clients (applets, application clients) when they request access to
protected resources that require authentication. At that point the user
can be asked to provide appropriate authentication data. If a user is
successfully authenticated, the user is allowed to access the resource.

==== [#50581514_pgfId-20762]##User Authentication Requirements

[#50581514_pgfId-20763]##The Java EE Product Provider must meet the
following requirements concerning user authentication.

======= [#50581514_pgfId-12814]##Login Sessions

[#50581514_pgfId-19179]##All Java EE web servers must maintain a login
session for each web user. It must be possible for a login session to
span more than one application, allowing a user to log in once and
access multiple applications. The required login session support is
described in the Servlet specification. This requirement of a session
for each web user supports single signon.

[#50581514_pgfId-13790]##Applications can remain independent of the
details of implementing the security and maintenance of login
information. The Java EE Product Provider has the flexibility to choose
authentication mechanisms independent of the applications secured by
these mechanisms.

[#50581514_pgfId-19199]##Lazy authentication must be supported by web
servers for protected web resources. When authentication is required,
one of the three required login mechanisms listed in the next section
may be used.

======= [#50581514_pgfId-12472]##[#50581514_24956]##Required Login Mechanisms

[#50581514_pgfId-9948]##All Java EE products are required to support
three login mechanisms: HTTP basic authentication, SSL mutual
authentication, and form-based login. An application is not required to
use any of these mechanisms, but they are required to be available for
any application’s use.

======= [#50581514_pgfId-9949]##HTTP Basic Authentication

[#50581514_pgfId-16995]##All Java EE products are required to support
HTTP basic authentication (RFC2068). Platform Providers are also
required to support basic authentication over SSL.

======= [#50581514_pgfId-9952]##[#50581514_91016]##SSL Mutual Authentication

[#50581514_pgfId-9956]##TLS 1.2 and the means to perform mutual (client
and server) certificate-based authentication are required by this
specification.

[#50581514_pgfId-29069]##All Java EE products must also support TLS 1.1
and TLS 1.0, to ensure interoperable secure communications with clients;
however, TLS 1.0 should be disabled if not needed for a given
deployment, and TLS 1.1 may be disabled if not needed.

[#50581514_pgfId-29070]##Similarly, all Java EE products must support
the following cipher suites, to ensure interoperable secure
communications with clients:

* [#50581514_pgfId-29073]## _TLS_RSA_WITH_AES_128_CBC_SHA_
* [#50581514_pgfId-29074]## _TLS_DHE_RSA_WITH_AES_128_CBC_SHA_
* [#50581514_pgfId-29075]## _TLS_ECDH_RSA_WITH_AES_128_CBC_SHA_
* [#50581514_pgfId-29076]## _TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA_
* [#50581514_pgfId-29077]## _TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA_
* [#50581514_pgfId-29156]## _TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA_

[#50581514_pgfId-29138]##However, it is recommended to use the strongest
possible cipher suite that can be negotiated between client and server,
and the above cipher suites may be disabled in favor of stronger cipher
suites, if not needed for a given deployment.

[#50581514_pgfId-29122]##Note that previous versions of this
specification required support for SSL 3.0, and for the following cipher
suites:

* [#50581514_pgfId-24910]## _TLS_RSA_WITH_RC4_128_MD5_
* [#50581514_pgfId-24897]## _SSL_RSA_WITH_RC4_128_MD5_
* [#50581514_pgfId-24917]## _TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA_
* [#50581514_pgfId-24915]## _SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA_
* [#50581514_pgfId-24906]## _TLS_RSA_EXPORT_WITH_RC4_40_MD5_
* [#50581514_pgfId-9957]## _SSL_RSA_EXPORT_WITH_RC4_40_MD5_
* [#50581514_pgfId-24901]## _TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA_
* [#50581514_pgfId-9962]## _SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA_

[#50581514_pgfId-14843]##SSL 3.0 was officially deprecated by RFC 7568
in 2015, and is unsupported or disabled by default in many TLS
implementations. None of the above cipher suites is currently considered
secure, and may be unsupported or disabled by default. In extreme cases,
it may be necessary to use SSL 3.0, or to negotiate one of the above
cipher suites, in order to interoperate with an older client or a
previous version of Java EE. However, it is recommended to use TLS 1.0
or higher, and to negotiate a stronger cipher suite, whenever possible.
SSL 3.0, and the above listed cipher suites, should be disabled if not
needed for interoperability in a given deployment.

======= [#50581514_pgfId-14190]##Form Based Login

[#50581514_pgfId-13843]##The web application deployment descriptor
contains an element that causes a Java EE product to associate an HTML
form resource (perhaps dynamically generated) with the web application.
If the Deployer chooses this form of authentication (over HTTP basic, or
SSL certificate based authentication), this form must be used as the
user interface for login to the application.

[#50581514_pgfId-13844]##The form based login mechanism and web
application deployment descriptors are described in the Servlet
specification.

======= [#50581514_pgfId-15875]##[#50581514_26496]##Unauthenticated Users

[#50581514_pgfId-15878]##Web containers are required to support access
to web resources by clients that have not authenticated themselves to
the container. This is the common mode of access to web resources on the
Internet.

[#50581514_pgfId-28986]##A web container reports that no user has been
authenticated by returning _null_ from the _SecurityContext_ method
_getCallerPrincipal_ or the _HttpServletRequest_ method
_getUserPrincipal_ . This is different than the result of the
_EJBContext_ method _getCallerPrincipal_ . The EJB specification
requires that the _EJBContext_ method _getCallerPrincipal_ always return
a valid _Principal_ object. This method can never return _null_ . The
_SecurityContext_ method _getCallerPrincipal_ can also be called in the
EJB container, and still returns _null_ for anonymous users.

[#50581514_pgfId-19229]##In Java EE products that contain both a web
container and an EJB container, components running in a web container
must be able to call enterprise beans even when no user has been
authenticated in the web container. When a call is made in such a case
from a component in a web container to an enterprise bean, a Java EE
product must provide a principal for use in the call.

[#50581514_pgfId-15882]##A Java EE product may provide a principal for
use by unauthenticated callers using many approaches, including, but not
limited to:

* [#50581514_pgfId-15892]##Always use a single distinguished principal.
* [#50581514_pgfId-15897]##Use a different distinguished principal per
server, or per session, or per application.
* [#50581514_pgfId-15906]##Allow the deployer or system administrator to
choose which principal to use through the Run As capability of the web
and enterprise bean containers.

[#50581514_pgfId-15913]##This specification does not specify how a Java
EE product should choose a principal to represent unauthenticated users,
although future versions of this specification may add requirements in
this area. Note that the EJB specification does include requirements in
this area when using the EJB interoperability protocol. Applications are
encouraged to use the Run As capability in cases where the web component
may be unauthenticated and needs to call EJB components.

======= [#50581514_pgfId-10253]##[#50581514_16811]##Application Client User Authentication

[#50581514_pgfId-10256]##The application client container must provide
authentication of application users to satisfy the authentication and
authorization constraints enforced by the enterprise bean containers and
web containers. The techniques used may vary with the implementation of
the application client container, and are beyond the control of the
application. The application client container may integrate with a Java
EE product’s authentication system, to provide a single signon
capability, or the container may authenticate the user when the
application is started. The container may delay authentication until
there is a request to access a protected resource or enterprise bean.

[#50581514_pgfId-16122]##The container will provide an appropriate user
interface for interactions with the user to gather authentication data.
In addition, an application client may provide a class that implements
the _javax.security.auth.callback.CallbackHandler_ interface and specify
the class name in its deployment descriptor (see
link:JavaEE_Platform_Spec.htm#50581520_62711[See Java EE Application
Client XML Schema]” for details). The Deployer may override the callback
handler specified by the application and require use of the container’s
default authentication user interface instead.

[#50581514_pgfId-16126]##If use of a callback handler has been
configured by the Deployer, the application client container must
instantiate an object of this class and use it for all authentication
interactions with the user. The application’s callback handler must
support all the _Callback_ objects specified in the
_javax.security.auth.callback_ package.

[#50581514_pgfId-15315]##Application clients may execute in an
environment controlled by a Java SE security manager and are subject to
the security permissions defined in
link:JavaEE_Platform_Spec.htm#50581515_98360[See Java Platform, Standard
Edition (Java SE) Requirements].” Although this specification does not
define the relationship between the operating system identity associated
with a running application client and the authenticated user identity,
support for single signon requires that the Java EE product be able to
relate these identities. Additional application client requirements are
described in link:JavaEE_Platform_Spec.htm#50581520_32725[See CHApter]
of this specification.

======= [#50581514_pgfId-9979]##[#50581514_51893]##Resource Authentication Requirements

[#50581514_pgfId-9980]##Resources within an enterprise are often
deployed in security policy domains different from the security policy
domain of the application component. The wide variance of authentication
mechanisms used to authenticate the caller to resources leads to the
requirement that a Java EE product provide the means to authenticate in
the security policy domain of the resource.

[#50581514_pgfId-9981]##A Product Provider must support both of the
following:

. [#50581514_pgfId-9982]##Configured Identity. A Java EE container must
be able to authenticate for access to the resource using a principal and
authentication data specified by a Deployer at deployment time.The
authentication must not depend in any way on data provided by the
application components. Providing for the confidential storage of the
authentication information is the responsibility of the Product
Provider.
. [#50581514_pgfId-9983]##Programmatic Authentication. The Java EE
product must provide for specification of the principal and
authentication data for a resource by the application component at
runtime using appropriate APIs. The application may obtain the principal
and authentication data through a variety of mechanisms, including
receiving them as parameters, obtaining them from the component’s
environment, and so forth.

[#50581514_pgfId-15968]##In addition, the following techniques are
recommended but not required by this specification:

[#50581514_pgfId-20850]## 

. [#50581514_pgfId-15971]##Principal Mapping. A resource can have a
principal and attributes that are determined by a mapping from the
identity and security attributes of the requesting principal. In this
case, a resource principal is not based on inheritance of the identity
or security attributes from a requesting principal, but gets its
identity and security attributes based on the mapping.
. [#50581514_pgfId-15982]##Caller Impersonation. A resource principal
acts on behalf of a requesting principal. Acting on behalf of a caller
principal requires delegation of the caller’s identity and credentials
to the underlying resource manager. In some scenarios, a requesting
principal can be a delegate of an initiating principal and the resource
principal is transitively impersonating an initiating principal.

[#50581514_pgfId-15985]##The support for principal delegation is
typically specific to a security mechanism. For example, Kerberos
supports a mechanism for the delegation of authentication. (Refer to the
Kerberos v5 specification for more details.)

. [#50581514_pgfId-19338]##Credentials Mapping. This technique may be
used when an application server and an EIS support different
authentication domains. For example:
. [#50581514_pgfId-19341]##The initiating principal may have been
authenticated and have public key certificate-based credentials.
. [#50581514_pgfId-19340]##The security environment for the resource
manager may be configured with the Kerberos authentication service.

[#50581514_pgfId-19347]##The application server is configured to map the
public key certificate-based credentials associated with the initiating
principal to the Kerberos credentials.

[#50581514_pgfId-16001]##Additional information on resource
authentication requirements can be found in the Connector specification.

==== [#50581514_pgfId-9985]##Authorization Requirements

[#50581514_pgfId-15345]##To support the authorization models described
in this chapter, the following requirements are imposed on Java EE
products.

======= [#50581514_pgfId-15342]##Code Authorization

[#50581514_pgfId-10184]##A Java EE product may restrict the use of
certain Java SE classes and methods to secure and ensure proper
operation of the system. The minimum set of permissions that a Java EE
product is required to grant to a Java EE application is defined in
link:JavaEE_Platform_Spec.htm#50581515_98360[See Java Platform, Standard
Edition (Java SE) Requirements].” All Java EE products must be capable
of deploying application components with exactly these permissions.

[#50581514_pgfId-14670]##A Java EE Product Provider may choose to enable
selective access to resources using the Java protection model. The
mechanism used is Java EE product dependent.

[#50581514_pgfId-14671]##The _permissions.xml_ descriptor (see
link:JavaEE_Platform_Spec.htm#50581515_61934[See Declaring Permissions
Required by Application Components]”) makes it possible to express
permissions that a component needs for access.

======= [#50581514_pgfId-9989]##[#50581514_86207]##Caller Authorization

[#50581514_pgfId-9991]##A Java EE product must enforce the access
control rules specified at deployment time (see
link:JavaEE_Platform_Spec.htm#50581514_11504[See Deployment
Requirements]”) and more fully described in the EJB and Servlet
specifications.

======= [#50581514_pgfId-15394]##Propagated Caller Identities.

[#50581514_pgfId-19348]##In a Java EE product that contains an EJB
container, it must be possible to configure the Java EE product so that
a propagated caller identity is used in all authorization decisions.
With this configuration, for all calls to all enterprise beans from a
single application within a single Java EE product, the principal name
returned by the _EJBContext_ method _getCallerPrincipal_ or the
_SecurityContext_ method _getCallerPrincipal_ must be the same as that
returned by the first enterprise bean in the call chain. If the first
enterprise bean in the call chain is called by a servlet or JSP page,
the principal name must be the same as that returned by the
_HttpServletRequest_ method _getUserPrincipal_ or the _SecurityContext_
method _getCallerPrincipal_ in the calling servlet or JSP page.
(However, if the _HttpServletRequest_ or _SecurityContext_ method
_getCallerPrincipal_ returns _null_ , the principal used in calls to
enterprise beans is not specified by this specification, although it
must still be possible to configure enterprise beans to be callable by
such components.)

[#50581514_pgfId-19354]##Note that this does not require delegation of
credentials, only identification of the caller. A single principal must
be the principal used in authorization decisions for access to all
enterprise beans in the call chain. The requirements in this section
apply only when a Java EE product has been configured to propagate
caller identity.

======= [#50581514_pgfId-19349]##[#50581514_42761]##Run As Identities

[#50581514_pgfId-14848]##Java EE products must also support the Run As
capability that allows the Application Component Provider and the
Deployer to specify an identity under which an enterprise bean or web
component must run. In this case it is the Run As identity that is
propagated to subsequent EJB components, rather than the original caller
identity.

[#50581514_pgfId-19361]##Note that this specification doesn’t specify
any relationship between the Run As identity and any underlying
operating system identity that may be used to access system resources
such as files. However, the Java Authorization Contract for Containers
specification does specify the relationship between the Run As identity
and the access control context used by the Java SE security manager.

==== [#50581514_pgfId-15863]##[#50581514_11504]##Deployment Requirements

[#50581514_pgfId-15864]##All Java EE products must implement the access
control semantics described in all included component specifications,
such as the EJB, JSP, and Servlet specifications; provide a means of
mapping the security roles specified in metadata annotations or the
deployment descriptor to the actual roles exposed by a Java EE product;
and support the default mapping from user groups to roles defined by the
Java EE Security API specification.

[#50581514_pgfId-15865]##While most Java EE products will allow the
Deployer to customize the role mappings and change the assignment of
roles to methods, all Java EE products must support the ability to
deploy applications and components using exactly the mappings and
assignments specified in their metadata annotations or deployment
descriptors.

[#50581514_pgfId-15872]##As described in the EJB specification and the
Servlet specification, a Java EE product must provide a deployment tool
or tools capable of assigning the security roles in metadata annotations
or deployment descriptors to the entities that are used to determine
role membership at authorization time.

[#50581514_pgfId-15922]##Application developers will need to specify (in
the application’s metadata annotations or deployment descriptors) the
security requirements of an application in which some components may be
accessed by unauthenticated users as well as authenticated users (as
described above in link:JavaEE_Platform_Spec.htm#50581514_26496[See
Unauthenticated Users]”). Applications express their security
requirements in terms of security roles, which the Deployer maps to
users (principals) in the operational environment at deployment time. An
application might define a role representing all authenticated and
unauthenticated users and configure some enterprise bean methods to be
accessible by this role.

[#50581514_pgfId-15923]##To support such usage, this specification
requires that it be possible to map an application defined security role
to the universal set of application principals independent of
authentication. __

==== [#50581514_pgfId-28792]##[#50581514_28962]##Future Directions

======= [#50581514_pgfId-10014]##Auditing

[#50581514_pgfId-10015]##This specification does not specify
requirements for the auditing of security relevant events, nor APIs for
application components to generate audit records. A future version of
this specification may include such a specification for products that
choose to provide auditing.

======= [#50581514_pgfId-20883]##Instance-based Access Control

[#50581514_pgfId-20890]##Some applications need to control access to
their data based on the content of the data, rather than simply the type
of the data. We refer to this as “instance-based” rather than
“class-based” access control. We hope to address this in a future
release.

======= [#50581514_pgfId-10992]##User Registration

[#50581514_pgfId-20917]##Web-based internet applications often need to
manage a set of customers dynamically, allowing users to register
themselves as new customers. This scenario was widely discussed in the
Servlet expert group (JSR-53) but we were unable to achieve consensus on
the appropriate solution. We had to abandon this work for J2EE 1.3, and
were not able to address it for J2EE 1.4, but hope to pursue it further
in a future release.

======= [#50581513_pgfId-874]##[#50581513_32725]##CHAPTEr

[#50581513_pgfId-5529]##[#50581513_83214]##Transaction Management

[#50581513_pgfId-6965]## _T_ his chapter describes the required Java™
Platform, Enterprise Edition (Java EE) transaction management and
runtime environment.

[#50581513_pgfId-6969]##Product Providers must transparently support
transactions that involve multiple components and transactional
resources within a single Java EE product, as described in this chapter.
This requirement must be met regardless of whether the Java EE product
is implemented as a single process, multiple processes on the same
network node, or multiple processes on multiple network nodes.

[#50581513_pgfId-17223]##If the following components are included in a
Java EE product, they are considered transactional resources and must
behave as specified here:

* [#50581513_pgfId-17224]##JDBC connections
* [#50581513_pgfId-17225]##JMS sessions
* [#50581513_pgfId-17227]##Resource adapter connections for resource
adapters specifying the _XATransaction_ transaction level

==== [#50581513_pgfId-6976]##[#50581513_29855]##Overview

[#50581513_pgfId-6983]##A Java EE Product that includes both a servlet
container and an EJB container must support a transactional application
comprised of combinations of web application components accessing
multiple enterprise beans within a single transaction. If the Java EE
product also includes support for the Connectors specification, each
component may also acquire one or more connections to access one or more
transactional resource managers.

[#50581513_pgfId-16277]##For example, in
_link:JavaEE_Platform_Spec.htm#50581513_13087[See Servlets/JSP Pages
Accessing Enterprise Beans]_ , the call tree starts from a servlet or
JSP page accessing multiple enterprise beans, which in turn may access
other enterprise beans. The components access resource managers via
connections.

======= [#50581513_pgfId-7701]##[#50581513_13087]##Servlets/JSP Pages Accessing Enterprise Beans

image:JavaEE_Platform_Spec-8.gif[image]

[#50581513_pgfId-17044]##The Application Component Provider specifies,
using a combination of programmatic and declarative transaction
demarcation APIs, how the platform must manage transactions on behalf of
the application.

[#50581513_pgfId-16286]##For example, the application may require that
all the components in _link:JavaEE_Platform_Spec.htm#50581513_13087[See
Servlets/JSP Pages Accessing Enterprise Beans]_ access resources as part
of a single transaction. The Platform Provider must provide the
transaction capabilities to support such a scenario.

[#50581513_pgfId-16278]##This specification does not define how the
components and the resources are partitioned or distributed within a
single Java EE product. In order to achieve the transactional semantics
required by the application, the Java EE Product Provider is free to
execute the application components sharing a transaction in the same
Java virtual machine, or distribute them across multiple virtual
machines, in accordance with the requirements of the component
specifications.

[#50581513_pgfId-16427]##The rest of this chapter describes the
transactional requirements for a Java EE product in more detail. +

==== [#50581513_pgfId-9993]##Requirements

[#50581513_pgfId-16344]##This section defines the transaction support
requirements of Java EE Products that must be supported by Product
Providers.

======= [#50581513_pgfId-19442]##[#50581513_43796]##Web Components

[#50581513_pgfId-17058]##Web components may demarcate transactions using
the _javax.transaction.UserTransaction_ interface or transactional
interceptors, which are defined in the JTA specification. They may
access multiple resource managers and invoke multiple enterprise beans
within a single transaction. The specified transaction context is
automatically propagated to the enterprise beans and transactional
resource managers. The result of the propagation may be subject to the
enterprise bean transaction attributes (for example, a bean may be
required to use Container Managed Transactions).

[#50581513_pgfId-23033]##Web application event listeners and upgrade
handlers must not demarcate transactions using the
_javax.transaction.UserTransaction_ interface or transactional
interceptors. Servlet filters may use transactional resources within
their _doFilter_ methods but should not use any transactional resources
in the methods of any objects used to wrap the request or response
objects.

======= [#50581513_pgfId-19495]##Transaction Requirements

[#50581513_pgfId-17059]##The Java EE platform must meet the following
requirements:

* [#50581513_pgfId-17060]##The Java EE platform must provide an object
implementing the _javax.transaction.UserTransaction_ interface to all
web components. The platform must publish the _UserTransaction_ object
in the Java™ Naming and Directory Interface (JNDI) name space available
to web components under the name _java:comp/UserTransaction_ .
* [#50581513_pgfId-28079]##The Java EE platform must provide classes
that implement the transactional interceptors, as defined by the JTA
specification.
* [#50581513_pgfId-16375]##If a web component invokes an enterprise bean
from a thread associated with a JTA transaction, the Java EE platform
must propagate the transaction context with the enterprise bean
invocation. Whether the target enterprise bean will be invoked in this
transaction context or not is determined by the rules defined in the EJB
specification.

[#50581513_pgfId-17646]##Note that this transaction propagation
requirement applies only to invocations of enterprise beans in the same
Java EE product instancelink:#pgfId-25428[2] as the invoking component.
Invocations of enterprise beans in another Java EE product instance (for
example, using the EJB interoperability protocol) need not propagate the
transaction context. See the EJB specification for details.

* [#50581513_pgfId-16376]##If a web component accesses a transactional
resource manager from a thread associated with a JTA transaction, the
Java EE platform must ensure that the resource access is included as
part of the JTA transaction.
* [#50581513_pgfId-17161]##If a web component creates a thread, the Java
EE platform must ensure that the newly created thread is not associated
with any JTA transaction.

======= [#50581513_pgfId-16439]##[#50581513_54461]##Transaction Non-Requirements

[#50581513_pgfId-19496]##The Product Provider is not required to support
the importing of a transaction context from a client to a web component.

[#50581513_pgfId-19487]##The Product Provider is not required to support
transaction context propagation via an HTTP request across web
components. The HTTP protocol does not support such transaction context
propagation. When a web component associated with a transaction makes an
HTTP request to another web component, the transaction context is not
propagated to the target servlet or page.

[#50581513_pgfId-19485]##However, when a web component is invoked
through the _RequestDispatcher_ interface, any active transaction
context must be propagated to the called servlet or JSP page.

======= [#50581513_pgfId-23021]##[#50581513_92813]##Transactions in Web Component Life Cycles

[#50581513_pgfId-23022]##Transactions may not span web requests from a
client on the network. If a web component starts a transaction in the
_service_ or _doFilter_ method (or transactional interceptor of
_service_ or _doFilter_ method), it must be completed before the
_service_ or _doFilter_ method returns to the network
clientlink:#pgfId-28071[3]. Returning from the _service_ or _doFilter_
method to the network client with an active transaction context is an
error. The web container is required to detect this error and abort the
transaction.

[#50581513_pgfId-26239]##As specified above in
link:JavaEE_Platform_Spec.htm#50581513_54461[See Transaction
Non-Requirements],” requests made within a web container using the
_RequestDispatcher_ must propagate any transaction context to the called
class. Unless the called class commits or aborts the transaction, the
transaction must remain active when the called class returns.

[#50581513_pgfId-26244]##If a servlet that is called via the
_RequestDispatcher_ starts a transaction, the behavior of the container
with regard to that transaction is unspecified when the servlet returns
from its service method. The web container may throw an exception to the
caller, abort the transaction and return to the caller without error, or
propagate the transaction context back to the caller. Portable servlets
will complete any transaction they start before returning from the
service method.

======= [#50581513_pgfId-19530]##[#50581513_48835]##Transactions and Threads

[#50581513_pgfId-16836]##There are many subtle and complex interactions
between the use of transactional resources and threads. To ensure
correct operation, web components should obey the following guidelines,
and the web container must support at least these usages.

* [#50581513_pgfId-16841]##JTA transactions should be started and
completed in the thread in which the _service_ method is called.
Additional threads that are created for any purpose should not attempt
to start JTA transactions.
* [#50581513_pgfId-16842]##Transactional resources may be acquired and
released by a thread other than the _service_ method thread, but should
not be shared between threads.
* [#50581513_pgfId-16843]##Transactional resource objects (for example,
JDBC _Connection_ objects) should not be stored in static fields. Such
objects can only be associated with one transaction at a time. Storing
them in static fields would make it easy to erroneously share them
between threads in different transactions.
* [#50581513_pgfId-16844]##Web components implementing
_SingleThreadModel_ may store top-level transactional resource objects
in class instance fields. A top-level object is one acquired directly
from a container managed connection factory object (for example, a JDBC
_Connection_ acquired from a JDBC _ConnectionFactory_ ), as opposed to
other objects acquired from these top-level objects (for example, a JDBC
_Statement_ acquired from a JDBC _Connection_ ). The web container
ensures that requests to a _SingleThreadModel_ servlet are serialized
and thus only one thread and one transaction will be able to use the
object at a time, and that the top-level object will be enlisted in any
new transaction started by the component.
* [#50581513_pgfId-16845]##In web components not implementing
_SingleThreadModel_ , transactional resource objects, as well as Java
Persistence _EntityManager_ objects, should not be stored in class
instance fields, and should be acquired and released within the same
invocation of the _service_ method.
* [#50581513_pgfId-25547]##Web components that are called by other web
components (using the _forward_ or _include_ methods) should not store
transactional resource objects in class instance fields.
* [#50581513_pgfId-16846]##Enterprise beans may be invoked from any
thread used by a web component. Transaction context propagation
requirements are described above and in the EJB specification.

======= [#50581513_pgfId-16739]##Enterprise JavaBeans™ Components

[#50581513_pgfId-16391]##The Java EE Product Provider must provide
support for transactions as defined in the EJB specification.

======= [#50581513_pgfId-16743]##Application Clients

[#50581513_pgfId-16746]##The Java EE Product Provider is not required to
provide transaction management support for application clients.

======= [#50581513_pgfId-16403]##Applet Clients

[#50581513_pgfId-16404]##The Java EE Product Provider is not required to
provide transaction management support for applets.

======= [#50581513_pgfId-7008]##[#50581513_17555]##Transactional JDBC™ Technology Support

[#50581513_pgfId-16472]##A Java EE product must support a JDBC
technology database as a transactional resource manager. The platform
must enable transactional JDBC API access from web components and
enterprise beans.

[#50581513_pgfId-17247]##It must be possible to access the JDBC
technology database from multiple application components within a single
transaction. For example, a servlet may wish to start a transaction,
access a database, invoke an enterprise bean that accesses the same
database as part of the same transaction, and, finally, commit the
transaction.

[#50581513_pgfId-25485]##A Java EE product must provide a transaction
manager that is capable of coordinating two-phase commit operations
across multiple XA-capable JDBC databases. If a JDBC driver supports the
Java Transaction API’s XA interfaces (in the _javax.transaction.xa_
package), then the Java EE product must be capable of using the XA
interfaces provided by the JDBC driver to accomplish two-phase commit
operations. The Java EE product may discover the XA capabilities of JDBC
drivers through product-specific means, although normally such JDBC
drivers would be delivered as resource adapters using the Connector API.

======= [#50581513_pgfId-17254]##[#50581513_36439]##Transactional JMS Support

[#50581513_pgfId-17255]##A Java EE product must support a JMS provider
as a transactional resource manager. The platform must enable
transactional JMS access from servlets, JSP pages, and enterprise beans.

[#50581513_pgfId-17290]##It must be possible to access the JMS provider
from multiple application components within a single transaction. For
example, a servlet may wish to start a transaction, send a JMS message,
invoke an enterprise bean that also sends a JMS message as part of the
same transaction, and, finally, commit the transaction.

======= [#50581513_pgfId-17296]##Transactional Resource Adapter (Connector) Support

[#50581513_pgfId-17297]##A Java EE product must support resource
adapters that use _XATransaction_ mode as transactional resource
managers. The platform must enable transactional access to the resource
adapter from servlets, JSP pages, and enterprise beans.

[#50581513_pgfId-17298]##It must be possible to access the resource
adapter from multiple application components within a single
transaction. For example, a servlet may wish to start a transaction,
access the resource adapter, invoke an enterprise bean that also
accesses the resource adapter as part of the same transaction, and,
finally, commit the transaction.

==== [#50581513_pgfId-17291]##Transaction Interoperability

======= [#50581513_pgfId-17292]##Multiple Java EE Platform Interoperability

[#50581513_pgfId-13539]##This specification does not require the Product
Provider to implement any particular protocol for transaction
interoperability across multiple Java EE products. Java EE compatibility
requires neither interoperability among identical Java EE products from
the same Product Provider, nor among heterogeneous Java EE products from
multiple Product Providers.

[#50581513_pgfId-16516]##We recommend that Java EE Product Providers use
the IIOP transaction propagation protocol defined by OMG and described
in the OTS specification (and implemented by the Java Transaction
Service), for transaction interoperability when using the EJB
interoperability protocol based on RMI-IIOP.

======= [#50581513_pgfId-16529]##Support for Transactional Resource Managers

[#50581513_pgfId-17722]##This specification requires all Java EE
products to support the _javax.transaction.xa.XAResource_ interface, as
specified in the Connector specification. This specification also
requires all Java EE products to support the
_javax.transaction.xa.XAResource_ interface for performing two-phase
commit operations on JDBC drivers that support the JTA XA APIs. This
specification does not require that JDBC drivers or JMS providers use
the _javax.transaction.xa.XAResource_ interface, although they may use
this interface and in all cases they must meet the transactional
resource manager requirements described in this chapter. In particular,
it must be possible to combine operations on one or more JDBC databases,
one or more JMS sessions, one or more enterprise beans, and multiple
resource adapters supporting the _XATransaction_ mode in a single JTA
transaction.

==== [#50581513_pgfId-17729]##[#50581513_19492]##Local Transaction Optimization

======= [#50581513_pgfId-17880]##Requirements

[#50581513_pgfId-17730]##If a transaction uses a single resource
manager, performance may be improved by using a resource manager
specific local optimization. A local transaction is typically more
efficient than a global transaction and provides better performance.
Local optimization is not available for transactions that are imported
from a different container.

[#50581513_pgfId-17731]##Containers may choose to provide local
transaction optimization, but are not required to do so. Local
transaction optimization must be transparent to a Java EE application.

[#50581513_pgfId-19650]##The following section describes a possible
mechanism for local transaction optimization by containers.

======= [#50581513_pgfId-17881]##A Possible Design

[#50581513_pgfId-17902]##This section illustrates how the previously
described requirements might be implemented.

[#50581513_pgfId-19579]##When the first connection to a resource manager
is established as part of the transaction, a resource manager specific
local transaction is started on the connection. Any subsequent
connection acquired as part of the transaction that can share the local
transaction on the first connection is allowed to share the local
transaction.

[#50581513_pgfId-17890]##A global transaction is started lazily under
the following conditions:

* [#50581513_pgfId-17891]##When a subsequent connection cannot share the
resource manager local transaction on the first connection, or if it
uses a different resource manager.
* [#50581513_pgfId-17892]##When a transaction is exported to a different
container.

[#50581513_pgfId-17893]##After the lazy start of a global transaction,
any subsequent connection acquired may either share the local
transaction on the first connection, or be part of the global
transaction, depending on the resource manager it accesses.

[#50581513_pgfId-17894]##When a transaction completion (commit or
rollback) is attempted, there are two possibilities:

* [#50581513_pgfId-17895]##If only a single resource manager had been
accessed as part of the transaction, the transaction is completed using
the resource manager specific local transaction mechanism.
* [#50581513_pgfId-17896]##If a global transaction had been started, the
transaction is completed treating the resource manager local transaction
as a last resource in the global 2-phase commit protocol, that is using
the last resource 2-phase commit optimization.

==== [#50581513_pgfId-17736]##[#50581513_35180]##Connection Sharing

[#50581513_pgfId-17737]##When multiple connections acquired by a Java EE
application use the same resource manager, containers may choose to
provide connection sharing within the same transaction scope. Sharing
connections typically results in efficient usage of resources and better
performance. Containers are required to provide connection sharing in
certain situations; see the Connector specification for details.

[#50581513_pgfId-17836]##Connections to resource managers acquired by
Java EE applications are considered potentially shared or shareable. A
Java EE application component that intends to use a connection in an
unshareable way must provide deployment information to that effect, to
prevent the connection from being shared by the container. Examples of
when this may be needed include situations with changed security
attributes, isolation levels, character settings, and localization
configuration. Containers must not attempt to share connections that are
marked unshareable. If a connection is not marked unshareable, it must
be transparent to the application whether the connection is actually
shared or not.

[#50581513_pgfId-17840]##Java EE application components may use the
optional _shareable_ element of the _Resource_ annotation or the
optional deployment descriptor element _res-sharing-scope_ to indicate
whether a connection to a resource manager is shareable or unshareable.
Containers must assume connections to be shareable if no deployment hint
is provided. link:JavaEE_Platform_Spec.htm#50581520_62711[See Java EE
Application Client XML Schema]”, the EJB specification, and the Servlet
specification provide descriptions of the deployment descriptor element.

[#50581513_pgfId-17752]##Java EE application components may cache
connection objects and reuse them across multiple transactions.
Containers that provide connection sharing must transparently switch
such cached connection objects (at dispatch time) to point to an
appropriate shared connection with the correct transaction scope. Refer
to the Connector specification for a detailed description of connection
sharing.

==== [#50581513_pgfId-23086]##[#50581513_77552]##JDBC and JMS Deployment Issues

[#50581513_pgfId-23089]##The JDBC transaction requirements in
link:JavaEE_Platform_Spec.htm#50581513_17555[See Transactional JDBC™
Technology Support]” and the JMS transaction requirements in
link:JavaEE_Platform_Spec.htm#50581513_36439[See Transactional JMS
Support]” may impose some restrictions on a Deployer’s configuration of
an application’s JDBC and JMS resources. Java EE Product Providers may
impose the restrictions described in this section to meet these
requirements.

[#50581513_pgfId-23092]##If the deployer configures a non-XA-capable
JDBC resource manager in a transaction, then a Java EE Product Provider
may restrict all JDBC access within that transaction to that
non-XA-capable JDBC resource manager. Otherwise, a Java EE Product
Provider must support use of multiple XA-capable JDBC resource managers
within a transaction. In addition, a Java EE Product Provider may
restrict the security configuration of all JDBC connections within a
transaction to a single user identity. A Java EE Product Provider is not
required to support transactions where more than one JDBC identity is
used. Specifically, this means that transactions that require the use of
more than one JDBC security identity (which can be done explicitly via
component provided user name and password) may not be portable.

[#50581513_pgfId-23094]##A Java EE Product Provider may make the same
restrictions as above, resulting in a transaction being restricted to a
single JMS resource manager and user identity.

[#50581513_pgfId-25436]##In addition, when both a JDBC resource manager
and a JMS resource manager are used in the same transaction, a Java EE
Product Provider may restrict both to a pairing that allows their
combination to deliver the full transactional semantics required by the
application, and may restrict the security identity of both to a single
identity. To fully support such usage, portable applications that wish
to include JDBC and JMS access in a single global transaction must not
mark the corresponding transactional resources as “unshareable”.

[#50581513_pgfId-23087]##Although these restrictions are allowed, it is
recommended that Java EE Product Providers support JDBC and JMS resource
managers that provide full two-phase commit functionality and, as a
result, do not impose these restrictions.

==== [#50581513_pgfId-25470]##[#50581513_13644]##Two-Phase Commit Support

[#50581513_pgfId-25471]##A Java EE product must support the use of
multiple XA-capable resource adapters in a single transaction. To
support such a scenario, full two-phase commit support is required. A
JMS provider may be provided as an XA-capable resource adapter. In such
a case, it must be possible to include JMS operations in the same global
transaction as other resource adapters. While JDBC drivers are not
required to be XA-capable, a JDBC driver may be delivered as an
XA-capable resource adapter. In such a case, it must be possible to
include JDBC operations in the same global transaction as other
XA-capable resource adapters. See also
link:JavaEE_Platform_Spec.htm#50581513_17555[See Transactional JDBC™
Technology Support].”

==== [#50581513_pgfId-17725]##[#50581513_36539]##[#50581513_33084]##System Administration Tools

[#50581513_pgfId-16664]##Although there are no compatibility
requirements for system administration capabilities, the Java EE Product
Provider will typically include tools that allow the System
Administrator to perform the following tasks:

* [#50581513_pgfId-16603]##Integrate transactional resource managers
with the platform.
* [#50581513_pgfId-16604]##Configure the transaction management parts of
the platform.
* [#50581513_pgfId-16605]##Monitor transactions at runtime.
* [#50581513_pgfId-16606]##Receive notifications of abnormal transaction
processing conditions (such as abnormally high number of transaction
rollbacks).

======= [#50581511_pgfId-18363]##CHAPTER __ [#50581511_32725]##

[#50581511_pgfId-1007216]##[#50581511_16122]##Resources, Naming, and
Injection

[#50581511_pgfId-1007217]## _T_ his chapter describes how applications
declare dependencies on external resources and configuration parameters,
and how those items are represented in the Java EE naming system and can
be injected into application components. These requirements are based on
annotations defined in the Java Metadata specification and features
defined in the Java Naming and Directory Interface™ (JNDI)
specification. The _Resource_ annotation described here is defined in
more detail in the Common Annotations specification. The _EJB_
annotation described here is defined in more detail in the Enterprise
JavaBeans specification. The _PersistenceUnit_ and _PersistenceContext_
annotations described here are defined in more detail in the Java
Persistence specification. The _Inject_ annotation described here is
defined in the Dependency Injection for Java specification, and its
usage in Java EE applications is defined in the Contexts and Dependency
Injection for the Java EE Platform specification.

==== [#50581511_pgfId-7675]##Overview

[#50581511_pgfId-12825]##The requirements defined in this chapter
address the following two issues:

* [#50581511_pgfId-7676]##The Application Assembler and Deployer should
be able to customize the behavior of an application’s business logic
without accessing the application’s source code. Typically this will
involve specification of parameter values, connection to external
resources, and so on. Deployment descriptors provide this capability
* [#50581511_pgfId-12837]##Applications must be able to access resources
and external information in their operational environment without
knowledge of how the external information is named and organized in that
environment. The JNDI naming context and Java language annotations
provide this capability.

======= [#50581511_pgfId-7679]##Chapter Organization

[#50581511_pgfId-7683]##The following sections contain the Java EE
platform solutions to the above issues:

* [#50581511_pgfId-12853]##link:JavaEE_Platform_Spec.htm#50581511_50670[See
JNDI Naming Context],” defines general rules for the use of the JNDI
naming context and its interaction with Java language annotations that
reference entries in the naming context.
* [#50581511_pgfId-17144]##link:JavaEE_Platform_Spec.htm#50581511_92979[See
Responsibilities by Java EE Role],” defines the general responsibilities
for each of the Java EE roles such as Application Component Provider,
Application Assembler, Deployer, and Java EE Product Provider.
* [#50581511_pgfId-18316]##link:JavaEE_Platform_Spec.htm#50581511_15165[See
Simple Environment Entries],” defines the basic interfaces that specify
and access the application component’s naming environment. The section
illustrates the use of the application component’s naming environment
for generic customization of the application component’s business logic.
* [#50581511_pgfId-7687]##link:JavaEE_Platform_Spec.htm#50581511_15618[See
Enterprise JavaBeans™ (EJB) References],” defines the interfaces for
obtaining the business interface, no-interface view, or home interface
of an enterprise bean using an EJB reference. An EJB reference is a
special entry in the application component’s environment.
* [#50581511_pgfId-997063]##link:JavaEE_Platform_Spec.htm#50581511_31473[See
Web Service References],” refers to the specification for web service
references.
* [#50581511_pgfId-7691]##link:JavaEE_Platform_Spec.htm#50581511_11574[See
Resource Manager Connection Factory References],” defines the interfaces
for obtaining a resource manager connection factory using a resource
manager connection factory reference. A resource manager connection
factory reference is a special entry in the application component’s
environment.
* [#50581511_pgfId-12902]##link:JavaEE_Platform_Spec.htm#50581511_30282[See
Resource Environment References],” defines the interfaces for obtaining
an administered object that is associated with a resource using a
resource environment reference. A resource environment reference is a
special entry in the application component’s environment.
* [#50581511_pgfId-16273]##link:JavaEE_Platform_Spec.htm#50581511_29908[See
Message Destination References],” defines the interfaces for declaring
and using message destination references.
* [#50581511_pgfId-12917]##link:JavaEE_Platform_Spec.htm#50581511_27391[See
UserTransaction References],” describes the use by eligible application
components of references to a _UserTransaction_ object in the
component’s environment to start, commit, and abort transactions.
* [#50581511_pgfId-997016]##link:JavaEE_Platform_Spec.htm#50581511_91999[See
TransactionSynchronizationRegistry References],” describes the use by
eligible application components of references to a
_TransactionSynchronizationRegistry_ object in the component’s
environment.
* [#50581511_pgfId-16286]##link:JavaEE_Platform_Spec.htm#50581511_72785[See
ORB References],” describes the use by eligible application components
of references to a CORBA _ORB_ object in the component’s environment.
* [#50581511_pgfId-997026]##link:JavaEE_Platform_Spec.htm#50581511_84517[See
Persistence Unit References],” describes the use by eligible application
components of references to an _EntityManagerFactory_ object in the
component’s environment.
* [#50581511_pgfId-997030]##link:JavaEE_Platform_Spec.htm#50581511_48657[See
Persistence Context References],” describes the use by eligible
application components of references to an _EntityManager_ object in the
component’s environment.
* [#50581511_pgfId-1000929]##link:JavaEE_Platform_Spec.htm#50581511_99957[See
Application Name and Module Name References],” describes the use by
eligible application components of references to the names of the
current application and module.
* [#50581511_pgfId-1006085]##link:JavaEE_Platform_Spec.htm#50581511_62617[See
Application Client Container Property],” describes the use by eligible
application components of references to the application client container
property.
* [#50581511_pgfId-1000936]##link:JavaEE_Platform_Spec.htm#50581511_72918[See
Validator and Validator Factory References],” describes the use by
eligible application components of references to the _Validator_ and
_ValidatorFactory_ objects in the component’s environment.
* [#50581511_pgfId-1002730]##link:JavaEE_Platform_Spec.htm#50581511_72240[See
Resource Definition and Configuration],” describes the use by eligible
application components of metadata that may be used to define resources
in the component’s environment.
* [#50581511_pgfId-1001930]##link:JavaEE_Platform_Spec.htm#50581511_11623[See
DataSource Resource Definition],” describes the use by eligible
application components of references to _DataSource_ resources in the
component’s environment.
* [#50581511_pgfId-1001970]##link:JavaEE_Platform_Spec.htm#50581511_87111[See
JMS Connection Factory Resource Definition],” describes the use by
eligible application components of references to JMS _ConnectionFactory_
resources in the component’s environment.
* [#50581511_pgfId-1001951]##link:JavaEE_Platform_Spec.htm#50581511_90666[See
JMS Destination Definition],” describes the use by eligible application
components of references to JMS _Destination_ resources in the
component’s environment.
* [#50581511_pgfId-1001958]##link:JavaEE_Platform_Spec.htm#50581511_22739[See
Mail Session Definition],” describes the use by eligible application
components of references to Mail _Session_ resources in the component’s
environment.
* [#50581511_pgfId-1002025]##link:JavaEE_Platform_Spec.htm#50581511_80497[See
Connector Connection Factory Definition],” describes the use by eligible
application components of references to Connector connection factory
resources in the component’s environment.
* [#50581511_pgfId-1004829]##link:JavaEE_Platform_Spec.htm#50581511_85453[See
Connector Administered Object Definition],” describes the use by
eligible application components of references to Connector administered
object resources in the component’s environment.
* [#50581511_pgfId-1006331]##link:JavaEE_Platform_Spec.htm#50581511_90595[See
Default Data Source],” describes the use by eligible application
components of references to the default DataSource in the component’s
environment.
* [#50581511_pgfId-1006338]##link:JavaEE_Platform_Spec.htm#50581511_52679[See
Default JMS Connection Factory],” describes the use by eligible
application components of references to the default JMS
ConnectionFactory in the component’s environment.
* [#50581511_pgfId-1007459]##link:JavaEE_Platform_Spec.htm#50581511_67316[See
Default Concurrency Utilities Objects],” describes the use by eligible
application components of references to the default Concurrency
Utilities objects in the component’s environment.
* [#50581511_pgfId-1006320]##link:JavaEE_Platform_Spec.htm#50581511_20225[See
Managed Bean References],” describes the use by eligible application
components of references to Managed Beans.
* [#50581511_pgfId-1006324]##link:JavaEE_Platform_Spec.htm#50581511_17023[See
Bean Manager References],” describes the use by eligible application
components of references to a _BeanManager_ object in the component’s
environment.
* [#50581511_pgfId-1002052]##link:JavaEE_Platform_Spec.htm#50581511_62440[See
Support for Dependency Injection],” describes support for the use of the
Dependency Injection APIs.

======= [#50581511_pgfId-12928]##Required Access to the JNDI Naming Environment

[#50581511_pgfId-12850]##Java EE application clients, enterprise beans,
and web components are required to have access to a JNDI naming
environmentlink:#pgfId-1000473[4]. The containers for these application
component types are required to provide the naming environment support
described here.

[#50581511_pgfId-8607]##Annotations and deployment descriptors are the
main vehicles for conveying access information to the Application
Assembler and Deployer about application components’ requirements for
customization of business logic and access to external information. The
annotations described here are available for use by all application
component types. The deployment descriptor entries described here are
present in identical form in the deployment descriptor schemas for each
of these application component types. See the corresponding
specification of each application component type for the details.

==== [#50581511_pgfId-7693]##[#50581511_50670]##JNDI Naming Context

[#50581511_pgfId-7694]##The application component’s naming environment
is a mechanism that allows customization of the application component’s
business logic during deployment or assembly. Use of the application
component’s environment allows the application component to be
customized without the need to access or change the application
component’s source code.

======= [#50581511_pgfId-16471]##The Application Component’s Environment

[#50581511_pgfId-7695]##The container implements the application
component’s environment, and provides it to the application component
instance as a JNDI naming context. The application component’s
environment is used as follows:

. [#50581511_pgfId-7696]##The application component’s business methods
make use of entries from the environment. The business methods may
access the environment using the JNDI interfaces or lookup methods on
component-specific context objects. Also, entries from the environment
may be injected into the application component’s fields or methods. The
Application Component Provider declares in the deployment descriptor, or
via annotations, all the environment entries that the application
component expects to be provided in its environment at runtime. For each
environment entry, the Application Component Provider can also specify
in the deployment descriptor, or via annotations, the JNDI name of
another environment entry whose value should be used to initialize the
environment entry being defined (“lookup” functionality).
. [#50581511_pgfId-7697]##The container provides an implementation of
the JNDI naming context that stores the application component
environment. The container also provides the tools that allow the
Deployer to create and manage the environment of each application
component.
. [#50581511_pgfId-7698]##The Deployer uses the tools provided by the
container to initialize the environment entries that are declared in the
application component’s deployment descriptor or via annotations. The
Deployer can set and modify the values of the environment entries. As
part of this process, the Deployer is allowed to override any “lookup”
information associated with the application component.
. [#50581511_pgfId-16434]##The container injects entries from the
environment into application component fields or methods as specified by
the application component’s deployment descriptor or by annotations on
the application component class.
. [#50581511_pgfId-7699]##The container also makes the environment
naming context available to the application component instances at
runtime. The application component’s instances may use the JNDI
interfaces or component context lookup methods to obtain the values of
the environment entries. __

======= [#50581511_pgfId-997238]##[#50581511_61227]##Application Component Environment Namespaces

[#50581511_pgfId-997245]##The application component’s naming environment
is composed of four logical namespaces, representing naming environments
with different scopes. The four namespaces are: __

* [#50581511_pgfId-997256]## _java:comp_ – Names in this namespace are
per-component (for example, per enterprise bean). Except for components
in a web module, each component gets its own _java:comp_ namespace, not
shared with any other component. Components in a web module do not have
their own private component namespace. __ See note below.
* [#50581511_pgfId-997278]## _java:module_ – Names in this namespace are
shared by all components in a module (for example, all enterprise beans
in a single EJB module, or all components in a web module). __
* [#50581511_pgfId-999536]## _java:app_ – Names in this namespace are
shared by all components in all modules in a single application, where
“single application” means a single deployment unit, such as a single
ear file, a single module deployed standalone, etc. For example, a war
file and an EJB jar file in the same ear file would both have access to
resources in the _java:app_ namespace. __
* [#50581511_pgfId-999537]## _java:global_ – Names in this namespace are
shared by all applications deployed in an application server instance.
Note that an application server instance may represent a single server,
a cluster of servers, an administrative domain containing many servers,
or even more. The scope of an application server instance is
product-dependent, but it must be possible to deploy multiple
applications to a single application server instance.

[#50581511_pgfId-997339]##Note that in environments in which an
application is deployed multiple times—such as, for example, in cloud
environments, where multiple instances of the same application might be
deployed on behalf of multiple tenants—the namespace for each
application instance would be disjoint from the namespace of any other
instance of that same application.

[#50581511_pgfId-1000481]##For historical reasons, the _java:comp_
namespace is shared by all components in a web module. To preserve
compatibility, this specification doesn’t change that. In a web module,
_java:comp_ refers to the same namespace as _java:module_ . It is
recommended that resources in a web module that are intended to be
shared by more than one component be declared in the _java:module/env_
namespace.

[#50581511_pgfId-997346]##Note that an application client is a module
with only a single component.

[#50581511_pgfId-997349]##Note also that resource adapter (connector)
modules may not define resources in any of the component namespaces, but
may look up resources defined by other components. All the _java:_
namespaces accessible in a resource adapter are the namespaces of the
component that called the resource adapter (when called in the context
of a component).

[#50581511_pgfId-997357]##If multiple application components declare an
environment entry in one of the shared namespaces, all attributes of
that entry must be identical in each declaration. For example, if
multiple components declare a resource reference with the same
_java:app_ name, the _authentication_ and _shareable_ attributes must be
identical.

[#50581511_pgfId-997362]##If all attributes of each declaration of a
shared environment entry are not identical, this must be reported as a
deployment error to the Deployer. The deployment tool may allow the
Deployer to correct the error and continue deployment.

[#50581511_pgfId-997367]##The default JNDI namespace for resource
references and resource definitions must always be _java:comp/env_ .
Note that this applies to both the case where no name has been supplied
so the rules for choosing a default name are used, and the case where a
name has been supplied explicitly but the name does not specify a
_java:_ namespace. Since the _java:comp_ namespace is not available in
some contexts, use of that namespace in such a context should result in
a deployment error. Likewise, the _java:module_ namespace is not valid
in some contexts; use of that namespace in such contexts should result
in a deployment error. Environment entries may be declared in any one of
the defined namespaces by explicitly including the namespace prefix
before the name.

[#50581511_pgfId-1008280]##It is recommended but not required that
environment entries be created in the _env_ subcontext of the
corresponding naming context. For example, entries shared within a
module should be declared in the _java:module/env_ context. Note that
names that are not under the _env_ subcontext may conflict with the
current or future versions of this specification, with server-defined
names, such as the names of applications or modules, or with
server-defined resources. Names in the _env_ subcontexts of any of the
namespaces must only be created by an explicit declaration in an
application or by an explicit action by an administrator; the
application server must not predefine any names in the _env_ subcontext
of any of the namespaces, or in any subcontext of any such _env_
context.

[#50581511_pgfId-1003078]##An environment entry declared in the
_application.xml_ descriptor must specify a JNDI name in the _java:app_
or _java:global_ namespace, for example: _java:app/env/myString_ or
_java:global/someValue_ . The specification of a _java:comp_ or
_java:module_ name for an environment entry declared in the
_application.xml_ descriptor must be reported as a deployment error to
the Deployer.

[#50581511_pgfId-998576]##A Java EE product may impose security
restrictions on access of resources in the shared namespaces. However,
it must be possible to deploy applications that define resources in the
shared namespaces that are usable by different entities at the given
scope. For example, it must be possible to deploy an application that
defines a resource, using various forms of metadata declaration, in the
_java:global_ namespace that is usable by a separate application.

======= [#50581511_pgfId-998528]##Accessibility of Environment Entry Types

[#50581511_pgfId-997131]##All objects defined in environment entries of
any kind (either in deployment descriptors or through annotations) must
be specified to be of a Java type that is accessible to the component.
Accessibility of Java classes is specified in section
link:JavaEE_Platform_Spec.htm#50581519_78785[See Class Loading
Requirements].” If the object is of type _java.lang.Class_ , the _Class_
object must refer to a class that is accessible to the component. Note
that in cases where the container may return an implementation subtype
of the requested type, the implementation subtype might not be
accessible to the component.

======= [#50581511_pgfId-16470]##[#50581511_27403]##Sharing of Environment Entries

[#50581511_pgfId-7700]##Each application component defines its own set
of dependencies that must appear as entries in the application
component’s environment. All instances of an application component
within the same application instance within the same container share the
same environment entries. Application component instances are not
allowed to modify the environment at runtime.

[#50581511_pgfId-15857]##In general, lookups of objects in the JNDI
_java:_ namespace are required to return a new instance of the requested
object every time. Exceptions are allowed for the following:

* [#50581511_pgfId-15859]##The container knows the object is immutable
(for example, objects of type _java.lang.String_ ), or knows that the
application can’t change the state of the object.
* [#50581511_pgfId-15860]##The object is defined to be a singleton, such
that only one instance of the object may exist in the JVM.
* [#50581511_pgfId-15862]##The name used for the lookup is defined to
return an instance of the object that might be shared. The names
_java:comp/ORB_ , _java:comp/ValidatorFactory_ , and
_java:comp/BeanManager_ are such names.

[#50581511_pgfId-15864]##In these cases, a shared instance of the object
may be returned. In all other cases, a new instance of the requested
object must be returned on each lookup. Note that, in the case of
resource adapter connection objects, it is the resource adapter’s
_ManagedConnectionFactory_ implementation that is responsible for
satisfying this requirement.

[#50581511_pgfId-16437]##Each injection of an object corresponds to a
JNDI lookup. Whether a new instance of the requested object is injected,
or whether a shared instance is injected, is determined by the rules
described above. __

======= [#50581511_pgfId-16472]##[#50581511_11378]##Annotations and Injection

[#50581511_pgfId-16467]##As described in the following sections, a field
or method of certain container-managed component classes may be
annotated to request that an entry from the application component’s
environment be injected into the class. The specifications for the
different containers indicate which classes are considered
container-managed classes; not all classes of a given type are
necessarily managed by the container.

[#50581511_pgfId-997070]##Any of the types of resources described in
this chapter may be injected. Injection may also be requested using
entries in the deployment descriptor corresponding to each of these
resource types. The field or method may have any access qualifier (
_public_ , _private_ , etc.). For all classes except application client
main classes, the fields or methods must not be _static_ . Because
application clients use the same lifecycle as Java SE applications, no
instance of the application client main class is created by the
application client container. Instead, the _static_ _main_ method is
invoked. To support injection for the application client main class, the
fields or methods annotated for injection must be _static_ .

[#50581511_pgfId-16473]##A field of a class may be the target of
injection. The field must not be _final_ . By default, the name of the
field is combined with the fully qualified name of the class and used
directly as the name in the application component’s naming context. For
example, a field named _myDatabase_ in the class _MyApp_ in the package
_com.example_ would correspond to the JNDI name
_java:comp/env/com.example.MyApp/myDatabase_ . The annotation also
allows the JNDI name to be specified explicitly. When a deployment
descriptor entry is used to specify injection, the JNDI name and the
field name are both specified explicitly. Note that, by default, the
JNDI name is relative to the _java:comp/env_ naming context.

[#50581511_pgfId-16474]##Environment entries may also be injected into a
class through methods that follow the naming conventions for JavaBeans
properties. The annotation is applied to the _set_ method for the
property, which is the method that is called to inject the environment
entry into the class. The JavaBeans property name (not the method name)
is used as the default JNDI name. For example, a method named
_setMyDatabase_ in the same _MyApp_ class would correspond to the same
JNDI name _java:comp/env/com.example.MyApp/myDatabase_ as the field
_myDatabase_ .

[#50581511_pgfId-16533]##Each resource may only be injected into a
single field or method of a given name in a given class. Requesting
injection of the _java:comp/env/com.example.MyApp/myDatabase_ resource
into both the _setMyDatabase_ method and the _myDatabase_ field is an
error. Note, however, that either the field or the method could request
injection of a resource of a different (non-default) name. By explicitly
specifying the JNDI name of a resource, a single resource may be
injected into multiple fields or methods of multiple classes.

[#50581511_pgfId-17367]##The specifications for the various application
component types describe which classes may be annotated for injection,
as summarized in link:JavaEE_Platform_Spec.htm#50581511_19779[See
Component classes supporting injection].

[#50581511_pgfId-1006913]##The component classes listed in
link:JavaEE_Platform_Spec.htm#50581511_19779[See Component classes
supporting injection] with support level “Standard” all support Java EE
resource injection, as well as PostConstruct and PreDestroy callbacks.
In addition, if CDI is enabled—which it is by default—these classes also
support CDI injection, as described in
link:JavaEE_Platform_Spec.htm#50581511_62440[See Support for Dependency
Injection]”, and the use of interceptorslink:#pgfId-1006927[5]. The
component classes listed with support level “Limited” only support Java
EE field injection and the PostConstruct callback. Note that these are
application client main classes, where field injection is into static
fields.

{empty}[#50581511_pgfId-1006906]##The specifications for the various
application component types also describe when injection occurs in the
lifecycle of the component. Typically injection will occur after an
instance of the class is constructed, but before any business methods
are called. If the container fails to find a resource needed for
injection, initialization of the class must fail, and the class must not
be put into service.link:JavaEE_Platform_Spec.htm#50581511_50149[See
Classes supporting injection]

======= [#50581511_pgfId-1008057]##[#50581511_19779]##Component classes supporting injection

[#50581511_pgfId-1008063]##Spec

[#50581511_pgfId-1008066]##[#50581511_50149]##Classes supporting
injection

[#50581511_pgfId-1008068]##Support level

[#50581511_pgfId-1008070]##Servlet

[#50581511_pgfId-1008072]##servlets

[#50581511_pgfId-1008073]##servlet filters

[#50581511_pgfId-1008074]##event listeners

[#50581511_pgfId-1008075]##HTTP upgrade handlers

[#50581511_pgfId-1008077]##Standard

[#50581511_pgfId-1008078]##Standard

[#50581511_pgfId-1008079]##Standard

[#50581511_pgfId-1008080]##Standard

[#50581511_pgfId-1008082]##JSP

[#50581511_pgfId-1008084]##tag handlers

[#50581511_pgfId-1008085]##tag library event listeners

[#50581511_pgfId-1008087]##Standard

[#50581511_pgfId-1008088]##Standard

[#50581511_pgfId-1008090]##JSF

{empty}[#50581511_pgfId-1008095]##managed classeslink:#pgfId-1008094[6]

[#50581511_pgfId-1008097]##Standard

[#50581511_pgfId-1008099]##JAX-WS

[#50581511_pgfId-1008101]##service endpoints

[#50581511_pgfId-1008102]##handlers

[#50581511_pgfId-1008104]##Standard

[#50581511_pgfId-1008105]##Standard

[#50581511_pgfId-1008166]##JAX-RS

{empty}[#50581511_pgfId-1008168]##JAX-RS
componentslink:#pgfId-1008172[7]

[#50581511_pgfId-1008170]##Standard

[#50581511_pgfId-1008107]##WebSocket

[#50581511_pgfId-1008109]##endpoints

[#50581511_pgfId-1008111]##Standard

[#50581511_pgfId-1008113]##EJB

[#50581511_pgfId-1008115]##beans

[#50581511_pgfId-1008117]##Standard

[#50581511_pgfId-1008119]##Interceptor

{empty}[#50581511_pgfId-1008124]##interceptorslink:#pgfId-1008123[8]

[#50581511_pgfId-1008126]##Standard

[#50581511_pgfId-1008128]##Java Persistence

[#50581511_pgfId-1008130]##entity listeners

[#50581511_pgfId-1008132]##Standard

[#50581511_pgfId-1008134]##Managed Beans

[#50581511_pgfId-1008136]##managed beans

[#50581511_pgfId-1008138]##Standard

{empty}[#50581511_pgfId-1008143]##CDIlink:#pgfId-1008142[9]

[#50581511_pgfId-1008144]## 

{empty}[#50581511_pgfId-1008149]##CDI-style managed
beanslink:#pgfId-1008148[10]

{empty}[#50581511_pgfId-1008153]##decoratorslink:#pgfId-1008152[11]

[#50581511_pgfId-1008155]##Standard

[#50581511_pgfId-1008156]##Standard

[#50581511_pgfId-1008158]##Java EE platform

[#50581511_pgfId-1008160]##main class (static)

[#50581511_pgfId-1008161]##login callback handler

[#50581511_pgfId-1008163]##Limited

[#50581511_pgfId-1008164]##Standard

[#50581511_pgfId-17450]##Annotations may also be applied to the class
itself. These annotations declare an entry in the application
component’s environment but do not cause the resource to be injected.
Instead, the application component is expected to use JNDI or a
component context lookup method to lookup the entry. When the annotation
is applied to the class, the JNDI name and the environment entry type
must be specified explicitly. __

[#50581511_pgfId-18218]##Resource annotations may appear on any of the
classes listed above, or on any superclass of any class listed above. A
resource annotation on any class in the inheritance hierarchy defines a
resource needed by the application component. However, injection of
resources follows the Java language overriding rules for visibility of
fields and methods. A method definition that overrides a method on a
superclass defines the resource, if any, to be injected into that
method. An overriding method may request injection even though the
superclass method does not request injection, it may request injection
of a different resource than is requested by the superclass, or it may
request no injection even though the superclass method requests
injection.

[#50581511_pgfId-18885]##In addition, fields or methods that are not
visible in or are hidden (as opposed to overridden) by a subclass may
still request injection. This allows, for example, a private field to be
the target of injection and that field to be used in the implementation
of the superclass, even though the subclass has no visibility into that
field and doesn’t know that the implementation of the superclass is
using an injected resource. Note a declaration of a field in a subclass
with the same name as a field in a superclass always causes the field in
the superclass to be hidden.

[#50581511_pgfId-18886]##In some cases a class may need to perform
initialization of its own after all resources have been injected. To
support this case, one method of the class may be annotated with the
_PostConstruct_ annotation (or, equivalently, specified using the
_post-construct_ entry of a deployment descriptor). This method will be
called after all injections have occured and before the class is put
into service. This method will be called even if the class doesn’t
request any resources to be injected. Similarly, for classes whose
lifecycle is managed by the container, the _PreDestroy_ annotation (or,
equivalently, the _pre-destroy_ entry of a deployment descriptor) may be
applied to one method that will be called when the class is taken out of
service and will no longer be used by the container. Each class in a
class hierarchy may have _PostConstruct_ and _PreDestroy_ methods. The
order in which the methods are called matches the order of the class
hierarchy with methods on a superclass being called before methods on a
subclass.

[#50581511_pgfId-18653]##The _PostConstruct_ and _PreDestroy_
annotations are specified by the Common Annotations specification. All
classes that support injection also support the _PostConstruct_
annotation. All classes for which the container manages the full
lifecycle of the object also support the _PreDestroy_ annotation.

[#50581511_pgfId-1006653]##Starting with Java EE 7, CDI support is
enabled by default. CDI bean-defining annotations and the _beans.xml_
descriptor are used to determine which classes are CDI beans and
eligible for injection into other objects. Similarly, the annotation
metadata and the _beans.xml_ descriptor are used by CDI to determine
which interceptors are eligible to be applied. See the CDI specification
and the Interceptors specification for the rules that determine which
classes are CDI beans and the treatment of interceptors.

======= [#50581511_pgfId-16495]##[#50581511_78077]##Annotations and Deployment Descriptors

[#50581511_pgfId-16496]##Environment entries may be declared by use of
annotations, without need for any deployment descriptor entries.
Environment entries may also be declared by deployment descriptor
entries. The same environment entry may be declared using both an
annotation and a deployment descriptor entry. In this case, the
information in the deployment descriptor entry may be used to override
some of the information provided in the annotation. This approach may be
used by an Application Assembler or Deployer to override information
provided by the Application Component Developer. Applications should not
use deployment descriptor entries to request injection of a resource
into a field or method that has not been designed for injection.

[#50581511_pgfId-17464]##The following list describes the rules for how
a deployment descriptor entry may override a _Resource_ annotation.

* [#50581511_pgfId-17471]##The relevant deployment descriptor entry is
located based on the JNDI name used with the annotation (either
defaulted or provided explicitly).
* [#50581511_pgfId-17484]##The type specified in the deployment
descriptor must be assignable to the type of the field or property.
* [#50581511_pgfId-17493]##The description, if specified, overrides the
description element of the annotation.
* [#50581511_pgfId-17502]##The injection target, if specified, defines
additional injection points for the resource.
* [#50581511_pgfId-1003184]##The _mapped-name_ element, if specified,
overrides the _mappedName_ element of the annotation.
* [#50581511_pgfId-998806]##The _res-sharing-scope_ element, if
specified, overrides the _shareable_ element of the annotation. In
general, the Application Assembler or Deployer should not change this
value as doing so is likely to break the application.
* [#50581511_pgfId-998807]##The _res-auth_ element, if specified,
overrides the _authenticationType_ element of the annotation. In
general, the Application Assembler or Deployer should not change this
value as doing so is likely to break the application.
* [#50581511_pgfId-998811]##The _lookup-name_ element, if specified,
overrides the _lookup_ element of the annotation.

[#50581511_pgfId-1003191]##It is an error to request injection of two
resources into the same target. The behavior of an application that does
so is undefined.

[#50581511_pgfId-998859]##The rules for how a deployment descriptor
entry may override an _EJB_ annotation are included in the EJB
specification. The rules for how a deployment descriptor entry may
override a _WebServiceRef_ annotation are included in the Web Services
for Java EE specification.

[#50581511_pgfId-997082]##A PostConstruct method may be specified using
either the _PostConstruct_ annotation on the method or the
_post-construct_ deployment descriptor entry. Similarly, a PreDestroy
method may be specified using either the _PreDestroy_ annotation on the
method or the _pre-destroy_ deployment descriptor entry.

======= [#50581511_pgfId-997486]##Other Naming Context Entries

[#50581511_pgfId-997493]##In addition to environment entries declared by
application components, other items will appear in the naming context,
as specified by this and other specifications. Following are some of
these entries. This is not an exhaustive list; consult the corresponding
specification for details.

* [#50581511_pgfId-997499]##All enterprise beans in an application are
given entries in the shared namespaces. See the EJB specification for
details.
* [#50581511_pgfId-997502]##All web applications are given names in the
shared namespaces. The names correspond to the complete URL of the web
application. See the Servlet specification for details.
* [#50581511_pgfId-997506]##Objects representing several container
services are defined in the _java:comp_ namespace. See, for example,
link:JavaEE_Platform_Spec.htm#50581511_27391[See UserTransaction
References],” link:JavaEE_Platform_Spec.htm#50581511_91999[See
TransactionSynchronizationRegistry References],” and
link:JavaEE_Platform_Spec.htm#50581511_72785[See ORB References].”
* [#50581511_pgfId-997509]##Strings providing the current module name
and application name are defined in the _java:comp_ namespace. See
link:JavaEE_Platform_Spec.htm#50581511_99957[See Application Name and
Module Name References].”

==== [#50581511_pgfId-16732]##[#50581511_92979]##Responsibilities by Java EE Role

[#50581511_pgfId-16733]##This section describes the responsibilities for
each Java EE role that apply to all uses of the Java EE naming context.
The sections that follow describe the responsibilities that are specific
to the different types of objects that may be stored in the naming
context.

======= [#50581511_pgfId-16728]##[#50581511_26814]##Application Component Provider’s Responsibilities

[#50581511_pgfId-16726]##The Application Component Provider may make use
of three techniques for accessing and managing the naming context.
First, the Application Component Provider may use Java language
annotations to request injection of a resource from the naming context,
or to declare elements that are needed in the naming context. Second,
the component may use the JNDI APIs to access entries in the naming
context. Third, deployment descriptor entries may be used to declare
entries needed in the naming context, and to request injection of these
entries into application components. Deployment descriptor entries may
also be used to override information provided by annotations.

[#50581511_pgfId-998873]##As part of the declaration of elements in the
naming context, the Application Component Provider can specify the JNDI
name of a resource to be looked up in the naming context to initialize
the element being declared. The JNDI name in question may belong to any
of the namespaces that compose the application component environment.

[#50581511_pgfId-998022]##To ensure that it has access to the correct
_javax.naming.InitialContext_ implementation provided by the container,
a portable application component must not specify the
_java.naming.factory.initial_ property, must not specify a
_URLContextFactory_ for the _“java”_ scheme-id, and must not call the
_javax.naming.spi.NamingManager.setInitialContextFactoryBuilder_ method.

======= [#50581511_pgfId-16702]##Application Assembler’s Responsibilities

[#50581511_pgfId-16703]##The Application Assembler is allowed to modify
the entries in the naming context set by the Application Component
Provider, and is allowed to set the values of those entries for which
the Application Component Provider has not specified any values. The
Application Assembler may use the deployment descriptor to override
settings made by the Application Component Provider in the source code
using annotations.

======= [#50581511_pgfId-16704]##[#50581511_69928]##Deployer’s Responsibilities

[#50581511_pgfId-16705]##The Deployer must ensure that all the entries
declared by an application component are created and properly
initialized.

[#50581511_pgfId-16706]##The Deployer can modify the entries that have
been previously set by the Application Component Provider and/or
Application Assembler, and must set the values of those entries for
which a required value has not been specified. If an annotation contains
the _lookup_ element or a deployment descriptor entry includes the
_lookup-name_ element, the Deployer should bind it to the entry
specified as the target of the lookup. Deployment should fail if the
_lookup_ element of an annotation or the _lookup-name_ element in a
deployment descriptor entry does not specify a name with an explicit
_java:_ namespace. The Deployer may also use product-specific resource
mapping tools, deployment descriptors, rules, or capabilities to bind
resource reference entries to resources in the target operational
environment.

[#50581511_pgfId-16707]##The _description_ deployment descriptor
elements and annotation elements provided by the Application Component
Provider or Application Assembler help the Deployer with this task.

======= [#50581511_pgfId-16711]##[#50581511_17356]##Java EE Product Provider’s Responsibilities

[#50581511_pgfId-16715]##The Java EE Product Provider has the following
responsibilities:

* [#50581511_pgfId-16716]##Provide a deployment tool that allows the
Deployer to set and modify the entries of the application component’s
naming context.
* [#50581511_pgfId-16717]##Implement the _java:comp_ , _java:module_ ,
_java:app_ and _java:global_ environment naming contexts, and provide
them to the application component instances at runtime. The naming
context must include all the entries declared by the Application
Component Provider, with their values supplied in the deployment
descriptor or set by the Deployer. The environment naming context must
allow the Deployer to create subcontexts if they are needed by an
application component. Certain entries in the naming context may have to
be initialized with the values of other entries, specifically when the
“lookup” facility is used. In this case, it is an error if there are any
circular dependencies between entries. Similarly, it is an error if
looking up the specified JNDI name results in a resource whose type is
not compatible with the entry being created. The deployment tool may
allow the deployer to correct either of these classes of errors and
continue the deployment.
* [#50581511_pgfId-998005]##Ensure that, in the absence of any
properties specified by the application, the
_javax.naming.InitialContext_ implementation meets the requirements
described in this specification.
* [#50581511_pgfId-16718]##Inject entries from the naming environment
into the application component, as specified by the deployment
descriptor or annotations on the application component classes.
* [#50581511_pgfId-16700]##The container must ensure that the
application component instances have only read access to their naming
context. The container must throw the
_javax.naming.OperationNotSupportedException_ from all the methods of
the _javax.naming.Context_ interface that modify the environment naming
context and its subcontexts.

==== [#50581511_pgfId-16397]##[#50581511_15165]##Simple Environment Entries

[#50581511_pgfId-16449]##A simple environment entry is a configuration
parameter used to customize an application component’s business logic.
The environment entry values may be one of the following Java types:
_String_ , _Character_ , _Byte_ , _Short_ , _Integer_ , _Long_ ,
_Boolean_ , _Double_ , _Float_ , _Class_ , and any subclass of _Enum_ .

[#50581511_pgfId-16427]##The following subsections describe the
responsibilities of each Java EE Role.

======= [#50581511_pgfId-7705]##Application Component Provider’s Responsibilities

[#50581511_pgfId-7706]##This section describes the Application Component
Provider’s view of the application component’s environment, and defines
his or her responsibilities. It does so in three sections, the first
describing annotations for injecting environment entries, the second
describing the API for accessing environment entries, and the third
describing syntax for declaring the environment entries in a deployment
descriptor.

======= [#50581511_pgfId-16465]##Injection of Simple Environment Entries

[#50581511_pgfId-16466]##A field or a method of an application component
may be annotated with the _Resource_ annotation. The name and type of
the environment entry are as described above. Note that the container
will unbox the environment entry as required to match it to a primitive
type used for the injection field or method. The _authenticationType_
and _shareable_ elements of the _Resource_ annotation must not be
specified; simple environment entries are not shareable and do not
require authentication.

[#50581511_pgfId-18079]##The following code example illustrates how an
application component uses annotations to declare environment entries.

======= [#50581511_pgfId-18080]##// The maximum number of tax exemptions, configured by the Deployer.

[#50581511_pgfId-18081]##@Resource int maxExemptions;

[#50581511_pgfId-16617]##// The minimum number of tax exemptions,
configured by the Deployer.

[#50581511_pgfId-16618]##@Resource int minExemptions;

[#50581511_pgfId-16589]## 

[#50581511_pgfId-16588]##public void setTaxInfo(int
numberOfExemptions,...)

[#50581511_pgfId-16547]## throws InvalidNumberOfExemptionsException \{

[#50581511_pgfId-16548]## ...

[#50581511_pgfId-16562]## // Use the environment entries to

[#50581511_pgfId-16563]## // customize business logic.

[#50581511_pgfId-16564]## if (numberOfExemptions > maxExemptions ||

[#50581511_pgfId-16565]## numberOfExemptions < minExemptions)

[#50581511_pgfId-16566]## throw new
InvalidNumberOfExemptionsException();

[#50581511_pgfId-16578]## ...

======= [#50581511_pgfId-16579]##}

[#50581511_pgfId-998932]##The following code example illustrates how an
environment entry can be assigned a value by referring to another entry,
potentially in a different namespace.

======= [#50581511_pgfId-998933]##// an entry that gets its value from an application-wide entry

[#50581511_pgfId-998918]##@Resource(lookup="java:app/env/timeout") int
timeout;

======= [#50581511_pgfId-7707]##Programming Interfaces for Accessing Simple Environment Entries

[#50581511_pgfId-7708]##In addition to the injection based approach
described above, an application component may access environment entries
dynamically. An application component instance locates the environment
naming context using the JNDI interfaces. An instance creates a
_javax.naming.InitialContext_ object by using the constructor with no
arguments, and looks up the naming environment via the _InitialContext_
under the name _java:comp/env_ . The application component’s environment
entries are stored directly in the environment naming context, or in its
direct or indirect subcontexts.

[#50581511_pgfId-12866]##Environment entries have the Java programming
language type declared by the Application Component Provider in the
deployment descriptor.

[#50581511_pgfId-1008187]##The following code example illustrates how an
application component accesses its environment entries.

======= [#50581511_pgfId-1008188]## public void setTaxInfo(int numberOfExemptions,...)

[#50581511_pgfId-1008189]## throws InvalidNumberOfExemptionsException \{

[#50581511_pgfId-7716]## ...

[#50581511_pgfId-7718]## // Obtain the application component’s

[#50581511_pgfId-12941]## // environment naming context.

[#50581511_pgfId-7719]## Context initCtx = new InitialContext();

[#50581511_pgfId-7720]## Context myEnv =
(Context)initCtx.lookup("java:comp/env");

[#50581511_pgfId-7721]## 

[#50581511_pgfId-7722]## // Obtain the maximum number of tax exemptions

[#50581511_pgfId-7723]## // configured by the Deployer.

[#50581511_pgfId-7724]## Integer max =
(Integer)myEnv.lookup("maxExemptions");

[#50581511_pgfId-7725]## 

[#50581511_pgfId-7726]## // Obtain the minimum number of tax exemptions

[#50581511_pgfId-7727]## // configured by the Deployer.

[#50581511_pgfId-7728]## Integer min =
(Integer)myEnv.lookup("minExemptions");

[#50581511_pgfId-7729]## 

[#50581511_pgfId-7730]## // Use the environment entries to

[#50581511_pgfId-14678]## // customize business logic.

[#50581511_pgfId-7731]## if (numberOfExemptions > max.intValue() ||

[#50581511_pgfId-7732]## numberOfExemptions < min.intValue())

[#50581511_pgfId-7733]## throw new InvalidNumberOfExemptionsException();

[#50581511_pgfId-7734]## 

[#50581511_pgfId-7735]## // Get some more environment entries. These
environment

[#50581511_pgfId-7736]## // entries are stored in subcontexts.

[#50581511_pgfId-7737]## String val1 =
(String)myEnv.lookup("foo/name1");

[#50581511_pgfId-12953]## Boolean val2 =
(Boolean)myEnv.lookup("foo/bar/name2");

[#50581511_pgfId-14766]## 

[#50581511_pgfId-14767]## // The application component can also

[#50581511_pgfId-14768]## // lookup using full pathnames.

[#50581511_pgfId-14769]## Integer val3 =
(Integer)initCtx.lookup("java:comp/env/name3");

[#50581511_pgfId-7743]## Integer val4 =

[#50581511_pgfId-14776]##
(Integer)initCtx.lookup("java:comp/env/foo/name4");

[#50581511_pgfId-7745]## ...

======= [#50581511_pgfId-12962]##}

======= [#50581511_pgfId-7748]##Declaration of Simple Environment Entries

[#50581511_pgfId-7749]##The Application Component Provider must declare
all the environment entries accessed from the application component’s
code. The environment entries are declared using either annotations on
the application component’s code, or using the _env-entry_ elements in
the deployment descriptor. Each _env-entry_ element describes a single
environment entry. The _env-entry_ element consists of an optional
description of the environment entry, the environment entry name, which
by default is relative to the _java:comp/env_ context, the expected Java
programming language type of the environment entry value (the type of
the object returned from the JNDI _lookup_ method), and an optional
environment entry value.

[#50581511_pgfId-14830]##An environment entry is scoped to the
application component whose declaration contains the _env-entry_
element. This means that the environment entry is not accessible from
other application components at runtime, and that other application
components may define _env-entry_ elements with the same
_env-entry-name_ without causing a name conflict.

[#50581511_pgfId-7751]##If the Application Component Provider provides a
value for an environment entry using the _env-entry-value_ element, the
value can be changed later by the Application Assembler or Deployer. The
value must be a string that is valid for the constructor of the
specified type that takes a single _String_ parameter, or in the case of
_Character_ , a single character.

[#50581511_pgfId-8514]##The following example is the declaration of
environment entries used by the application component whose code was
illustrated in the previous subsection.

======= [#50581511_pgfId-8225]##...

[#50581511_pgfId-7761]##<env-entry>

[#50581511_pgfId-7762]## <description>

[#50581511_pgfId-7763]## The maximum number of tax exemptions

[#50581511_pgfId-7764]## allowed to be set.

[#50581511_pgfId-7765]## </description>

[#50581511_pgfId-7766]## <env-entry-name>maxExemptions</env-entry-name>

[#50581511_pgfId-7767]##
<env-entry-type>java.lang.Integer</env-entry-type>

[#50581511_pgfId-7768]## <env-entry-value>15</env-entry-value>

[#50581511_pgfId-7769]##</env-entry>

[#50581511_pgfId-7770]##<env-entry>

[#50581511_pgfId-7771]## <description>

[#50581511_pgfId-7772]## The minimum number of tax exemptions allowed to
be set.

[#50581511_pgfId-7774]## </description>

[#50581511_pgfId-7775]## <env-entry-name>minExemptions</env-entry-name>

[#50581511_pgfId-7776]##
<env-entry-type>java.lang.Integer</env-entry-type>

[#50581511_pgfId-7777]## <env-entry-value>1</env-entry-value>

[#50581511_pgfId-7778]##</env-entry>

[#50581511_pgfId-7779]##<env-entry>

[#50581511_pgfId-7780]## <env-entry-name>foo/name1</env-entry-name>

[#50581511_pgfId-7781]##
<env-entry-type>java.lang.String</env-entry-type>

[#50581511_pgfId-7782]## <env-entry-value>value1</env-entry-value>

[#50581511_pgfId-7783]##</env-entry>

[#50581511_pgfId-7784]##<env-entry>

[#50581511_pgfId-7785]## <env-entry-name>foo/bar/name2</env-entry-name>

[#50581511_pgfId-7786]##
<env-entry-type>java.lang.Boolean</env-entry-type>

[#50581511_pgfId-7787]## <env-entry-value>true</env-entry-value>

[#50581511_pgfId-7788]##</env-entry>

[#50581511_pgfId-7789]##<env-entry>

[#50581511_pgfId-7790]## <description>Some description.</description>

[#50581511_pgfId-7791]## <env-entry-name>name3</env-entry-name>

[#50581511_pgfId-7792]##
<env-entry-type>java.lang.Integer</env-entry-type>

[#50581511_pgfId-7793]##</env-entry>

[#50581511_pgfId-7794]##<env-entry>

[#50581511_pgfId-7795]## <env-entry-name>foo/name4</env-entry-name>

[#50581511_pgfId-7796]##
<env-entry-type>java.lang.Integer</env-entry-type>

[#50581511_pgfId-7797]## <env-entry-value>10</env-entry-value>

[#50581511_pgfId-7798]##</env-entry>

[#50581511_pgfId-998596]##<env-entry>

[#50581511_pgfId-998597]## <env-entry-name>helperClass</env-entry-name>

[#50581511_pgfId-998598]##
<env-entry-type>java.lang.Class</env-entry-type>

[#50581511_pgfId-998599]##
<env-entry-value>com.acme.helper.Helper</env-entry-value>

[#50581511_pgfId-998594]##</env-entry>

[#50581511_pgfId-998611]##<env-entry>

[#50581511_pgfId-998612]## <env-entry-name>timeUnit</env-entry-name>

[#50581511_pgfId-998613]##
<env-entry-type>java.util.concurrent.TimeUnit</env-entry-type>

[#50581511_pgfId-998614]##
<env-entry-value>NANOSECONDS</env-entry-value>

[#50581511_pgfId-998615]##</env-entry>

[#50581511_pgfId-998956]##<env-entry>

[#50581511_pgfId-998960]## <env-entry-name>bar</env-entry-name>

[#50581511_pgfId-998961]##
<env-entry-type>java.lang.Integer</env-entry-type>

[#50581511_pgfId-998962]##
<lookup-name>java:app/env/appBar</lookup-name>

[#50581511_pgfId-1007547]##</env-entry>

======= [#50581511_pgfId-1007549]##...

[#50581511_pgfId-16662]##Injection of environment entries may also be
specified using the deployment descriptor, without need for Java
language annotations. The following example is the declaration of
environment entries corresponding to the earlier injection example.

======= [#50581511_pgfId-16663]##...

[#50581511_pgfId-16664]##<env-entry>

[#50581511_pgfId-16665]## <description>

[#50581511_pgfId-16666]## The maximum number of tax exemptions

[#50581511_pgfId-16667]## allowed to be set.

[#50581511_pgfId-16668]## </description>

[#50581511_pgfId-16669]## <env-entry-name>

[#50581511_pgfId-18293]## com.example.PayrollService/maxExemptions

[#50581511_pgfId-18292]## </env-entry-name>

[#50581511_pgfId-16670]##
<env-entry-type>java.lang.Integer</env-entry-type>

[#50581511_pgfId-16671]## <env-entry-value>15</env-entry-value>

[#50581511_pgfId-18274]## <injection-target>

[#50581511_pgfId-18275]## <injection-target-class>

[#50581511_pgfId-18279]## com.example.PayrollService

[#50581511_pgfId-18276]## </injection-target-class>

[#50581511_pgfId-16686]## <injection-target-name>

[#50581511_pgfId-18280]## maxExemptions

[#50581511_pgfId-18277]## </injection-target-name>

[#50581511_pgfId-18278]## </injection-target>

[#50581511_pgfId-16672]##</env-entry>

[#50581511_pgfId-16673]##<env-entry>

[#50581511_pgfId-16674]## <description>

[#50581511_pgfId-16675]## The minimum number of tax exemptions

[#50581511_pgfId-16676]## allowed to be set.

[#50581511_pgfId-16677]## </description>

[#50581511_pgfId-16678]## <env-entry-name>

[#50581511_pgfId-18296]## com.example.PayrollService/minExemptions

[#50581511_pgfId-18297]## </env-entry-name>

[#50581511_pgfId-16679]##
<env-entry-type>java.lang.Integer</env-entry-type>

[#50581511_pgfId-16680]## <env-entry-value>1</env-entry-value>

[#50581511_pgfId-18282]## <injection-target>

[#50581511_pgfId-18283]## <injection-target-class>

[#50581511_pgfId-18284]## com.example.PayrollService

[#50581511_pgfId-18285]## </injection-target-class>

[#50581511_pgfId-18286]## <injection-target-name>

[#50581511_pgfId-18287]## minExemptions

[#50581511_pgfId-18288]## </injection-target-name>

[#50581511_pgfId-18289]## </injection-target>

[#50581511_pgfId-16681]##</env-entry>

[#50581511_pgfId-17706]## 

[#50581511_pgfId-17705]##It’s often convenient to declare a field or
method as an injection target, but specify a default value in the code,
as illustrated in the following example.

[#50581511_pgfId-1005834]## 

[#50581511_pgfId-17709]##// The maximum number of tax exemptions,
configured by the Deployer.

[#50581511_pgfId-17710]##@Resource int maxExemptions = 4; // defaults to
4

[#50581511_pgfId-17715]## 

[#50581511_pgfId-17707]##To support this case, the container must only
inject a value for this resource if the deployer has specified a value
to override the default value. The _env-entry-value_ element in the
deployment descriptor is optional when an injection target is specified.
If the element is not specified, no value will be injected. In addition,
if the element is not specified, the named resource is not initialized
in the naming context; explicit lookups of the named resource will fail.

[#50581511_pgfId-998965]##The deployment descriptor equivalent of the
_lookup_ element of the _@Resource_ annotation is _lookup-name_ . The
following deployment descriptor fragment is equivalent to the earlier
example that used _lookup_ .

[#50581511_pgfId-998969]## 

[#50581511_pgfId-999007]##<env-entry>

[#50581511_pgfId-999009]##
<env-entry-name>somePackage.SomeClass/timeout</env-entry-name>

[#50581511_pgfId-999010]##
<env-entry-type>java.lang.Integer</env-entry-type>

[#50581511_pgfId-999011]## <injection-target>

[#50581511_pgfId-999012]## <injection-target-class>

[#50581511_pgfId-1005838]## somePackage.SomeClass

[#50581511_pgfId-1005839]## </injection-target-class>

[#50581511_pgfId-999013]##
<injection-target-name>timeout</injection-target-name>

[#50581511_pgfId-999014]## </injection-target>

[#50581511_pgfId-999015]##
<lookup-name>java:app/env/timeout</lookup-name>

[#50581511_pgfId-999551]##</env-entry>

[#50581511_pgfId-999552]## 

[#50581511_pgfId-999556]##It is an error for both the _env-entry-value_
and _lookup-name_ elements to be specified for a given _env-entry_
element. If either element exists, an eventual _lookup_ element of the
corresponding _Resource_ annotation (if any) must be ignored. In other
words, assignment of a value to an environment entry via a deployment
descriptor, either directly ( _env-entry-value_ ) or indirectly (
_lookup-name_ ), overrides any assignments made via annotations.

==== [#50581511_pgfId-7814]##[#50581511_15618]##Enterprise JavaBeans™ (EJB) References

[#50581511_pgfId-8246]##This section describes the programming and
deployment descriptor interfaces that allow the Application Component
Provider to refer to the homes of enterprise beans or to enterprise bean
instances using “logical” names called EJB references. The EJB
references are special entries in the application component’s naming
environment. The Deployer binds the EJB reference to the enterprise
bean’s business interface, no-interface view, or home interface in the
target operational environment.

[#50581511_pgfId-7816]##The deployment descriptor also allows the
Application Assembler to link an EJB reference declared in one
application component to an enterprise bean contained in an ejb-jar file
in the same Java EE application. The link is an instruction to the tools
used by the Deployer describing the binding of the EJB reference to the
business interface, no-interface view, or home interface of the
specified target enterprise bean. The same linking can also be specified
by the Application Component Provider using annotations in the source
code of the component.

[#50581511_pgfId-997157]##The requirements in this section only apply to
Java EE products that include an EJB container.

======= [#50581511_pgfId-7818]##Application Component Provider’s Responsibilities

[#50581511_pgfId-7819]##This subsection describes the Application
Component Provider’s view and responsibilities with respect to EJB
references. It does so in three sections, the first describing
annotations for injecting EJB references, the second describing the API
for accessing EJB references, and the third describing the syntax for
declaring the EJB references in a deployment descriptor

======= [#50581511_pgfId-16822]##Injection of EJB Entries

[#50581511_pgfId-16823]##A field or a method of an application component
may be annotated with the _EJB_ annotation. The _EJB_ annotation
represents a reference to an EJB session bean or entity bean. The
reference may be to a session bean’s business interface, to a session
bean’s no-interface view, or to the local or remote home interface of a
session bean or entity bean.

[#50581511_pgfId-16834]##The following example illustrates how an
application component uses the EJB annotation to reference an instance
of an enterprise bean. The referenced bean is a stateful session bean.
The enterprise bean reference will have the name
_java:comp/env/com.example.ExampleBean/myCart_ in the naming context,
where _ExampleBean_ is the name of the class of the referencing bean and
_com.acme.example_ is its package. The target of the reference is not
named and must be resolved by the Deployer, unless there is only one
session bean component within the application that exposes a client view
type that matches the EJB reference.

[#50581511_pgfId-1000552]## 

[#50581511_pgfId-1000553]##package com.acme.example;

[#50581511_pgfId-1000564]## 

[#50581511_pgfId-1000554]##@Stateless public class ExampleBean
implements Example \{

[#50581511_pgfId-1000555]## ...

[#50581511_pgfId-1000558]## @EJB private ShoppingCart myCart;

[#50581511_pgfId-1000559]## ...

[#50581511_pgfId-1000560]##}

[#50581511_pgfId-1002116]## 

[#50581511_pgfId-16840]##The following example illustrates use of almost
all elements of the _EJB_ annotation.

======= [#50581511_pgfId-16841]##@EJB(

[#50581511_pgfId-16842]## name = "ejb/shopping-cart",

[#50581511_pgfId-16843]## beanName = "cart1”,

[#50581511_pgfId-16844]## beanInterface = ShoppingCart.class,

[#50581511_pgfId-16845]## description = "The shopping cart for this
application"

[#50581511_pgfId-16846]##)

[#50581511_pgfId-16847]##private ShoppingCart myCart;

[#50581511_pgfId-999025]## 

[#50581511_pgfId-999026]##As an alternative to _beanName_ , a reference
to an EJB can use the global JNDI name for that EJB, or any of the other
names mandated by the EJB specifications, by means of the _lookup_
annotation element. The following example uses a JNDI name in the
application namespace.

======= [#50581511_pgfId-999040]##@EJB(

[#50581511_pgfId-999051]## lookup="java:app/cartModule/ShoppingCart",

[#50581511_pgfId-999044]## description = "The shopping cart for this
application"

[#50581511_pgfId-999045]##)

[#50581511_pgfId-999046]##private ShoppingCart myOtherCart;

[#50581511_pgfId-1000571]## 

[#50581511_pgfId-1000572]##If the _ShoppingCart_ bean were instead
written to the EJB 2.x client view, the EJB reference would be to the
bean’s home interface. For example:

[#50581511_pgfId-1000573]## 

[#50581511_pgfId-1000574]##@EJB(

[#50581511_pgfId-1000575]## name="ejb/shopping-cart",

[#50581511_pgfId-1000576]## beanInterface=ShoppingCartHome.class,

[#50581511_pgfId-1000577]## beanName="cart1",

[#50581511_pgfId-1000578]## description="The shopping cart for this
application"

[#50581511_pgfId-1000579]##)

[#50581511_pgfId-1000580]##private ShoppingCartHome myCartHome;

[#50581511_pgfId-1000592]## 

[#50581511_pgfId-1000593]##If the _ShoppingCart_ bean were instead
written to the no-interface client view and implemented by bean class
_ShoppingCartBean.class_ , the EJB reference would have type
_ShoppingCartBean.class_ . For example:

[#50581511_pgfId-1000606]## 

[#50581511_pgfId-1000597]##@EJB(

[#50581511_pgfId-1000598]## name="ejb/shopping-cart",

[#50581511_pgfId-1000599]## beanInterface=ShoppingCartBean.class,

[#50581511_pgfId-1000600]## beanName="cart1",

[#50581511_pgfId-1000601]## description="The shopping cart for this
application"

[#50581511_pgfId-1000602]##)

[#50581511_pgfId-1000603]##private ShoppingCartBean myCart;

======= [#50581511_pgfId-16824]##Programming Interfaces for EJB References

[#50581511_pgfId-16825]##The Application Component Provider may use EJB
references to locate the business interface, no-interface view, or home
interface of an enterprise bean as follows.

* [#50581511_pgfId-7825]##Assign an entry in the application component’s
environment to the reference. (See subsection
link:JavaEE_Platform_Spec.htm#50581511_35419[See Declaration of EJB
References] for information on how EJB references are declared in the
deployment descriptor.)
* [#50581511_pgfId-7826]##This specification recommends, but does not
require, that references to enterprise beans be organized in the _ejb_
subcontext of the application component’s environment (that is, in the
_java:comp/env/ejb_ JNDI context). Note that enterprise bean references
declared via annotations will not, by default, be in any subcontext.
* [#50581511_pgfId-7827]##Look up the business interface, no-interface
view, or home interface of the referenced enterprise bean in the
application component’s environment using JNDI.

[#50581511_pgfId-7828]##The following example illustrates how an
application component uses an EJB reference to locate the home interface
of an enterprise bean.

======= [#50581511_pgfId-7831]##public void changePhoneNumber(...) \{

[#50581511_pgfId-7832]## ...

[#50581511_pgfId-7834]## // Obtain the default initial JNDI context.

[#50581511_pgfId-7835]## Context initCtx = new InitialContext();

[#50581511_pgfId-7836]##

[#50581511_pgfId-7837]## // Look up the home interface of the
EmployeeRecord

[#50581511_pgfId-7838]## // enterprise bean in the environment.

[#50581511_pgfId-7839]## Object result =
initCtx.lookup("java:comp/env/ejb/EmplRecord");

[#50581511_pgfId-7841]## 

[#50581511_pgfId-7842]## // Convert the result to the proper type.

[#50581511_pgfId-14785]## EmployeeRecordHome emplRecordHome =
(EmployeeRecordHome)

[#50581511_pgfId-14786]## javax.rmi.PortableRemoteObject.narrow(result,

[#50581511_pgfId-14787]## EmployeeRecordHome.class);

[#50581511_pgfId-14788]## ...

======= [#50581511_pgfId-7847]## }

[#50581511_pgfId-7849]##In the example, the Application Component
Provider assigned the environment entry _ejb/EmplRecord_ as the EJB
reference name to refer to the remote home interface of an enterprise
bean.

======= [#50581511_pgfId-7851]##[#50581511_35419]##Declaration of EJB References

[#50581511_pgfId-7852]##Although the EJB reference is an entry in the
application component’s environment, the Application Component Provider
must not use a _env-entry_ element to declare it. Instead, the
Application Component Provider must declare all the EJB references using
either annotations on the application component’s code or the _ejb-ref_
or _ejb-local-ref_ elements of the deployment descriptor. This allows
the consumer of the application component’s JAR file (the Application
Assembler or Deployer) to discover all the EJB references used by the
application component. Deployment descriptor entries may also be used to
specify injection of an EJB reference into an application component.

[#50581511_pgfId-7853]##Each _ejb-ref_ or _ejb-local-ref_ element
describes the interface requirements that the referencing application
component has for the referenced enterprise bean. The _ejb-ref_ element
is used for referencing an enterprise bean that is accessed through its
remote business interface or remote home and component interfaces. The
_ejb-local-ref_ element is used for referencing an enterprise bean that
is accessed through its local business interface, no-interface view, or
local home and component interfaces. The _ejb-ref_ element contains a
_description_ element and the _ejb-ref-name_ , _ejb-ref-type_ , _home_ ,
and _remote_ elements. The _ejb-local-ref_ element contains a
_description_ element and the _ejb-ref-name_ , _ejb-ref-type_ ,
_local-home_ , and _local_ elements

[#50581511_pgfId-7854]##The _ejb-ref-name_ element specifies the EJB
reference name. Its value is the environment entry name used in the
application component code. The optional _ejb-ref-type_ element
specifies the expected type of the enterprise bean. Its value must be
either _Entity_ or _Session_ . The _home_ and _remote_ or _local-home_
and _local_ elements specify the expected Java programming language
types of the referenced enterprise bean’s interface(s). If the reference
is to an EJB 2.x remote client view interface, the _home_ element is
required. Likewise, if the reference is to an EJB 2.x local client view
interface, the _local-home_ element is required. The _remote_ element of
the _ejb-ref_ element refers to either the business interface type or
the component interface, depending on whether the reference is to a
bean’s EJB 3.x or EJB 2.x remote client view. Likewise, the _local_
element of the _ejb-local-ref_ element refers to either the business
interface type, bean class type, or the component interface type,
depending on whether the reference is to a bean’s EJB 3.x local business
interface, no-interface view, or EJB 2.x local client view respectively.

[#50581511_pgfId-14854]##An EJB reference is scoped to the application
component whose declaration contains the _ejb-ref_ or _ejb-local-ref_
element. This means that the EJB reference is not accessible from other
application components at runtime and that other application components
may define _ejb-ref_ or _ejb-local-ref_ elements with the same
_ejb-ref-name_ without causing a name conflict.

[#50581511_pgfId-999056]##The lookup-name element specifies the JNDI
name of an environment entry that provides a value for the reference.

[#50581511_pgfId-7855]##The following example illustrates the
declaration of EJB references in the deployment descriptor.

======= [#50581511_pgfId-7864]##...

[#50581511_pgfId-7865]##<ejb-ref>

[#50581511_pgfId-7866]## <description>

[#50581511_pgfId-7867]## This is a reference to the entity bean that

[#50581511_pgfId-7868]## encapsulates access to employee records.

[#50581511_pgfId-7869]## </description>

[#50581511_pgfId-7870]## <ejb-ref-name>ejb/EmplRecord</ejb-ref-name>

[#50581511_pgfId-7871]## <ejb-ref-type>Entity</ejb-ref-type>

[#50581511_pgfId-7872]## <home>com.wombat.empl.EmployeeRecordHome</home>

[#50581511_pgfId-7873]## <remote>com.wombat.empl.EmployeeRecord</remote>

[#50581511_pgfId-7874]##</ejb-ref>

[#50581511_pgfId-7875]## 

[#50581511_pgfId-7876]##<ejb-ref>

[#50581511_pgfId-7877]## <ejb-ref-name>ejb/Payroll</ejb-ref-name>

[#50581511_pgfId-7878]## <ejb-ref-type>Entity</ejb-ref-type>

[#50581511_pgfId-7879]## <home>com.aardvark.payroll.PayrollHome</home>

[#50581511_pgfId-7880]## <remote>com.aardvark.payroll.Payroll</remote>

[#50581511_pgfId-7881]##</ejb-ref>

[#50581511_pgfId-7882]## 

[#50581511_pgfId-7883]##<ejb-ref>

[#50581511_pgfId-7884]## <ejb-ref-name>ejb/PensionPlan</ejb-ref-name>

[#50581511_pgfId-7885]## <ejb-ref-type>Session</ejb-ref-type>

[#50581511_pgfId-7886]## <home>com.wombat.empl.PensionPlanHome</home>

[#50581511_pgfId-7887]## <remote>com.wombat.empl.PensionPlan</remote>

[#50581511_pgfId-999089]##
<lookup-name>java:global/personnel/retirement/PensionPlan</lookup-name>

[#50581511_pgfId-7888]##</ejb-ref>

======= [#50581511_pgfId-7889]##...

======= [#50581511_pgfId-7894]##Application Assembler’s Responsibilities

[#50581511_pgfId-7895]##The Application Assembler can use the _ejb-link_
element in the deployment descriptor to link an EJB reference to a
target enterprise bean.

[#50581511_pgfId-7896]##The Application Assembler specifies the link to
an enterprise bean as follows:

* [#50581511_pgfId-9655]##The Application Assembler uses the optional
_ejb-link_ element of the _ejb-ref_ or _ejb-local-ref_ element of the
referencing application component. The value of the _ejb-link_ element
is the name of the target enterprise bean. This is the name as defined
by the metadata annotation (or default) on the bean class or in the
_ejb-name_ element for the target enterprise bean. The target enterprise
bean can be in any ejb-jar file or war file in the same Java EE
application as the referencing application component.
* [#50581511_pgfId-14880]##Alternatively, to avoid the need to rename
enterprise beans to have unique names within an entire Java EE
application, the Application Assembler may use either of the following
two syntaxes in the _ejb-link_ element of the referencing application
component.
* [#50581511_pgfId-1000675]##The Application Assembler specifies the
module name of the ejb-jar file or war file containing the referenced
enterprise bean and appends the ejb-name of the target bean separated by
“/”. The module name is the base name of the bundle with no filename
extension, unless specified in the deployment descriptor.
* [#50581511_pgfId-1000691]##The Application Assembler specifies the
path name of the ejb-jar file containing the referenced enterprise bean
and appends the _ejb-name_ of the target bean separated from the path
name by “ _#_ ”. The path name is relative to the referencing
application component JAR file. In this manner, multiple beans with the
same _ejb-name_ may be uniquely identified when the Application
Assembler cannot change ejb-names.
* [#50581511_pgfId-999090]##Alternatively to the use of _ejb-link_ , the
Application Assembler may use the _lookup-name_ element to reference the
target EJB component by means of one of its JNDI names. It is an error
for both _ejb-link_ and _lookup-name_ to appear inside an _ejb-ref_
element.
* [#50581511_pgfId-14884]##The Application Assembler must ensure that
the target enterprise bean is type-compatible with the declared EJB
reference. This means that the target enterprise bean must be of the
type indicated in the _ejb-ref-type_ element, if present, and that the
business interface, no-interface view, or home and remote interfaces of
the target enterprise bean must be Java type-compatible with the type
declared in the EJB reference.

[#50581511_pgfId-8745]##The following example illustrates the use of the
_ejb-link_ element in the deployment descriptor. The enterprise bean
reference should be satisfied by the bean named _EmployeeRecord_ . The
_EmployeeRecord_ enterprise bean may be packaged in the same module as
the component making this reference, or it may be packaged in another
module within the same Java EE application as the component making this
reference.

======= [#50581511_pgfId-8747]##...

[#50581511_pgfId-8748]##<ejb-ref>

[#50581511_pgfId-8749]## <description>

[#50581511_pgfId-8750]## This is a reference to the entity bean that

[#50581511_pgfId-8751]## encapsulates access to employee records. It

[#50581511_pgfId-8782]## has been linked to the entity bean named

[#50581511_pgfId-8783]## EmployeeRecord in this application.

[#50581511_pgfId-8752]## </description>

[#50581511_pgfId-8753]## <ejb-ref-name>ejb/EmplRecord</ejb-ref-name>

[#50581511_pgfId-8754]## <ejb-ref-type>Entity</ejb-ref-type>

[#50581511_pgfId-8755]## <home>com.wombat.empl.EmployeeRecordHome</home>

[#50581511_pgfId-8756]## <remote>com.wombat.empl.EmployeeRecord</remote>

[#50581511_pgfId-8777]## <ejb-link>EmployeeRecord</ejb-link>

[#50581511_pgfId-8757]##</ejb-ref>

======= [#50581511_pgfId-8772]##...

[#50581511_pgfId-14685]##The following example illustrates using the
_ejb-link_ element to indicate an enterprise bean reference to the
_ProductEJB_ enterprise bean that is in the same Java EE application
unit but in a different ejb-jar file.

======= [#50581511_pgfId-14689]##...

[#50581511_pgfId-14690]##<ejb-ref>

[#50581511_pgfId-9673]## <description>

[#50581511_pgfId-9674]## This is a reference to the entity bean that

[#50581511_pgfId-9675]## encapsulates access to a product. It

[#50581511_pgfId-9676]## has been linked to the entity bean named

[#50581511_pgfId-9677]## ProductEJB in the product.jar file in this

[#50581511_pgfId-12966]## application.

[#50581511_pgfId-9678]## </description>

[#50581511_pgfId-9679]## <ejb-ref-name>ejb/Product</ejb-ref-name>

[#50581511_pgfId-9680]## <ejb-ref-type>Entity</ejb-ref-type>

[#50581511_pgfId-9681]## <home>com.acme.products.ProductHome</home>

[#50581511_pgfId-9682]## <remote>com.acme.products.Product</remote>

[#50581511_pgfId-9683]##
<ejb-link>../products/product.jar#ProductEJB</ejb-link>

[#50581511_pgfId-9684]##</ejb-ref>

======= [#50581511_pgfId-9685]##...

[#50581511_pgfId-16858]##The following example illustrates using the
_ejb-link_ element to indicate an enterprise bean reference to the
_ShoppingCart_ enterprise bean that is in the same Java EE application
unit but in a different ejb-jar file. The reference was originally
declared in the application component’s code using an annotation. The
Assembler provides only the link to the bean.

======= [#50581511_pgfId-16862]##...

[#50581511_pgfId-16863]##<ejb-ref>

[#50581511_pgfId-16871]##
<ejb-ref-name>ShoppingService/myCart</ejb-ref-name>

[#50581511_pgfId-16875]##
<ejb-link>../products/product.jar#ShoppingCart</ejb-link>

[#50581511_pgfId-16876]##</ejb-ref>

======= [#50581511_pgfId-16877]##...

[#50581511_pgfId-1007576]##The same effect can be obtained by using the
_lookup-name_ element instead, using an appropriate JNDI name for the
target bean.

[#50581511_pgfId-1007577]## 

[#50581511_pgfId-999643]##...

[#50581511_pgfId-999644]##<ejb-ref>

[#50581511_pgfId-999645]##
<ejb-ref-name>ShoppingService/myCart</ejb-ref-name>

[#50581511_pgfId-999646]##
<lookup-name>java:app/products/ShoppingCart</lookup-name>

[#50581511_pgfId-999647]##</ejb-ref>

[#50581511_pgfId-999641]##...

======= [#50581511_pgfId-7930]##Deployer’s Responsibilities

[#50581511_pgfId-7931]##The Deployer is responsible for the following:

* [#50581511_pgfId-7932]##The Deployer must ensure that all the declared
EJB references are bound to the business interfaces, no-interface views,
or home interfaces of enterprise beans that exist in the operational
environment. The Deployer may use, for example, the JNDI _LinkRef_
mechanism to create a symbolic link to the actual JNDI name of the
target enterprise bean.
* [#50581511_pgfId-7933]##The Deployer must ensure that the target
enterprise bean is type-compatible with the types declared for the EJB
reference. This means that the target enterprise bean must be of the
type indicated in the _ejb-ref-type_ element or specified via the _EJB_
annotation, and that the business interface, no-interface view, or home
and remote interfaces of the target enterprise bean must be Java
type-compatible with the type declared in the EJB reference (if
specified).
* [#50581511_pgfId-7934]##If an EJB reference declaration includes the
_ejb-link_ element, the Deployer should bind the enterprise bean
reference to the enterprise bean specified as the link’s target. If an
EJB annotation includes the _lookup_ element or the EJB reference
declaration includes the _lookup-name_ element, the Deployer should bind
the enterprise bean reference to the enterprise bean specified as the
target of the lookup. It is an error for an EJB reference declaration to
include both an _ejb-link_ and a _lookup-name_ element.

[#50581511_pgfId-1000741]##The following example illustrates the use of
the _lookup-name_ element to bind an _ejb-ref_ to a target enterprise
bean in the operational environment. The reference was originally
declared in the bean’s code using an annotation. The target enterprise
bean has _ejb-name_ _ShoppingCart_ and is deployed in the stand-alone
module _products.jar_ .

[#50581511_pgfId-1000742]##...

[#50581511_pgfId-1000743]##<ejb-ref>

[#50581511_pgfId-1000744]##
<ejb-ref-name>ShoppingService/myCart</ejb-ref-name>

[#50581511_pgfId-1000745]##
<lookup-name>java:global/products/ShoppingCart</lookup-name>

[#50581511_pgfId-1000746]##</ejb-ref>

======= [#50581511_pgfId-7935]##Java EE Product Provider’s Responsibilities

[#50581511_pgfId-7936]##The Java EE Product Provider must provide the
deployment tools that allow the Deployer to perform the tasks described
in the previous subsection. The deployment tools provided by the Java EE
Product Provider must be able to process the information supplied in
class file annotations and in the _ejb-ref_ and _ejb-local-ref_ elements
in the deployment descriptor.

[#50581511_pgfId-7937]##At the minimum, the tools must be able to:

* [#50581511_pgfId-7938]##Preserve the application assembly information
in annotations or in the _ejb-link_ elements by binding an EJB reference
to the business interface, no-interface view, or home interface of the
specified target enterprise bean.
* [#50581511_pgfId-7939]##Inform the Deployer of any unresolved EJB
references, and allow him or her to resolve an EJB reference by binding
it to a specified compatible target enterprise bean.

==== [#50581511_pgfId-7941]##[#50581511_31473]##Web Service References

[#50581511_pgfId-997062]##A web service reference is similar to an
Enterprise JavaBeans reference, but is used to reference a web service.
Web service references are fully specified in the Web Service
specification and the JAX-WS specification.

==== [#50581511_pgfId-997061]##[#50581511_11574]##Resource Manager Connection Factory References

[#50581511_pgfId-7942]##A resource manager connection factory is an
object that is used to create connections to a resource manager. For
example, an object that implements the _javax.sql.DataSource_ interface
is a resource manager connection factory for _java.sql.Connection_
objects that implement connections to a database management system.

[#50581511_pgfId-7943]##This section describes the application component
programming and deployment descriptor interfaces that allow the
application component code to refer to resource factories using logical
names called resource manager connection factory references. The
resource manager connection factory references are special entries in
the application component’s environment. The Deployer binds the resource
manager connection factory references to the actual resource manager
connection factories that exist in the target operational environment.
Because these resource manager connection factories allow the Container
to affect resource management, the connections acquired through the
resource manager connection factory references are called managed
resources (for example, these resource manager connection factories
allow the Container to implement connection pooling and automatic
enlistment of the connection with a transaction).

[#50581511_pgfId-8629]##Resource manager connection factory objects
accessed through the naming environment are only valid within the
component instance that performed the lookup. See the individual
component specifications for additional restrictions that may apply.

======= [#50581511_pgfId-7945]##[#50581511_49875]##Application Component Provider’s Responsibilities

[#50581511_pgfId-7946]##This subsection describes the Application
Component Provider’s view of locating resource factories and defines his
or her responsibilities. It does so in three sections, the first
describing the annotations used to inject resource manager connection
factory references, the second describing the API for accessing resource
manager connection factory references, and the third describing the
syntax for declaring the factory references in a deployment descriptor

======= [#50581511_pgfId-16917]##Injection of Resource Manager Connection Factory References

[#50581511_pgfId-16920]##A field or a method of an application component
may be annotated with the _Resource_ annotation. The name and type of
the factory are as described above. The _authenticationType_ and
_shareable_ elements of the _Resource_ annotation may be used to control
the type of authentication desired for the resource and the shareability
of connection acquired from the factory, as described in the following
sections.

[#50581511_pgfId-16921]##The following code example illustrates how an
application component uses annotations to declare resource manager
connection factory references.

======= [#50581511_pgfId-16922]##// The employee database.

[#50581511_pgfId-16953]##@Resource javax.sql.DataSource employeeAppDB;

[#50581511_pgfId-16958]##public void changePhoneNumber(...) \{

[#50581511_pgfId-16929]## ...

[#50581511_pgfId-16966]## // Invoke factory to obtain a resource. The
security

[#50581511_pgfId-16967]## // principal for the resource is not given,
and

[#50581511_pgfId-16968]## // therefore it will be configured by the
Deployer.

[#50581511_pgfId-16969]## java.sql.Connection con =
employeeAppDB.getConnection();

[#50581511_pgfId-16935]## ...

======= [#50581511_pgfId-16936]##}

[#50581511_pgfId-999148]##It is possible to specify as part of the
_@Resource_ annotation the JNDI name of an entry to which the resource
being defined will be bound.

======= [#50581511_pgfId-999149]##// The customer database, looked up in the application environment.

[#50581511_pgfId-999150]##@Resource(lookup="java:app/env/customerDB")

[#50581511_pgfId-1000778]##javax.sql.DataSource customerAppDB;

[#50581511_pgfId-999146]## 

[#50581511_pgfId-999160]##The data source object being looked up in the
previous example may have been declared as follows.

[#50581511_pgfId-999162]## 

[#50581511_pgfId-999165]##@Resource(name="java:app/env/customerDB",

[#50581511_pgfId-999170]## type=javax.sql.DataSource.class)

[#50581511_pgfId-999171]##public class AnApplicationClass \{

[#50581511_pgfId-999172]## ...

[#50581511_pgfId-999173]##}

[#50581511_pgfId-999163]## 

[#50581511_pgfId-999174]##From a practical standpoint, declaring a
commonly used data source at the application level and referring to it
using lookup from multiple components may simplify the task of deploying
the application, since now the Deployer will have to perform a single
binding operation for the application-level resource, instead of
multiple ones. The task can be further simplified by using a data source
resource definition, see
link:JavaEE_Platform_Spec.htm#50581511_11623[See DataSource Resource
Definition]”. Of course, nothing prevents the Deployer from separately
binding each data source reference if necessary.

======= [#50581511_pgfId-7947]##Programming Interfaces for Resource Manager Connection Factory References

[#50581511_pgfId-7948]##The Application Component Provider may use
resource manager connection factory references to obtain connections to
resources as follows.

* [#50581511_pgfId-7949]##Assign an entry in the application component’s
naming environment to the resource manager connection factory reference.
(See subsection link:JavaEE_Platform_Spec.htm#50581511_23196[See
Declaration of Resource Manager Connection Factory References in
Deployment Descriptor] for information on how resource manager
connection factory references are declared in the deployment
descriptor.)
* [#50581511_pgfId-7953]##This specification recommends, but does not
require, that all resource manager connection factory references be
organized in the subcontexts of the application component’s environment,
using a different subcontext for each resource manager type. For
example, all JDBC™ DataSource references should be declared in the
_java:comp/env/jdbc_ subcontext, all JMS connection factories in the
_java:comp/env/jms_ subcontext, all JavaMail connection factories in the
_java:comp/env/mail_ subcontext, and all URL connection factories in the
_java:comp/env/url_ subcontext. Note that resource manager connection
factory references declared via annotations will not, by default, appear
in any subcontext.
* [#50581511_pgfId-7954]##Lookup the resource manager connection factory
object in the application component’s environment using the JNDI
interface.
* [#50581511_pgfId-14892]##Invoke the appropriate method on the resource
manager connection factory object to obtain a connection to the
resource. The factory method is specific to the resource type. It is
possible to obtain multiple connections by calling the factory object
multiple times.

[#50581511_pgfId-14893]##The Application Component Provider can control
the shareability of the connections acquired from the resource manager
connection factory. By default, connections to a resource manager are
shareable across other application components in the application that
use the same resource in the same transaction context. The Application
Component Provider can specify that connections obtained from a resource
manager connection factory reference are not shareable by specifying the
value of the _shareable_ annotation element to _false_ or the
_res-sharing-scope_ deployment descriptor element to be _Unshareable_ .
The sharing of connections to a resource manager allows the container to
optimize the use of connections and enables the container’s use of local
transaction optimizations.

[#50581511_pgfId-14894]##The Application Component Provider has two
choices with respect to dealing with associating a principal with the
resource manager access:

* [#50581511_pgfId-7957]##Allow the Deployer to set up principal mapping
or resource manager sign on information. In this case, the application
component code invokes a resource manager connection factory method that
has no security-related parameters.
* [#50581511_pgfId-7958]##Sign on to the resource from the application
component code. In this case, the application component invokes the
appropriate resource manager connection factory method that takes the
sign on information as method parameters.

[#50581511_pgfId-7959]##The Application Component Provider uses the
_authenticationType_ annotation element or the _res-auth_ deployment
descriptor element to indicate which of the two resource authentication
approaches is used.

[#50581511_pgfId-7960]##We expect that the first form (that is letting
the Deployer set up the resource sign on information) will be the
approach used by most application components.

[#50581511_pgfId-7961]##The following code sample illustrates obtaining
a JDBC connection.

======= [#50581511_pgfId-7965]## public void changePhoneNumber(...) \{

[#50581511_pgfId-7966]## ...

[#50581511_pgfId-7967]## 

[#50581511_pgfId-7968]## // obtain the initial JNDI context

[#50581511_pgfId-7969]## Context initCtx = new InitialContext();

[#50581511_pgfId-7970]##

[#50581511_pgfId-7971]## // perform JNDI lookup to obtain resource
manager

[#50581511_pgfId-14693]## // connection factory

[#50581511_pgfId-7972]## javax.sql.DataSource ds =
(javax.sql.DataSource)

[#50581511_pgfId-7973]##
initCtx.lookup("java:comp/env/jdbc/EmployeeAppDB");

[#50581511_pgfId-7974]## 

[#50581511_pgfId-7975]## // Invoke factory to obtain a resource. The
security

[#50581511_pgfId-7976]## // principal for the resource is not given, and

[#50581511_pgfId-7977]## // therefore it will be configured by the
Deployer.

[#50581511_pgfId-7978]## java.sql.Connection con = ds.getConnection();

[#50581511_pgfId-7979]## ...

======= [#50581511_pgfId-7980]## }

======= [#50581511_pgfId-7984]##[#50581511_23196]##Declaration of Resource Manager Connection Factory References in Deployment Descriptor

[#50581511_pgfId-7985]##Although a resource manager connection factory
reference is an entry in the application component’s environment, the
Application Component Provider must not use an _env-entry_ element to
declare it.

[#50581511_pgfId-7986]##Instead, the Application Component Provider must
declare all the resource manager connection factory references using
either annotations on the application component’s code or in the
deployment descriptor using the _resource-ref_ elements. This allows the
consumer of the application component’s JAR file (the Application
Assembler or Deployer) to discover all the resource manager connection
factory references used by an application component. Deployment
descriptor entries may also be used to specify injection of a resource
manager connection factory reference into an application component.

[#50581511_pgfId-7987]##Each _resource-ref_ element describes a single
resource manager connection factory reference. The _resource-ref_
element consists of the _description_ element, the mandatory
_res-ref-name_ element, and the optional _res-sharing-scope_ ,
_res-type_ , and _res-auth_ elements. The _res-ref-name_ element
contains the name of the environment entry used in the application
component’s code. The name of the environment entry is relative to the
_java:comp/env_ context (for example, the name should be
_jdbc/EmployeeAppDB_ rather than _java:comp/env/jdbc/EmployeeAppDB_ ).
The _res-type_ element contains the Java programming language type of
the resource manager connection factory that the application component
code expects. The _res-type_ element is optional if an injection target
is specified for this resource; in this case the _res-type_ defaults to
the type of the injection target. The _res-auth_ element indicates
whether the application component code performs resource sign on
programmatically, or whether the container signs on to the resource
based on the principal mapping information supplied by the Deployer. The
Application Component Provider indicates the sign on responsibility by
setting the value of the _res-auth_ element to _Application_ or
_Container_ . If not specified, the default is _Container_ . The
_res-sharing-scope_ element indicates whether connections to the
resource manager obtained through the given resource manager connection
factory reference can be shared or whether connections are unshareable.
The value of the _res-sharing-scope_ element is _Shareable_ or
_Unshareable_ . If the _res-sharing-scope_ element is not specified,
connections are assumed to be shareable.

[#50581511_pgfId-9404]##A resource manager connection factory reference
is scoped to the application component whose declaration contains the
_resource-ref_ element. This means that the resource manager connection
factory reference is not accessible from other application components at
runtime, and that other application components may define _resource-ref_
elements with the same _res-ref-name_ without causing a name conflict.

[#50581511_pgfId-7988]##The type declaration allows the Deployer to
identify the type of the resource manager connection factory.

[#50581511_pgfId-9415]##Note that the indicated type is the Java
programming language type of the resource manager connection factory,
not the type of the connection.

[#50581511_pgfId-9416]##The following example is the declaration of the
resource reference used by the application component illustrated in the
previous subsection.

======= [#50581511_pgfId-7999]##...

[#50581511_pgfId-8000]##<resource-ref>

[#50581511_pgfId-8001]## <description>

[#50581511_pgfId-8002]## A data source for the database in which

[#50581511_pgfId-8003]## the EmployeeService enterprise bean will

[#50581511_pgfId-8004]## record a log of all transactions.

[#50581511_pgfId-8005]## </description>

[#50581511_pgfId-8006]## <res-ref-name>jdbc/EmployeeAppDB</res-ref-name>

[#50581511_pgfId-8007]## <res-type>javax.sql.DataSource</res-type>

[#50581511_pgfId-8008]## <res-auth>Container</res-auth>

[#50581511_pgfId-14911]##
<res-sharing-scope>Shareable</res-sharing-scope>

[#50581511_pgfId-8009]##</resource-ref>

[#50581511_pgfId-999226]## 

[#50581511_pgfId-999227]##The following example modifies the previous
one by linking the resource reference being defined to another one,
using a well-known JNDI name for the latter.

[#50581511_pgfId-999235]## 

[#50581511_pgfId-999228]##<resource-ref>

[#50581511_pgfId-999203]##<res-ref-name>jdbc/EmployeeAppDB</res-ref-name>

[#50581511_pgfId-999204]## <res-type>javax.sql.DataSource</res-type>

[#50581511_pgfId-999205]## <res-auth>Container</res-auth>

[#50581511_pgfId-999206]##
<res-sharing-scope>Shareable</res-sharing-scope>

[#50581511_pgfId-999240]##
<lookup-name>java:app/env/TheEmployeeDB</lookup-name>

[#50581511_pgfId-999207]##</resource-ref>

======= [#50581511_pgfId-8014]##[#50581511_37977]##Standard Resource Manager Connection Factory Types

[#50581511_pgfId-8015]##The Application Component Provider must use the
_javax.sql.DataSource_ resource manager connection factory type for
obtaining JDBC API connections.

[#50581511_pgfId-8899]##The Application Component Provider must use the
_javax.jms.ConnectionFactory_ , the _javax.jms.QueueConnectionFactory_ ,
or the _javax.jms.TopicConnectionFactory_ for obtaining JMS connections.

[#50581511_pgfId-8891]##The Application Component Provider must use the
_javax.mail.Session_ resource manager connection factory type for
obtaining JavaMail API connections.

[#50581511_pgfId-8879]##The Application Component Provider must use the
_java.net.URL_ resource manager connection factory type for obtaining
URL connections.

[#50581511_pgfId-8865]##It is recommended that the Application Component
Provider name JDBC API data sources in the _java:comp/env/jdbc_
subcontext, all JMS connection factories in the _java:comp/env/jms_
subcontext, all JavaMail API connection factories in the
_java:comp/env/mail_ subcontext, and all URL connection factories in the
_java:comp/env/url_ subcontext. Note that resource manager connection
factory references declared via annotations will not, by default, appear
in any subcontext.

[#50581511_pgfId-8869]##The Java EE Connector Architecture allows an
application component to use the annotation or API described in this
section to obtain resource objects that provide access to additional
back-end systems.

======= [#50581511_pgfId-8019]##[#50581511_16016]##Deployer’s Responsibilities

[#50581511_pgfId-8020]##The Deployer uses deployment tools to bind the
resource manager connection factory references to the actual resource
factories configured in the target operational environment.

[#50581511_pgfId-8021]##The Deployer must perform the following tasks
for each resource manager connection factory reference declared in the
deployment descriptor:

* [#50581511_pgfId-8022]##Bind the resource manager connection factory
reference to a resource manager connection factory that exists in the
operational environment. The Deployer may use, for example, the JNDI
_LinkRef_ mechanism to create a symbolic link to the actual JNDI name of
the resource manager connection factory. The resource manager connection
factory type must be compatible with the type declared in the source
code or in the _res-type_ element. If the resource manager connection
factory references includes a _lookup_ annotation element or a
_lookup-name_ deployment descriptor element, the Deployer may choose
whether to honor it and have the corresponding lookup be performed, or
override it with a binding of his or her own choosing.
* [#50581511_pgfId-8023]##Provide any additional configuration
information that the resource manager needs for opening and managing the
resource. The configuration mechanism is resource manager specific, and
is beyond the scope of this specification.
* [#50581511_pgfId-8024]##If the value of the _Resource_ annotation
_authenticationType_ element is _AuthenticationType.CONTAINER_ or the
deployment descriptor’s _res-auth_ element is _Container_ , the Deployer
is responsible for configuring the sign on information for the resource
manager. This is performed in a manner specific to the container and
resource manager; it is beyond the scope of this specification.

[#50581511_pgfId-8025]##For example, if principals must be mapped from
the security domain and principal realm used at the application
component level to the security domain and principal realm of the
resource manager, the Deployer or System Administrator must define the
mapping. The mapping is performed in a manner specific to the container
and resource manager; it is beyond the scope of this specification.

======= [#50581511_pgfId-8027]##Java EE Product Provider’s Responsibilities

[#50581511_pgfId-8028]##The Java EE Product Provider is responsible for
the following:

* [#50581511_pgfId-8029]##Provide the deployment tools that allow the
Deployer to perform the tasks described in the previous subsection.
* [#50581511_pgfId-8030]##Provide the implementation of the resource
manager connection factory classes that are required by this
specification.
* [#50581511_pgfId-8031]##If the Application Component Provider sets the
_authenticationType_ element of the _Resource_ annotation to
_AuthenticationType.APPLICATION_ or the _res-auth_ of a resource
reference to _Application_ , the container must allow the application
component to perform explicit programmatic sign on using the resource
manager’s API.
* [#50581511_pgfId-14914]##If the Application Component Provider sets
the _shareable_ element of the _Resource_ annotation to _false_ or sets
the _res-sharing-scope_ of a resource manager connection factory
reference to _Unshareable_ , the container must not attempt to share the
connections obtained from the resource manager connection factory
referencelink:#pgfId-14923[12].
* [#50581511_pgfId-8032]##The container must provide tools that allow
the Deployer to set up resource sign on information for the resource
manager references whose _authenticationType_ is set to
_AuthenticationType.CONTAINER_ or whose _res-auth_ element is set to
_Container_ . The minimum requirement is that the Deployer must be able
to specify the username/password information for each resource manager
connection factory reference declared by the application component, and
the container must be able to use the username/password combination for
user authentication when obtaining a connection by invoking the resource
manager connection factory.

[#50581511_pgfId-8033]##Although not required by this specification, we
expect that containers will support some form of a single sign on
mechanism that spans the application server and the resource managers.
The container will allow the Deployer to set up the resources such that
the principal can be propagated (directly or through principal mapping)
to a resource manager, if required by the application.

[#50581511_pgfId-8034]##While not required by this specification, most
Java EE products will provide the following features:

* [#50581511_pgfId-8035]##A tool to allow the System Administrator to
add, remove, and configure a resource manager for the Java EE Server.
* [#50581511_pgfId-8036]##A mechanism to pool resources for the
application components and otherwise manage the use of resources by the
container. The pooling must be transparent to the application
components.

======= [#50581511_pgfId-8037]##System Administrator’s Responsibilities

[#50581511_pgfId-8038]##The System Administrator is typically
responsible for the following:

* [#50581511_pgfId-8039]##Add, remove, and configure resource managers
in the Java EE Server environment.

[#50581511_pgfId-8040]##In some scenarios, these tasks can be performed
by the Deployer.

==== [#50581511_pgfId-9520]##[#50581511_30282]##Resource Environment References

[#50581511_pgfId-997163]##This section describes the programming and
deployment descriptor interfaces that allow the Application Component
Provider to refer to administered objects that are associated with a
resource (for example, a Connector CCI _InteractionSpec_ instance) by
using “logical” names called resource environment references. The
resource environment references are special entries in the application
component’s environment. The Deployer binds the resource environment
references to administered objects in the target operational
environment.

======= [#50581511_pgfId-997165]##Application Component Provider’s Responsibilities

[#50581511_pgfId-9523]##This subsection describes the Application
Component Provider’s view and responsibilities with respect to resource
environment references.

======= [#50581511_pgfId-16990]##Injection of Resource Environment References

[#50581511_pgfId-16995]##A field or a method of an application component
may be annotated with the _Resource_ annotation to request injection of
a resouce environment reference. The name and type of the resource
environment reference are as described earlier. The _authenticationType_
and _shareable_ elements of the _Resource_ annotation must not be
specified; resource environment entries are not shareable and do not
require authentication. The use of the _Resource_ annotation to declare
a resource environment reference differs from the use of the _Resource_
annotation to declare other environment references only in that the type
of a resource environment reference is not one of the Java language
types used for other environment references.

======= [#50581511_pgfId-9524]##Resource Environment Reference Programming Interfaces

[#50581511_pgfId-9525]##The Application Component Provider may use
resource environment references to locate administered objects that are
associated with resources as follows.

* [#50581511_pgfId-9526]##Assign an entry in the application component’s
environment to the reference. (See subsection
link:JavaEE_Platform_Spec.htm#50581511_91929[See Declaration of Resource
Environment References in Deployment Descriptor] for information on how
resource environment references are declared in the deployment
descriptor.)
* [#50581511_pgfId-9736]##This specification recommends, but does not
require, that all resource environment references be organized in the
appropriate subcontext of the component’s environment for the resource
type. Note that resource environment references declared via annotations
will not, by default, appear in any subcontext.
* [#50581511_pgfId-9531]##Look up the administered object in the
application component’s environment using JNDI.

======= [#50581511_pgfId-9549]##[#50581511_91929]##Declaration of Resource Environment References in Deployment Descriptor

[#50581511_pgfId-9552]##Although the resource environment reference is
an entry in the application component’s environment, the Application
Component Provider must not use a _env-entry_ element to declare it.
Instead, the Application Component Provider must declare all references
to administered objects associated with resources using either
annotations on the application component’s code or the
_resource-env-ref_ elements of the deployment descriptor. This allows
the application component’s JAR file consumer to discover all the
resource environment references used by the application component.
Deployment descriptor entries may also be used to specify injection of a
resource environment reference into an application component.

[#50581511_pgfId-18698]##Each _resource-env-ref_ element describes the
requirements that the referencing application component has for the
referenced administered object. The _resource-env-ref_ element contains
optional _description_ and _resource-env-ref-type_ elements and the
mandatory _resource-env-ref-name_ element. The _resource-env-ref-type_
element is optional if an injection target is specified for this
resource; in this case the _resource-env-ref-type_ defaults to the type
of the injection target.

[#50581511_pgfId-9554]##The _resource-env-ref-name_ element specifies
the resource environment reference name. Its value is the environment
entry name used in the application component code. The name of the
resource environment reference is relative to the _java:comp/env_
context. The _resource-env-ref-type_ element specifies the expected type
of the referenced object.

[#50581511_pgfId-16317]##A resource environment reference is scoped to
the application component whose declaration contains the
_resource-env-ref_ element. This means that the resource environment
reference is not accessible to other application components at runtime,
and that other application components may define _resource-env-ref_
elements with the same _resource-env-ref-name_ without causing a name
conflict.

[#50581511_pgfId-999262]##A resource environment reference may specify a
_lookup-name_ to link the reference being defined to another one via a
JNDI name.

======= [#50581511_pgfId-16318]##Deployer’s Responsibilities

[#50581511_pgfId-16319]##The Deployer is responsible for the following:

* [#50581511_pgfId-9629]##The Deployer must ensure that all the declared
resource environment references are bound to administered objects that
exist in the operational environment. The Deployer may use, for example,
the JNDI _LinkRef_ mechanism to create a symbolic link to the actual
JNDI name of the target object. The Deployer may override the linkage
preferences of a resource environment reference that includes a _lookup_
annotation element or _lookup-name_ deployment descriptor element.
* [#50581511_pgfId-9630]##The Deployer must ensure that the target
object is type-compatible with the type declared for the resource
environment reference. This means that the target object must be of the
type indicated in the _Resource_ annotation or the
_resource-env-ref-type_ element.

======= [#50581511_pgfId-9622]##Java EE Product Provider’s Responsibilities

[#50581511_pgfId-9636]##The Java EE Product Provider must provide the
deployment tools that allow the Deployer to perform the tasks described
in the previous subsection. The deployment tools provided by the Java EE
Product Provider must be able to process the information supplied in the
class file annotations and the _resource-env-ref_ elements in the
deployment descriptor.

[#50581511_pgfId-9637]##At the minimum, the tools must be able to inform
the Deployer of any unresolved resource environment references, and
allow him or her to resolve a resource environment reference by binding
it to a specified compatible target object in the environment.

==== [#50581511_pgfId-15880]##[#50581511_29908]##Message Destination References

[#50581511_pgfId-15881]##This section describes the programming and
deployment descriptor interfaces that allow the Application Component
Provider to refer to message destination objects by using “logical”
names called message destination references. Message destination
references are special entries in the application component’s
environment. The Deployer binds the message destination references to
administered message destinations in the target operational environment.

[#50581511_pgfId-997170]##The requirements in this section only apply to
Java EE products that include support for JMS.

======= [#50581511_pgfId-15882]##Application Component Provider’s Responsibilities

[#50581511_pgfId-15883]##This subsection describes the Application
Component Provider’s view and responsibilities with respect to message
destination references.

======= [#50581511_pgfId-17024]##Injection of Message Destination References

[#50581511_pgfId-17027]##A field or a method of an application component
may be annotated with the _Resource_ annotation to request injection of
a message destination reference. The name and type of the resource
environment reference are as described earlier. The _authenticationType_
and _shareable_ elements of the _Resource_ annotation must not be
specified; message destination references are not shareable and do not
require authentication.

[#50581511_pgfId-17045]##Note that when using the _Resource_ annotation
to declare a message destination reference it is not possible to link
the reference to other references to the same message destination or to
specify whether the message destination is used to produce or consume
messages. The deployment descriptor entries described later do provide a
way to associate many message destination references with a single
message destination and to specify whether each message destination
reference is used to produce, consume, or both produce and consume
messages, so that the entire message flow of an application may be
specified. The Application Assembler may use these message destination
links to link together message destination references that have been
declared using the _Resource_ annotation. A message destination
reference declared via the _Resource_ annotation is assumed to be used
to both produce and consume messages; this default may be overridden
using a deployment descriptor entry.

[#50581511_pgfId-17058]##The following example illustrates how an
application component uses the Resource annotation to request injection
of a message destination reference.

[#50581511_pgfId-17066]##@Resource javax.jms.Queue stockQueue;

[#50581511_pgfId-999281]##The following example illustrates how a
message destination reference can be linked to another one by specifying
its JNDI name, perhaps in a different namespace, as a value for the
lookup element.

[#50581511_pgfId-999279]## 

[#50581511_pgfId-1002255]##@Resource(lookup="java:app/env/TheOrderQueue")

[#50581511_pgfId-1002251]##javax.jms.Queue orderQueue;

======= [#50581511_pgfId-15884]##Message Destination Reference Programming Interfaces

[#50581511_pgfId-15885]##The Application Component Provider may use
message destination references to locate message destinations, as
follows.

* [#50581511_pgfId-15886]##Assign an entry in the application
component’s environment to the reference. (See subsection
link:JavaEE_Platform_Spec.htm#50581511_69514[See Declaration of Message
Destination References in Deployment Descriptor] for information on how
message destination references are declared in the deployment
descriptor.)
* [#50581511_pgfId-15890]##This specification recommends, but does not
require, that all message destination references be organized in the
appropriate subcontext of the component’s environment for the resource
type (for example, in the _java:comp/env/jms_ JNDI context for JMS
Destinations). Note that message destination references declared via
annotations will not, by default, appear in any subcontext.
* [#50581511_pgfId-15891]##Look up the administered object in the
application component’s environment using JNDI.

[#50581511_pgfId-15892]##The following example illustrates how an
application component uses a message destination reference to locate a
JMS Destination.

======= [#50581511_pgfId-15893]##// Obtain the default initial JNDI context.

[#50581511_pgfId-15894]##Context initCtx = new InitialContext();

[#50581511_pgfId-15895]## 

[#50581511_pgfId-15896]##// Look up the JMS StockQueue in the
environment.

[#50581511_pgfId-15897]##Object result =
initCtx.lookup("java:comp/env/jms/StockQueue");

[#50581511_pgfId-15898]## 

[#50581511_pgfId-15899]##// Convert the result to the proper type.

======= [#50581511_pgfId-15900]##javax.jms.Queue queue = (javax.jms.Queue)result;

[#50581511_pgfId-15901]##In the example, the Application Component
Provider assigned the environment entry _jms/StockQueue_ as the message
destination reference name to refer to a JMS queue.

======= [#50581511_pgfId-15903]##[#50581511_69514]##Declaration of Message Destination References in Deployment Descriptor

[#50581511_pgfId-15904]##Although the message destination reference is
an entry in the application component’s environment, the Application
Component Provider must not use a _env-entry_ element to declare it.
Instead, the Application Component Provider should declare all
references to message destinations using either the _Resource_
annotation in the application component’s code or the
_message-destination-ref_ elements of the deployment descriptor. This
allows the application component’s JAR file consumer to discover all the
message destination references used by the application component.
Deployment descriptor entries may also be used to specify injection of a
message destination reference into an application component.

[#50581511_pgfId-15905]##Each _message-destination-ref_ element
describes the requirements that the referencing application component
has for the referenced destination. The _message-destination-ref_
element contains optional _description_ , _message-destination-type_ ,
and _message-destination-usage_ elements and the mandatory
_message-destination-ref-name_ element.

[#50581511_pgfId-18710]##The _message-destination-ref-name_ element
specifies the message destination reference name. Its value is the
environment entry name used in the application component code. By
default, the name of the message destination reference is relative to
the _java:comp/env_ context (for example, the name should be
_jms/StockQueue_ rather than _java:comp/env/jms/StockQueue_ ). The
_message-destination-type_ element specifies the expected type of the
referenced destination. For example, in the case of a JMS Destination,
its value might be _javax.jms.Queue_ . The _message-destination-type_
element is optional if an injection target is specified for this message
destination reference; in this case the _message-destination-type_
defaults to the type of the injection target. The
_message-destination-usage_ element specifies whether messages are
consumed from the message destination, produced for the destination, or
both. If not specified, messages are assumed to be both consumed and
produced.

[#50581511_pgfId-15907]##A message destination reference is scoped to
the application component whose declaration contains the
_message-destination-ref_ element. This means that the message
destination reference is not accessible to other application components
at runtime, and that other application components may define
_message-destination-ref_ elements with the same
_message-destination-ref-name_ without causing a name conflict.

[#50581511_pgfId-15908]##The following example illustrates the
declaration of message destination references in the deployment
descriptor.

======= [#50581511_pgfId-15909]##...

[#50581511_pgfId-15910]##<message-destination-ref>

[#50581511_pgfId-15911]## <description>

[#50581511_pgfId-15912]## This is a reference to a JMS queue used in the

[#50581511_pgfId-15913]## processing of Stock info

[#50581511_pgfId-15914]## </description>

[#50581511_pgfId-15915]## <message-destination-ref-name>

[#50581511_pgfId-16052]## jms/StockInfo

[#50581511_pgfId-16051]## </message-destination-ref-name>

[#50581511_pgfId-15916]## <message-destination-type>

[#50581511_pgfId-16053]## javax.jms.Queue

[#50581511_pgfId-16050]## </message-destination-type>

[#50581511_pgfId-16045]## _<message-destination-usage>_

[#50581511_pgfId-16054]## _Produces_

[#50581511_pgfId-16055]## _</message-destination-usage>_

[#50581511_pgfId-15917]##</message-destination-ref>

======= [#50581511_pgfId-15918]## ...

======= [#50581511_pgfId-16056]##Application Assembler’s Responsibilities

[#50581511_pgfId-16063]##By means of linking message consumers and
producers to one or more common logical destinations specified in the
enterprise bean deployment descriptor, the Application Assembler can
specify the flow of messages within an application. The Application
Assembler uses the _message-destination_ element, the
_message-destination-link_ element of the _message-destination-ref_
element, and the _message-destination-link_ element of an ejb-jar’s
_message-driven_ element to link message destination references to a
common logical destination.

[#50581511_pgfId-16064]##The Application Assembler specifies the link
between message consumers and producers as follows:

* [#50581511_pgfId-16065]##The Application Assembler uses the
_message-destination_ element to specify a logical message destination
within the application. The _message-destination_ element defines a
_message-destination-name_ , which is used for the purpose of linking.
* [#50581511_pgfId-16066]##The Application Assembler uses the
_message-destination-link_ element of the _message-destination-ref_
element of an application component that produces messages to link it to
the target destination. The value of the _message-destination-link_
element is the name of the target destination, as defined in the
_message-destination-name_ element of the _message-destination_ element.
The _message-destination_ element can be in any module in the same Java
EE application as the referencing component. The Application Assembler
uses the _message-destination-usage_ element of the
_message-destination-ref_ element to indicate that the referencing
application component produces messages to the referenced destination.
* [#50581511_pgfId-16067]##If the consumer of messages from the common
destination is a message-driven bean, the Application Assembler uses the
_message-destination-link_ element of the _message-driven_ element to
reference the logical destination. If the Application Assembler links a
message-driven bean to its source destination, he or she should use the
_message-destination-type_ element of the _message-driven_ element to
specify the expected destination type. Otherwise, the Application
Assembler uses the _message-destination-link_ element of the
_message-destination-ref_ element of the application component that
consumes messages to link to the common destination. In the latter case,
the Application Assembler uses the _message-destination-usage_ element
of the _message-destination-ref_ element to indicate that the
application component consumes messages from the referenced destination.
* [#50581511_pgfId-16068]##To avoid the need to rename message
destinations to have unique names within an entire Java EE application,
the Application Assembler may use the following syntax in the
_message-destination-link_ element of the referencing application
component. The Application Assembler specifies the path name of the JAR
file containing the referenced message destination and appends the
_message-destination-name_ of the target destination separated from the
path name by #. The path name is relative to the referencing application
component JAR file. In this manner, multiple destinations with the same
_message-destination-name_ may be uniquely identified.
* [#50581511_pgfId-16069]##When linking message destinations, the
Application Assembler must ensure that the consumers and producers for
the destination require a message destination of the same or compatible
type, as determined by the messaging system.

======= [#50581511_pgfId-15919]##Deployer’s Responsibilities

[#50581511_pgfId-15920]##The Deployer is responsible for the following:

* [#50581511_pgfId-15921]##The Deployer must ensure that all the
declared message destination references are bound to administered
objects that exist in the operational environment. The Deployer may use,
for example, the JNDI _LinkRef_ mechanism to create a symbolic link to
the actual JNDI name of the target object. The Deployer may override the
linkage preferences of a message destination reference that includes a
_lookup-name_ element.
* [#50581511_pgfId-16095]##The Deployer must ensure that the target
object is type-compatible with the type declared for the message
destination reference. This means that the target object must be of the
type indicated in the _message-destination-type_ element.
* [#50581511_pgfId-16096]##The Deployer must observe the message
destination links specified by the Application Assembler.

======= [#50581511_pgfId-16100]##Java EE Product Provider’s Responsibilities

[#50581511_pgfId-15930]##The Java EE Product Provider must provide the
deployment tools that allow the Deployer to perform the tasks described
in the previous subsection. The deployment tools provided by the Java EE
Product Provider must be able to process the information supplied in the
_message-destination-ref_ elements in the deployment descriptor.

[#50581511_pgfId-15934]##At the minimum, the tools must be able to
inform the Deployer of any unresolved message destination references,
and allow him or her to resolve a message destination reference by
binding it to a specified compatible target object in the environment.

==== [#50581511_pgfId-8519]##UserTransaction [#50581511_27391]##References

[#50581511_pgfId-18103]##Certain Java EE application component types are
allowed to use the JTA _UserTransaction_ interface to start, commit, and
abort transactions. Such application components can find an appropriate
object implementing the _UserTransaction_ interface by looking up the
JNDI name _java:comp/UserTransaction_ or by requesting injection of a
_UserTransaction_ object using the _Resource_ annotation. The
_authenticationType_ and _shareable_ elements of the _Resource_
annotation must not be specified. The container is only required to
provide the _java:comp/UserTransaction_ name, or inject a
_UserTransaction_ object, for those components that can validly make use
of it. Any such reference to a _UserTransaction_ object is only valid
within the component instance that performed the lookup. See the
individual component definitions for further information.

[#50581511_pgfId-17090]##The following example illustrates how an
application component acquires and uses a _UserTransaction_ object via
injection.

======= [#50581511_pgfId-17091]##@Resource UserTransaction tx;

[#50581511_pgfId-17121]## 

[#50581511_pgfId-17114]##public void updateData(...) \{

[#50581511_pgfId-17092]## ...

[#50581511_pgfId-17099]## // Start a transaction.

[#50581511_pgfId-17100]## tx.begin();

[#50581511_pgfId-17101]## ...

[#50581511_pgfId-17102]## // Perform transactional operations on data.

[#50581511_pgfId-17103]## ...

[#50581511_pgfId-17104]## // Commit the transaction.

[#50581511_pgfId-17105]## tx.commit();

[#50581511_pgfId-17106]## ...

======= [#50581511_pgfId-17107]##}

[#50581511_pgfId-8535]##The following example illustrates how an
application component acquires and uses a _UserTransaction_ object using
a JNDI lookup.

======= [#50581511_pgfId-8538]##public void updateData(...) \{

[#50581511_pgfId-8539]## ...

[#50581511_pgfId-17665]## // Obtain the default initial JNDI context.

[#50581511_pgfId-8541]## Context initCtx = new InitialContext();

[#50581511_pgfId-8543]##

[#50581511_pgfId-8544]## // Look up the UserTransaction object.

[#50581511_pgfId-8546]## UserTransaction tx =
(UserTransaction)initCtx.lookup(

[#50581511_pgfId-14705]## "java:comp/UserTransaction");

[#50581511_pgfId-8548]## 

[#50581511_pgfId-8549]## // Start a transaction.

[#50581511_pgfId-8573]## tx.begin();

[#50581511_pgfId-8574]## ...

[#50581511_pgfId-8575]## // Perform transactional operations on data.

[#50581511_pgfId-8576]## ...

[#50581511_pgfId-8577]## // Commit the transaction.

[#50581511_pgfId-8578]## tx.commit();

[#50581511_pgfId-8553]## ...

======= [#50581511_pgfId-8554]##}

[#50581511_pgfId-17560]##A _UserTransaction_ object reference may also
be declared in a deployment descriptor in the same way as a resource
environment reference. Such a deployment descriptor entry may be used to
specify injection of a _UserTransaction_ object.

[#50581511_pgfId-997175]##The requirements in this section only apply to
Java EE products that include support for JTA.

======= [#50581511_pgfId-8529]##Application Component Provider’s Responsibilities

[#50581511_pgfId-8583]##The Application Component Provider is
responsible for requesting injection of a _UserTransaction_ object using
a _Resource_ annotation, or using the defined name to look up the
_UserTransaction_ object.

[#50581511_pgfId-12883]##Only some application component types are
required to be able to access a _UserTransaction_ object; see
_link:JavaEE_Platform_Spec.htm#50581515_TABLE%206-1[See Java EE
Technologies]_ in this specification and the EJB specification for
details.

======= [#50581511_pgfId-8531]##Java EE Product Provider’s Responsibilities

[#50581511_pgfId-8585]##The Java EE Product Provider is responsible for
providing an appropriate _UserTransaction_ object as required by this
specification.

==== [#50581511_pgfId-18736]##[#50581511_91999]##TransactionSynchronizationRegistry References

[#50581511_pgfId-18742]##The JTA _TransactionSynchronizationRegistry_
interface may be used by system level components such as persistence
managers that may be packaged with EJB or web application components.
Such components can find an appropriate object implementing the
_TransactionSynchronizationRegistry_ interface by looking up the JNDI
name _java:comp/TransactionSynchronizationRegistry_ or by requesting
injection of a _TransactionSynchronizationRegistry_ object using the
_Resource_ annotation. The _authenticationType_ and _shareable_ elements
of the _Resource_ annotation must not be specified. The container is
only required to provide the
_java:comp/TransactionSynchronizationRegistry_ name, or inject a
_TransactionSynchronizationRegistry_ object, for those components that
can validly make use of it. Any such reference to a
_TransactionSynchronizationRegistry_ object is only valid within the
component instance that performed the lookup. See the individual
component definitions for further information.

[#50581511_pgfId-18777]##A _TransactionSynchronizationRegistry_ object
reference may also be declared in a deployment descriptor in the same
way as a resource environment reference. Such a deployment descriptor
entry may be used to specify injection of a
_TransactionSynchronizationRegistry_ object.

[#50581511_pgfId-997180]##The requirements in this section only apply to
Java EE products that include support for JTA.

======= [#50581511_pgfId-18778]##Application Component Provider’s Responsibilities

[#50581511_pgfId-18779]##The Application Component Provider is
responsible for requesting injection of a
_TransactionSynchronizationRegistry_ object using a _Resource_
annotation, or using the defined name to look up the
_TransactionSynchronizationRegistry_ object.

[#50581511_pgfId-18780]##Only some application component types are
required to be able to access a _TransactionSynchronizationRegistry_
object; see _link:JavaEE_Platform_Spec.htm#50581515_TABLE%206-1[See Java
EE Technologies]_ in this specification for details.

======= [#50581511_pgfId-18787]##Java EE Product Provider’s Responsibilities

[#50581511_pgfId-18791]##The Java EE Product Provider is responsible for
providing an appropriate _TransactionSynchronizationRegistry_ object as
required by this specification.

==== [#50581511_pgfId-15769]##[#50581511_72785]##ORB References

[#50581511_pgfId-15773]##Some Java EE applications will need to make use
of the CORBA ORB to perform certain operations. Such applications can
find an appropriate object implementing the _ORB_ interface by looking
up the JNDI name _java:comp/ORB_ or by requesting injection of an _ORB_
object. The container is required to provide the _java:comp/ORB_ name
for all components except applets. Any such reference to a _ORB_ object
is only valid within the component instance that performed the lookup.

[#50581511_pgfId-17588]##The following example illustrates how an
application component acquires and uses an _ORB_ object via injection.

======= [#50581511_pgfId-17589]##@Resource ORB orb;

[#50581511_pgfId-17590]## 

[#50581511_pgfId-17591]##public void method(...) \{

[#50581511_pgfId-17592]## ...

[#50581511_pgfId-17593]## // Get the POA to use when creating object
references.

[#50581511_pgfId-17594]## POA rootPOA =
(POA)orb.resolve_initial_references("RootPOA");

[#50581511_pgfId-17600]## ...

======= [#50581511_pgfId-17601]##}

[#50581511_pgfId-17603]##The following example illustrates how an
application component acquires and uses an _ORB_ object using a JNDI
lookup.

======= [#50581511_pgfId-17604]##public void method(...) \{

[#50581511_pgfId-17605]## ...

[#50581511_pgfId-17670]## // Obtain the default initial JNDI context.

[#50581511_pgfId-17606]## Context initCtx = new InitialContext();

[#50581511_pgfId-17607]## 

[#50581511_pgfId-17608]## // Look up the ORB object.

[#50581511_pgfId-17609]## ORB orb =
(ORB)initCtx.lookup("java:comp/ORB");

[#50581511_pgfId-17611]## 

[#50581511_pgfId-17644]## // Get the POA to use when creating object
references.

[#50581511_pgfId-17645]## POA rootPOA =
(POA)orb.resolve_initial_references("RootPOA");

[#50581511_pgfId-17619]## ...

======= [#50581511_pgfId-17620]##}

[#50581511_pgfId-17565]##An _ORB_ object reference may also be declared
in a deployment descriptor in the same way as a resource manager
connection factory reference. Such a deployment descriptor entry may be
used to specify injection of an _ORB_ object.

[#50581511_pgfId-17576]##The _ORB_ instance available under the JNDI
name _java:comp/ORB_ may always be a shared instance. By default, the
_ORB_ instance injected into a component or declared via a deployment
descriptor entry may also be a shared instance. However, the application
may set the _shareable_ element of the _Resource_ annotation to _false_
, or may set the _res-sharing-scope_ element in the deployment
descriptor to _Unshareable_ , to request a non-shared _ORB_ instance.

[#50581511_pgfId-997185]##The requirements in this section only apply to
Java EE products that include support for interoperability using CORBA.

======= [#50581511_pgfId-15792]##Application Component Provider’s Responsibilities

[#50581511_pgfId-15793]##The Application Component Provider is
responsible for requesting injection of the _ORB_ object using the
Resource annotation, or using the defined name to look up the _ORB_
object. If the _shareable_ element of the _Resource_ annotation is set
to _false_ , the ORB object injected will not be the shared instance
used by other components in the application but instead will be a
private ORB instance used only by this component.

======= [#50581511_pgfId-15803]##Java EE Product Provider’s Responsibilities

[#50581511_pgfId-15807]##The Java EE Product Provider is responsible for
providing an appropriate _ORB_ object as required by this specification.

==== [#50581511_pgfId-18915]##[#50581511_84517]##Persistence Unit References

[#50581511_pgfId-18916]##This section describes the metadata annotations
and deployment descriptor elements that allow the application component
code to refer to the entity manager factory for a persistence unit using
a logical name called a _persistence unit reference_ . Persistence unit
references are special entries in the application component’s
environment. The Deployer binds the persistence unit references to
entity manager factories that are configured in accordance with the
_persistence.xml_ specification for the persistence unit, as described
in the Java Persistence specification.

[#50581511_pgfId-997190]##The requirements in this section only apply to
Java EE products that include support for the Java Persistence API.

======= [#50581511_pgfId-18920]##Application Component Provider’s Responsibilities

[#50581511_pgfId-18921]##This subsection describes the Application
Component Provider’s view of locating the entity manager factory for a
persistence unit and defines his or her responsibilities. The first
subsection describes annotations for injecting references to an entity
manager factory for a persistence unit; the second describes the API for
accessing an entity manager factory using a persistence unit reference;
and the third describes syntax for declaring persistence unit references
in a deployment descriptor.

======= [#50581511_pgfId-18922]##Injection of Persistence Unit References

[#50581511_pgfId-18923]##A field or a method of an application component
may be annotated with the _PersistenceUnit_ annotation. The _name_
element specifies the name under which the entity manager factory for
the referenced persistence unit may be located in the JNDI naming
context. The optional _unitName_ element specifies the name of the
persistence unit as declared in the _persistence.xml_ file that defines
the persistence unit.

[#50581511_pgfId-18927]##The following code example illustrates how an
application component uses annotations to declare persistence unit
references.

======= [#50581511_pgfId-18928]##@PersistenceUnit

======= [#50581511_pgfId-18929]##EntityManagerFactory emf;

======= [#50581511_pgfId-18931]##@PersistenceUnit(unitName="InventoryManagement")

======= [#50581511_pgfId-18932]##EntityManagerFactory inventoryEMF;

======= [#50581511_pgfId-18933]##Programming Interfaces for Persistence Unit References

[#50581511_pgfId-18935]##[#50581511_marker-18934]##The Application
Component Provider must use persistence unit references to obtain
references to entity manager factories as follows.

* [#50581511_pgfId-18936]##Assign an entry in the application
component’s environment to the persistence unit reference. (See
subsection link:JavaEE_Platform_Spec.htm#50581511_19988[See Declaration
of Persistence Unit References in Deployment Descriptor] for information
on how persistence unit references are declared in the deployment
descriptor.) It is recommended that the Application Component Provider
organize all persistence unit references in the
_java:comp/env/persistence_ subcontext of the component’s environment.
* [#50581511_pgfId-18941]##Lookup the entity manager factory for the
persistence unit in the application component’s environment using JNDI.
* [#50581511_pgfId-18942]##Invoke the appropriate method on the entity
manager factory to obtain an entity manager instance.

[#50581511_pgfId-18943]##The following code sample illustrates obtaining
an entity manager factory.

======= [#50581511_pgfId-18966]##@PersistenceUnit(name="persistence/InventoryAppDB")

[#50581511_pgfId-18969]##@Stateless

[#50581511_pgfId-18970]##public class InventoryManagerBean implements
InventoryManager \{

[#50581511_pgfId-18971]## EJBContext ejbContext;

[#50581511_pgfId-18972]## ...

[#50581511_pgfId-18973]## public void updateInventory(...) \{

[#50581511_pgfId-18974]## ...

[#50581511_pgfId-18975]## // obtain the initial JNDI context

[#50581511_pgfId-18976]## Context initCtx = new InitialContext();

[#50581511_pgfId-18977]##

[#50581511_pgfId-18978]## // perform JNDI lookup to obtain entity
manager factory

[#50581511_pgfId-18980]## EntityManagerFactory = (EntityManagerFactory)

[#50581511_pgfId-18982]## initCtx.lookup(

[#50581511_pgfId-19375]## "java:comp/env/persistence/InventoryAppDB");

[#50581511_pgfId-18983]## 

[#50581511_pgfId-18984]## // use factory to obtain application-managed
entity manager

[#50581511_pgfId-18985]## EntityManager em = emf.createEntityManager();

[#50581511_pgfId-18986]## ...

[#50581511_pgfId-999680]## }

======= [#50581511_pgfId-999681]##}

======= [#50581511_pgfId-18991]##[#50581511_19988]##Declaration of Persistence Unit References in Deployment Descriptor

[#50581511_pgfId-18992]##Although a persistence unit reference is an
entry in the application component’s environment, the Application
Component Provider must not use an _env-entry_
[#50581511_marker-18993]## element to declare it.

[#50581511_pgfId-18994]##Instead, if metadata annotations are not used,
the Application Component Provider must declare all the persistence unit
references in the deployment descriptor using the _persistence-unit-ref_
elements. This allows the Application Assembler or Deployer to discover
all the persistence unit references used by an application component.
Deployment descriptor entries may also be used to specify injection of a
persistence unit reference into an application component.

[#50581511_pgfId-18996]##[#50581511_marker-18995]##Each
_persistence-unit-ref_ element describes a single entity manager factory
reference for the persistence unit. The _persistence-unit-ref_ element
consists of the optional _description_ and _persistence-unit-name_
elements, and the mandatory _persistence-unit-ref-name_ element.

[#50581511_pgfId-18998]##The _persistence-unit-ref-name_ element
contains the name of the environment entry used in the application
component’s code. The name of the environment entry is relative to the
_java:comp/env_ context (e.g., the name should be
_persistence/InventoryAppDB_ rather than
_java:comp/env/persistence/InventoryAppDB_ ). The
_persistence-unit-name_ element is the name of the persistence unit, as
specified in the _persistence.xml_ file for the persistence unit.

[#50581511_pgfId-18999]##The following example is the declaration of a
persistence unit reference used by the _InventoryManager_ enterprise
bean illustrated in the previous subsection.

======= [#50581511_pgfId-19008]## ...

[#50581511_pgfId-19009]## <persistence-unit-ref>

[#50581511_pgfId-19010]## <description>

[#50581511_pgfId-19011]## Persistence unit for the inventory management

[#50581511_pgfId-19012]## application.

[#50581511_pgfId-19013]## </description>

[#50581511_pgfId-19014]## <persistence-unit-ref-name>

[#50581511_pgfId-19015]## persistence/InventoryAppDB

[#50581511_pgfId-19016]## </persistence-unit-ref-name>

[#50581511_pgfId-19017]## <persistence-unit-name>

[#50581511_pgfId-19018]## InventoryManagement

[#50581511_pgfId-19019]## </persistence-unit-name>

[#50581511_pgfId-19386]## </persistence-unit-ref>

======= [#50581511_pgfId-19387]## ...

======= [#50581511_pgfId-19392]##[#50581511_88636]## Application Assembler’s Responsibilities

[#50581511_pgfId-19027]##The Application Assembler can use the
_persistence-unit-name_ element in the deployment descriptor to
disambiguate a reference to a persistence unit.The Application Assembler
(or Application Component Provider) may use the following syntax in the
_persistence-unit-name_ element of the referencing application component
to avoid the need to rename persistence units to have unique names
within a Java EE application. The Application Assembler specifies the
path name of the root of the _persistence.xml_ file for the referenced
persistence unit and appends the name of the persistence unit separated
from the path name by _#_ . The path name is relative to the referencing
application component jar file. In this manner, multiple persistence
units with the same persistence unit name may be uniquely identified
when the Application Assembler cannot change persistence unit names.

[#50581511_pgfId-19028]##For example,

======= [#50581511_pgfId-19037]## ...

[#50581511_pgfId-19038]## <persistence-unit-ref>

[#50581511_pgfId-19039]## <description>

[#50581511_pgfId-19040]## Persistence unit for the inventory management

[#50581511_pgfId-19041]## application.

[#50581511_pgfId-19042]## </description>

[#50581511_pgfId-19043]## <persistence-unit-ref-name>

[#50581511_pgfId-19044]## persistence/InventoryAppDB

[#50581511_pgfId-19045]## </persistence-unit-ref-name>

[#50581511_pgfId-19046]## <persistence-unit-name>

[#50581511_pgfId-19047]## ../lib/inventory.jar#InventoryManagement

[#50581511_pgfId-19048]## </persistence-unit-name>

[#50581511_pgfId-19049]## </persistence-unit-ref>

======= [#50581511_pgfId-19050]## ...

[#50581511_pgfId-19055]##The Application Assembler uses the
_persistence-unit-name_ element to link the persistence unit name
_InventoryManagement_ declared in the _InventoryManagerBean_ to the
persistence unit named _InventoryManagement_ defined in _inventory.jar_
.

[#50581511_pgfId-996877]##The following rules apply to how a deployment
descriptor entry may override a _PersistenceUnit_ annotation:

* [#50581511_pgfId-996878]##The relevant deployment descriptor entry is
located based on the JNDI name used with the annotation (either
defaulted or provided explicitly).
* [#50581511_pgfId-996880]##The _persistence-unit-name_ overrides the
_unitName_ element of the annotation. The Application Assembler or
Deployer should exercise caution in changing this value, if specified,
as doing so is likely to break the application.
* [#50581511_pgfId-999841]##The injection target, if specified, must
name exactly the annotated field or property method.

======= [#50581511_pgfId-19056]##Deployer’s Responsibility

[#50581511_pgfId-19058]##The Deployer uses deployment tools to
[#50581511_marker-19057]##bind a persistence unit reference to the
actual entity manager factory configured for the persistence unit in the
target operational environment.

[#50581511_pgfId-19059]##The Deployer must perform the following tasks
for each persistence unit reference declared in the metadata annotations
or deployment descriptor:

* [#50581511_pgfId-19060]##Bind the persistence unit reference to an
entity manager factory configured for the persistence unit that exists
in the operational environment. The Deployer may use, for example, the
JNDI _LinkRef_ mechanism to create a symbolic link to the actual JNDI
name of the entity manager factory.
* [#50581511_pgfId-996885]##If the persistence unit name is specified,
the Deployer should bind the persistence unit reference to the entity
manager factory for the persistence unit specified as the target.
* [#50581511_pgfId-19061]##Provide any additional configuration
information that the entity manager factory needs for managing the
persistence unit, as described in the Java Persistence specification.

======= [#50581511_pgfId-19065]##Java EE Product Provider’s Responsibility

[#50581511_pgfId-19067]##The Java EE Product Provider is responsible for
the following:

* [#50581511_pgfId-19069]##Provide the
[#50581511_marker-19068]##deployment tools that allow the Deployer to
perform the tasks described in the previous subsection.
* [#50581511_pgfId-19070]##Provide the implementation of the entity
manager factory classes for the persistence units that are configured
with the container. The implementation of the entity manager factory
classes may be provided by the container directly or by the container in
conjunction with a third-party persistence provider, as described in the
Java Persistence specification.

======= [#50581511_pgfId-19074]##System Administrator’s Responsibility

[#50581511_pgfId-19076]##The [#50581511_marker-19075]##System
Administrator is typically responsible for the following:

* [#50581511_pgfId-19077]##Add, remove, and configure entity manager
factories in the server environment.

[#50581511_pgfId-19078]##In some scenarios, these tasks can be performed
by the Deployer.

==== [#50581511_pgfId-19080]##[#50581511_48657]##Persistence Context References

[#50581511_pgfId-19081]##This section describes the metadata annotations
and deployment descriptor elements that allow the application component
code to refer to a container-managed entity manager of a specified
persistence context type using a logical name called a _persistence
context reference_ . Persistence context references are special entries
in the application component’s environment. The Deployer binds the
persistence context references to container-managed entity managers for
persistence contexts of the specified type and configured in accordance
with their persistence unit, as described in the Java Persistence
specification.

[#50581511_pgfId-997195]##The requirements in this section only apply to
Java EE products that include support for the Java Persistence API.

======= [#50581511_pgfId-19085]##Application Component Provider’s Responsibilities

[#50581511_pgfId-19086]##This subsection describes the Application
Component Provider’s view of locating container-managed entity managers
and defines his or her responsibilities. The first subsection describes
annotations for injecting references to container-managed entity
managers; the second describes the API for accessing references to
container-managed entity managers; and the third describes syntax for
declaring these references in a deployment descriptor.

======= [#50581511_pgfId-19087]##Injection of Persistence Context References

[#50581511_pgfId-19088]##A field or a method of an application component
may be annotated with the _PersistenceContext_ annotation. The _name_
element specifies the name under which a container-managed entity
manager for the referenced persistence unit may be located in the JNDI
naming context. The optional _unitName_ element specifies the name of
the persistence unit as declared in the _persistence.xml_ file that
defines the persistence unit. The optional _type_ element specifies
whether a transaction-scoped or extended persistence context is to be
used. If the type is not specified, a transaction-scoped persistence
context will be used. References to container-managed entity managers
with extended persistence contexts can only be injected into stateful
session beans. The optional _synchronization_ element specifies whether
the persistence context is always automatically synchronized with the
current transaction or whether it must be explicitly joined to the
transaction. If the _synchronization_ element is not specified, the
persistence context will be automatically synchronized. The optional
_properties_ element specifies configuration properties to be passed to
the persistence provider when the entity manager is created.

[#50581511_pgfId-19092]##The following code example illustrates how an
application component uses annotations to declare persistence context
references.

======= [#50581511_pgfId-19093]##@PersistenceContext(type=EXTENDED)

======= [#50581511_pgfId-19094]##EntityManager em;

======= [#50581511_pgfId-19098]##Programming Interfaces for Persistence Context References

[#50581511_pgfId-19100]##[#50581511_marker-19099]##The Application
Component Provider may use a persistence context reference to obtain a
reference to a container-managed entity manager configured for a
persistence unit as follows:

* [#50581511_pgfId-19101]##Assign an entry in the application
component’s environment to the persistence context reference. (See
subsection link:JavaEE_Platform_Spec.htm#50581511_37865[See Declaration
of Persistence Context References in Deployment Descriptor] for
information on how persistence context references are declared in the
deployment descriptor.) It is recommended that the Application Component
Provider organize all persistence context references in the
_java:comp/env/persistence_ subcontext of the component’s environment.
* [#50581511_pgfId-19106]##Lookup the container-managed entity manager
for the persistence unit in the application component’s environment
using the JNDI API.

[#50581511_pgfId-19107]##The following code sample illustrates obtaining
an entity manager for a persistence context.

======= [#50581511_pgfId-19126]##@PersistenceContext(name="persistence/InventoryAppMgr")

[#50581511_pgfId-19129]##@Stateless

[#50581511_pgfId-19130]##public class InventoryManagerBean implements
InventoryManager \{

[#50581511_pgfId-19132]## 

[#50581511_pgfId-19133]## public void updateInventory(...) \{

[#50581511_pgfId-19134]## ...

[#50581511_pgfId-19135]## 

[#50581511_pgfId-19136]## // obtain the initial JNDI context

[#50581511_pgfId-19137]## Context initCtx = new InitialContext();

[#50581511_pgfId-19138]##

[#50581511_pgfId-19466]## // JNDI lookup to obtain container-managed
entity manager

[#50581511_pgfId-19467]## EntityManager = (EntityManager)

[#50581511_pgfId-19459]## initCtx.lookup(

[#50581511_pgfId-19418]## "java:comp/env/persistence/InventoryAppMgr");

[#50581511_pgfId-19143]## ...

[#50581511_pgfId-19545]## }

======= [#50581511_pgfId-19546]##}

======= [#50581511_pgfId-19549]##[#50581511_37865]##Declaration of Persistence Context References in Deployment Descriptor

[#50581511_pgfId-19149]##Although a persistence context reference is an
entry in the application component’s environment, the Application
Component Provider must not use an _env-entry_
[#50581511_marker-19150]## element to declare it.

[#50581511_pgfId-19151]##Instead, if metadata annotations are not used,
the Application Component Provider must declare all the persistence
context references in the deployment descriptor using the
_persistence-context-ref_ elements. This allows the Application
Assembler or Deployer to discover all the persistence context references
used by an application component. Deployment descriptor entries may also
be used to specify injection of a persistence context reference into a
bean.

[#50581511_pgfId-19153]##[#50581511_marker-19152]##Each
_persistence-context-ref_ element describes a single container-managed
entity manager reference. The _persistence-context-ref_ element consists
of the optional _description_ , _persistence-unit-name_ ,
_persistence-context-type_ , _persistence-context-synchronization_ , and
_persistence-property_ elements, and the mandatory
_persistence-context-ref-name_ element.

[#50581511_pgfId-19155]##The _persistence-context-ref-name_ element
contains the name of the environment entry used in the application
component’s code. The name of the environment entry is relative to the
_java:comp/env_ context (e.g., the name should be
_persistence/InventoryAppMgr_ rather than
_java:comp/env/persistence/InventoryAppMgr_ ). The
_persistence-unit-name_ element is the name of the persistence unit, as
specified in the _persistence.xml_ file for the persistence unit. The
_persistence-context-type_ element specifies whether a
transaction-scoped or extended persistence context is to be used. Its
value is either _Transaction_ or _Extended_ . If the persistence context
type is not specified, a transaction-scoped persistence context will be
used. The optional _persistence-context-synchronization_ element
specifies whether the persistence context is automatically synchronized
with the current transaction. Its value is either _Synchronized_ or
_Unsynchronized_ . If the persistence context synchronization is not
specified, the persistence context will be automatically synchronized.
The optional _persistence-property_ elements specify configuration
properties that are passed to the persistence provider when the entity
manager is created.

[#50581511_pgfId-19156]##The following example is the declaration of a
persistence context reference used by the _InventoryManager_ enterprise
bean illustrated in the previous subsection.

======= [#50581511_pgfId-19165]## ...

[#50581511_pgfId-19166]## <persistence-context-ref>

[#50581511_pgfId-19167]## <description>

[#50581511_pgfId-19168]## Persistence context for the inventory
management

[#50581511_pgfId-19169]## application.

[#50581511_pgfId-19170]## </description>

[#50581511_pgfId-19171]## <persistence-context-ref-name>

[#50581511_pgfId-19172]## persistence/InventoryAppDB

[#50581511_pgfId-19173]## </persistence-context-ref-name>

[#50581511_pgfId-19174]## <persistence-unit-name>

[#50581511_pgfId-19175]## InventoryManagement

[#50581511_pgfId-19176]## </persistence-unit-name>

[#50581511_pgfId-19177]## </persistence-context-ref>

======= [#50581511_pgfId-19178]## ...

======= [#50581511_pgfId-19183]## Application Assembler’s Responsibilities

[#50581511_pgfId-19184]##The Application Assembler can use the
_persistence-unit-name_ element in the deployment descriptor to specify
a reference to a persistence unit using the syntax described in
link:JavaEE_Platform_Spec.htm#50581511_88636[See Application Assembler’s
Responsibilities].” In this manner, multiple persistence units with the
same persistence unit name may be uniquely identified when the
persistence unit names cannot be changed.

[#50581511_pgfId-19185]##For example,

======= [#50581511_pgfId-19195]## ...

[#50581511_pgfId-19196]## <persistence-context-ref>

[#50581511_pgfId-19197]## <description>

[#50581511_pgfId-19198]## Persistence context for the inventory
management

[#50581511_pgfId-19199]## application.

[#50581511_pgfId-19200]## </description>

[#50581511_pgfId-19201]## <persistence-context-ref-name>

[#50581511_pgfId-19202]## persistence/InventoryAppDB

[#50581511_pgfId-19203]## </persistence-context-ref-name>

[#50581511_pgfId-19204]## <persistence-unit-name>

[#50581511_pgfId-19205]## ../lib/inventory.jar#InventoryManagement

[#50581511_pgfId-19206]## </persistence-unit-name>

[#50581511_pgfId-19207]## </persistence-context-ref>

======= [#50581511_pgfId-19208]## ...

[#50581511_pgfId-19213]##The Application Assembler uses the
_persistence-unit-name_ element to link the persistence unit name
_InventoryManagement_ declared in the _InventoryManagerBean_ to the
persistence unit named _InventoryManagement_ defined in _inventory.jar_
.

[#50581511_pgfId-996944]##The following rules apply to how a deployment
descriptor entry may override a _PersistenceContext_ annotation:

* [#50581511_pgfId-996945]##The relevant deployment descriptor entry is
located based on the JNDI name used with the annotation (either
defaulted or provided explicitly).
* [#50581511_pgfId-996946]##The _persistence-unit-name_ overrides the
_unitName_ element of the annotation. The Application Assembler or
Deployer should exercise caution in changing this value, if specified,
as doing so is likely to break the application.
* [#50581511_pgfId-996947]##The _persistence-context-type_ , if
specified, overrides the _type_ element of the annotation. In general,
the Application Assembler or Deployer should never change the value of
this element, as doing so is likely to break the application.
* [#50581511_pgfId-1002299]##The _persistence-context-synchronization_ ,
if specified, overrides the _synchronization_ element of the annotation.
In general, the Application Assembler or Deployer should never change
the value of this element, as doing so is likely to break the
application.
* [#50581511_pgfId-996948]##Any _persistence-property_ elements are
added to those specified by the _PersistenceContext_ annotation. If the
name of a specified property is the same as one specified by the
_PersistenceContext_ annotation, the value specified in the annotation
is overridden.
* [#50581511_pgfId-996949]##The injection target, if specified, must
name exactly the annotated field or property method.

======= [#50581511_pgfId-19214]##Deployer’s Responsibility

[#50581511_pgfId-19216]##The Deployer uses deployment tools to
[#50581511_marker-19215]##bind a persistence context reference to the
container-managed entity manager for the persistence context of the
specified type and configured for the persistence unit in the target
operational environment.

[#50581511_pgfId-19217]##The Deployer must perform the following tasks
for each persistence context reference declared in the metadata
annotations or deployment descriptor:

* [#50581511_pgfId-19218]##Bind the persistence context reference to a
container-managed entity manager for a persistence context of the
specified type and configured for the persistence unit as specified in
the _persistence.xml_ file for the persistence unit that exists in the
operational environment. The Deployer may use, for example, the JNDI
_LinkRef_ mechanism to create a symbolic link to the actual JNDI name of
the entity manager.
* [#50581511_pgfId-996954]##If the persistence unit name is specified,
the Deployer should bind the persistence context reference to an entity
manager for the persistence unit specified as the target.
* [#50581511_pgfId-19219]##Provide any additional configuration
information that the entity manager factory needs for creating such an
entity manager and for managing the persistence unit, as described in
the Java Persistence specification.

======= [#50581511_pgfId-19223]##Java EE Product Provider’s Responsibility

[#50581511_pgfId-19225]##The [#50581511_marker-19224]##Java EE Product
Provider is responsible for the following:

* [#50581511_pgfId-19227]##Provide the
[#50581511_marker-19226]##deployment tools that allow the Deployer to
perform the tasks described in the previous subsection.
* [#50581511_pgfId-19228]##Provide the implementation of the entity
manager classes for the persistence units that are configured with the
container. This implementation may be provided by the container
directory or by the container in conjunction with a third-party
persistence provider, as described in the Java Persistence
specification.

======= [#50581511_pgfId-19232]##System Administrator’s Responsibility

[#50581511_pgfId-19234]##The [#50581511_marker-19233]##System
Administrator is typically responsible for the following:

* [#50581511_pgfId-19235]##Add, remove, and configure entity manager
factories in the server environment.

[#50581511_pgfId-18913]##In some scenarios, these tasks can be performed
by the Deployer.

==== [#50581511_pgfId-997557]##[#50581511_99957]##Application Name and Module Name References

[#50581511_pgfId-997615]##A component may access the name of the current
application using the pre-defined JNDI name _java:app/AppName_ . A
component may access the name of the current module using the
pre-defined JNDI name _java:module/ModuleName_ . Both of these names are
represented by _String_ objects.

======= [#50581511_pgfId-997610]##Application Component Provider’s Responsibilities

[#50581511_pgfId-997660]##The Application Component Provider is
responsible for requesting injection of the application name or module
name using a _Resource_ annotation on a _String_ method or field, or
using the defined name to look up the application name or module name.

======= [#50581511_pgfId-997664]##Java EE Product Provider’s Responsibilities

[#50581511_pgfId-1005967]##The Java EE Product Provider is responsible
for providing the correct application name and module name _String_
objects as required by this specification.

==== [#50581511_pgfId-1006014]##[#50581511_62617]##Application Client Container Property

[#50581511_pgfId-1006015]##An application may determine whether it is
executing in a Java EE application client container by using the
pre-defined JNDI name _java:comp/InAppClientContainer_ . This property
is represented by a _Boolean_ object. If the application is running in a
Java EE application client container, the value of this property is
true. If the application is running in a Java EE web or EJB container,
the value of this property is false.

======= [#50581511_pgfId-1006016]##Application Component Provider’s Responsibilities

[#50581511_pgfId-1006017]##The Application Component Provider is
responsible for requesting injection of the application client container
property using a _Resource_ annotation on a _Boolean_ or _boolean_
method or field, or using the defined name to look up the application
client container property.

======= [#50581511_pgfId-1006021]##Java EE Product Provider’s Responsibilities

[#50581511_pgfId-1006025]##The Java EE Product Provider is responsible
for providing the correct application client container property as
required by this specification.

==== [#50581511_pgfId-1005970]##[#50581511_72918]##Validator and Validator Factory References

[#50581511_pgfId-18896]##This section describes the metadata annotations
and deployment descriptor entries that allow an application to obtain
instances of the Bean Validation _Validator_ and _ValidatorFactory_
types.

[#50581511_pgfId-997706]##Applications that need to use those interfaces
can find appropriate objects by looking up the name
_java:comp/Validator_ for _Validator_ and _java:comp/ValidatorFactory_
for _ValidatorFactory_ , or by requesting the injection of an object of
the appropriate type via the _Resource_ annotation. The
_authenticationType_ and _shareable_ elements of the _Resource_
annotation must not be specified.

======= [#50581511_pgfId-997757]##@Resource ValidatorFactory validatorFactory;

[#50581511_pgfId-997993]## 

[#50581511_pgfId-997994]##@Resource Validator validator;

[#50581511_pgfId-997754]## 

[#50581511_pgfId-997755]##For Validator objects, the default validation
context is used. This means that all such Validators will be equivalent
to those obtained by first acquiring a ValidatorFactory and then
invoking the getValidator method on it with no arguments.

[#50581511_pgfId-997806]##In other words, the following two code
snippets are equivalent:

[#50581511_pgfId-997809]## 

[#50581511_pgfId-997812]##// obtaining a Validator directly

[#50581511_pgfId-997868]##Context initCtx = new InitialContext();

[#50581511_pgfId-997815]##Validator validator =
(Validator)initCtx.lookup(

[#50581511_pgfId-997875]## "java:comp/Validator");

[#50581511_pgfId-997862]## 

[#50581511_pgfId-997839]##// obtaining a Validator from a
ValidatorFactory

[#50581511_pgfId-997876]##Context initCtx = new InitialContext();

[#50581511_pgfId-997840]##Validator validator =

[#50581511_pgfId-997858]## ((ValidatorFactory) initCtx.lookup(

[#50581511_pgfId-997872]## "java:comp/ValidatorFactory"))

[#50581511_pgfId-997855]## .getValidator();

[#50581511_pgfId-997803]## 

[#50581511_pgfId-997805]##A _Validator_ or _ValidatorFactory_ object
reference may also be declared in a deployment descriptor in the same
way as a resource environment reference.

[#50581511_pgfId-998639]##In order to customize the returned
_ValidatorFactory_ , an EJB, web or application client module may
specify a Bean Validation XML deployment descriptor, as described in the
Bean Validation specification.

[#50581511_pgfId-998663]##A validation deployment descriptor only
affects _ValidatorFactory_ instances in that module.

[#50581511_pgfId-998712]##There is no per-application validation
deployment descriptor.

======= [#50581511_pgfId-997914]##Application Component Provider’s Responsibilities

[#50581511_pgfId-997915]##The Application Component Provider is
responsible for requesting injection of a _Validator_ or of a
_ValidatorFactory_ using a _Resource_ annotation, or using the defined
names to look up a _Validator_ or _ValidatorFactory_ instance.

[#50581511_pgfId-998693]##The Application Component Provider may
customize the _ValidatorFactory_ and (indirectly) _Validator_ instances
by including a Bean Validation deployment descriptor inside a specific
module of the application.

======= [#50581511_pgfId-997919]##[#50581511_27277]##Java EE Product Provider’s Responsibilities

[#50581511_pgfId-1007935]##The Java EE Product Provider must make a
default _ValidatorFactory_ available at _java:comp/ValidatorFactory_ .
The default _ValidatorFactory_ available at _java:comp/ValidatorFactory_
must support use of CDI if CDI is enabled for the module. In particular,
all of the classes specified by the
_javax.validation.BootstrapConfiguration_ interface must be created as
non-contextual objects using CDI, as described in
link:JavaEE_Platform_Spec.htm#50581511_62440[See Support for Dependency
Injection]”. These objects must be used to configure the default
_ValidatorFactory_ available at _java:comp/ValidatorFactory_ in
accordance with the bootstrapping APIs described by the Bean Validation
specification.

[#50581511_pgfId-1007937]##The default _ValidatorFactory_ is a single
instance per module; each lookup of _java:comp/ValidatorFactory_ returns
the same instance.

[#50581511_pgfId-997912]##The default _Validator_ is created by the
default _ValidatoryFactory_ using the _getValidator_ method. Each lookup
of _java:comp/Validator_ returns a new _Validator_ instance.

==== [#50581511_pgfId-998088]##[#50581511_72240]##Resource Definition and Configuration

[#50581511_pgfId-1002519]##In addition to referencing resources as
defined in this chapter, an application may specify the definition and
configuration of resources that it requires in its operational
environment.[#50581511_30869]##

[#50581511_pgfId-1002518]##Each application has a set of “physical”
resources and services that it depends on (database storage, queueing,
mail, etc.) and which need to be made available to it when it is
deployed. Such resources may be scoped to the application instance or
may be shareable. An application may define a dependency upon such
resources in its environment by means of resource definition metadata.

[#50581511_pgfId-1002454]##The specification of resource definition
metadata provides information that can be used at the application’s
deployment to provision and configure the required resource. Further,
resource definitions allow an application to be deployed into a Java EE
environment with more minimal administrative configuration.

[#50581511_pgfId-1002465]##Resources may be defined in any of the JNDI
namespaces described in link:JavaEE_Platform_Spec.htm#50581511_61227[See
Application Component Environment Namespaces]”. For example, a resource
may be defined:

======= [#50581511_pgfId-1002434]##in the _java:comp_ namespace, for use by a single component;

* [#50581511_pgfId-1002435]##in the _java:module_ namespace, for use by
all components in a module;
* [#50581511_pgfId-1002436]##in the _java:app_ namespace, for use by all
components in an application;
* [#50581511_pgfId-1002437]##in the _java:global_ namespace, for use by
all applications.

[#50581511_pgfId-1002663]##The following annotations (and corresponding
XML deployment descriptor elements) define resources:
_DataSourceDefinition_ , _JMSConnectionFactoryDefinition_ ,
_JMSDestinationDefinition_ , _MailSessionDefinition_ ,
_ConnectionFactoryDefinition_ , and _AdministeredObjectDefinition_ .

[#50581511_pgfId-1002664]##Once defined, a resource may be referenced by
a component using the _lookup_ element of the _Resource_ annotation or
the _lookup-name_ element of the _resource-ref_ deployment descriptor
element in order to bind the logical reference to the resource as
referenced in the application code to the resource defined in the
environment. __

[#50581511_pgfId-1002695]##The specificity of the resource definition
elements as provided by the Application Component Provider may vary
according to the needs of the application. For example:

* [#50581511_pgfId-1002703]##An application may require an instance of a
resource, but its needs may be general in that while it requires a
resource with certain properties, it does not require a particular
instance of the resource. It may expect the resource to be provisioned
and configured for it by the Deployer or System Administrator.
* [#50581511_pgfId-1002704]##An application may require a particular
instance of a resource (with specific configuration properties) that
already exists. For example, the resource may previously have been
created and configured by the Deployer or System Administrator.

[#50581511_pgfId-1002714]##The values specified for required annotation
elements (and corresponding XML deployment descriptor elements) must be
observed when the application is deployed. Changing a value that has
been specified for some optional elements (e.g., _transactional_ ) may
cause the application to work incorrectly. Changing a value that has
been specified for an optional element related to quality of service
(e.g., pool size, idle time, etc.) may affect the performance of the
application.

[#50581511_pgfId-1003597]##The following default values used in the
_DataSourceDefinition_ , _JMSConnectionFactoryDefinition_ ,
_JMSDestinationDefinition_ , _MailSessionDefinition_ , and
_ConnectionFactoryDefinition_ annotations indicate that an element value
is optional and has not been set:

======= [#50581511_pgfId-1002365]##integer-valued elements: _-1_

* [#50581511_pgfId-1002578]##string-valued elements: _“”_
* [#50581511_pgfId-1002579]##array-valued elements: _\{}_

======= [#50581511_pgfId-1003712]##Guidelines

[#50581511_pgfId-1003601]##The following guidelines should be observed
with regard to the specification of values for resource definition
elements.

* [#50581511_pgfId-1003605]##In general, the Application Component
Provider or Assembler should specify values for elements which, if
changed, would cause the application to break—for example, JNDI name,
isolation level. If multiple resource definitions are specified for a
given resource, they must be consistent.
* [#50581511_pgfId-1003731]##The Java EE Product Provider may choose
suitable server-specific default values for optional elements for which
values have not been specified.

======= [#50581511_pgfId-1003609]##[#50581511_72429]##Requirements Common to All Resource Definition Types

[#50581511_pgfId-1003610]##The following requirements apply to the
resource definitions described in Sections
link:JavaEE_Platform_Spec.htm#50581511_11623[See DataSource Resource
Definition] through link:JavaEE_Platform_Spec.htm#50581511_85453[See
Connector Administered Object Definition].

[#50581511_pgfId-1003743]##When an Application Component Provider or
Application Assembler specifies connectivity information to a “physical”
resource through a resource definition annotation or deployment
descriptor element, it is assumed that the physical resource exists. The
automatic provisioning of resources may be supported by an
implementation of this specification, but support for this functionality
is not required. If automatic provisioning of resources is not
supported, it is the Deployer’s responsibility (possibly in conjunction
with the System Administrator) to insure that the physical resource is
provisioned for use by the application.

======= [#50581511_pgfId-1003630]##JNDI Name

[#50581511_pgfId-1003611]##The Deployer and Java EE Product Provider
must not alter the specified JNDI name. The requested resource must be
made available in JNDI under the specified name.

======= [#50581511_pgfId-1003634]##Resource Address

[#50581511_pgfId-1003612]##If the Application Component Provider or
Application Assembler has specified an address for a resource (server
name, port, etc.), a resource at the specified location should already
exist. If it does not, and if the automatic provisioning of resources is
not supported, it is the Deployer’s responsibility (possibly in
conjunction with the System Administrator) to insure that the resource
is provisioned for use by the applicationlink:#pgfId-1003842[13].

[#50581511_pgfId-1004129]##If the resource has not been otherwise
provisioned and if automatic provisioning of resources is supported, the
Java EE Product Provider is responsible for provisioning the resource.
If the requested resource cannot be made available or created, the
application must fail to deploy.

======= [#50581511_pgfId-1003640]##Quality of Service Elements

[#50581511_pgfId-1003620]##Quality of service elements may be altered by
the Deployer. The Java EE Product Provider is permitted to impose
restrictions upon quality of service elements in accordance with its
implementation limits and quality of service guarantees. If quality of
service values that have been specified do not meet these restrictions,
the Product Provider must not reject the deployment (but must instead
use appropriate values).

======= [#50581511_pgfId-1003654]##Properties

[#50581511_pgfId-1003621]##All resource definition annotations and XML
elements support the use of property elements (elements named “
_properties_ ” or “ _property_ ”). A Java EE Product Provider is
permitted to reject a deployment if a property that it recognizes has a
value that it does not support. A Java EE Product Provider must not
reject a deployment on the basis of a property that it does not
recognize.

======= [#50581511_pgfId-1002353]##[#50581511_11623]##DataSource Resource Definition

[#50581511_pgfId-998096]##An application may define a _DataSource_
resource. A _DataSource_ resource is used to access a database using a
JDBC driver.

[#50581511_pgfId-998129]##The _DataSource_ resource may be defined in
any of the JNDI namespaces described in
link:JavaEE_Platform_Spec.htm#50581511_61227[See Application Component
Environment Namespaces]”.

[#50581511_pgfId-1003132]##A _DataSource_ resource may be defined in a
web module, EJB module, application client module, or application
deployment descriptor using the _data-source_ element.

[#50581511_pgfId-1006282]##For example:

[#50581511_pgfId-1006283]## 

[#50581511_pgfId-1006284]##<data-source>

[#50581511_pgfId-998433]## <description>Sample DataSource
definition</description>

[#50581511_pgfId-998434]## <name> _java:app/MyDataSource_ </name>

[#50581511_pgfId-998435]## <class-name> _com.example.MyDataSource_
</class-name>

[#50581511_pgfId-998436]## <server-name>myserver.com</server-name>

[#50581511_pgfId-998437]## <port-number>6689</port-number>

[#50581511_pgfId-998438]## <database-name>myDatabase</database-name>

[#50581511_pgfId-998439]## <user>lance</user>

[#50581511_pgfId-998440]## <password>secret</password>

[#50581511_pgfId-998441]## <property>

[#50581511_pgfId-998442]## <name>Property1</name>

[#50581511_pgfId-998443]## <value>10</value>

[#50581511_pgfId-998444]## </property>

[#50581511_pgfId-998445]## <property>

[#50581511_pgfId-998446]## <name>Property2</name>

[#50581511_pgfId-998447]## <value>20</value>

[#50581511_pgfId-998448]## </property>

[#50581511_pgfId-998449]## <login-timeout>0</login-timeout>

[#50581511_pgfId-998450]## <transactional>false</transactional>

[#50581511_pgfId-998451]##
<isolation-level>TRANSACTION_READ_COMMITTED</isolation-level>

[#50581511_pgfId-998452]## <initial-pool-size>0</initial-pool-size>

[#50581511_pgfId-1000055]## <max-pool-size>30</max-pool-size>

[#50581511_pgfId-998454]## <min-pool-size>20</min-pool-size>

[#50581511_pgfId-998455]## <max-idle-time>0</max-idle-time>

[#50581511_pgfId-998456]## <max-statements>50</max-statements>

[#50581511_pgfId-1000065]##</data-source>

[#50581511_pgfId-998230]## 

[#50581511_pgfId-998231]##A _DataSource_ resource may also be defined
using the _DataSourceDefinition_ annotation on a container-managed
class, such as a servlet or enterprise bean class.

[#50581511_pgfId-998233]##For example:

[#50581511_pgfId-998234]## 

[#50581511_pgfId-998235]## _@DataSourceDefinition(_

[#50581511_pgfId-1001409]## _name="java:app/MyDataSource",_

[#50581511_pgfId-998236]## _className="com.example.MyDataSource",_

[#50581511_pgfId-998237]## _portNumber=6689,_

[#50581511_pgfId-998238]## _serverName="myserver.com",_

[#50581511_pgfId-998239]## _user="lance",_

[#50581511_pgfId-998240]## _password="secret")_

[#50581511_pgfId-998242]## 

[#50581511_pgfId-998243]##(Of course, we do not recommend including
passwords to production systems in the code, but it's often useful while
testing. Passwords, or other parts of the _DataSource_ definition, can
be overridden by a deployment descriptor when the application is
deployed.)

[#50581511_pgfId-998302]##Once defined, a _DataSource_ resource may be
referenced by a component using the _resource-ref_ deployment descriptor
element or the _Resource_ annotation. For example, the above
_DataSource_ could be referenced as follows:

[#50581511_pgfId-998311]## 

[#50581511_pgfId-998312]## _@Stateless_

[#50581511_pgfId-998313]## _public class MySessionBean \{_

[#50581511_pgfId-998314]## _@Resource(lookup = "java:app/MyDataSource")_

[#50581511_pgfId-998315]## _DataSource myDB;_

[#50581511_pgfId-998316]## _..._

[#50581511_pgfId-998317]## _}_

[#50581511_pgfId-1003776]## 

[#50581511_pgfId-1003801]##The following _DataSourceDefinition_
annotation elements (and corresponding XML deployment descriptor
elements) are considered to specify an address for a _DataSource_
resource: _serverName_ , _portNumber_ , _databaseName_ , _url_ .

[#50581511_pgfId-1003818]##The following _DataSourceDefinition_
annotation elements (and corresponding XML deployment descriptor
elements) are considered to be quality of service elements:
_loginTimeout_ , _initialPoolSize_ , _maxPoolSize_ , _minPoolSize_ ,
_maxIdleTime_ , _maxStatements_ .

======= [#50581511_pgfId-998357]##Application Component Provider’s Responsibilities

[#50581511_pgfId-998358]##The Application Component Provider is
responsible for the definition of a _DataSource_ resource using a
_DataSourceDefinition_ annotation or the _data-source_ deployment
descriptor element.

[#50581511_pgfId-1003352]##If the database has been previously
provisioned for the application (e.g., by administrative action), it is
the responsibility of the Application Component Provider to specify the
class name of the data source implementation class and the server and
port at which the database is to be accessed.

[#50581511_pgfId-1007707]##A URL should not be specified in conjunction
with address elements such as server name and port. If it is, the
precedence order is undefined and implementation specific.

======= [#50581511_pgfId-998362]##Deployer’s Responsibilities

[#50581511_pgfId-1003358]##Requirements common to all resource
definition types are described in
link:JavaEE_Platform_Spec.htm#50581511_72429[See Requirements Common to
All Resource Definition Types]”. The following additional requirements
apply:

======= [#50581511_pgfId-1003363]##If specified, user name and password should be used as specified.

* [#50581511_pgfId-1003364]##The transactional specification and
isolation level must be used as specified.

======= [#50581511_pgfId-1003357]##Java EE Product Provider’s Responsibilities

[#50581511_pgfId-998214]##Requirements common to all resource definition
types are described in link:JavaEE_Platform_Spec.htm#50581511_72429[See
Requirements Common to All Resource Definition Types]”. The following
additional requirements apply:

* [#50581511_pgfId-1007695]##If a class name is specified, a resource
with the specified implementation class (or a subclass) must be
provided. If the class name is specified as _XADataSource_ , an XA
datasource must be provided.
* [#50581511_pgfId-1003373]##If an isolation level is specified, the
Product Provider must satisfy the request or provide a higher level of
isolation. If the request cannot be satisfied, the Product Provider must
reject the deployment.

======= [#50581511_pgfId-1000968]##[#50581511_87111]##JMS Connection Factory Resource Definition

[#50581511_pgfId-1000969]##An application may define a JMS
_ConnectionFactory_ resource.

[#50581511_pgfId-1000970]##The JMS _ConnectionFactory_ resource may be
defined in any of the JNDI namespaces described in
link:JavaEE_Platform_Spec.htm#50581511_61227[See Application Component
Environment Namespaces]”.

[#50581511_pgfId-1003141]##A JMS _ConnectionFactory_ resource may be
defined in a web module, EJB module, application client module, or
application deployment descriptor using the jms-connection-factory
element.

[#50581511_pgfId-1000979]##For example:

[#50581511_pgfId-1005860]## 

[#50581511_pgfId-1000981]##<jms-connection-factory>

[#50581511_pgfId-1000982]## <description>

[#50581511_pgfId-1001088]## Sample JMS ConnectionFactory definition

[#50581511_pgfId-1001089]## </description>

[#50581511_pgfId-1000983]## <name> _java:app/MyJMSCF_ </name>

[#50581511_pgfId-1000984]## <interface-name>

[#50581511_pgfId-1007867]## _javax.jms.QueueConnectionFactory_

[#50581511_pgfId-1007871]## </interface-name>

[#50581511_pgfId-1000985]## <resource-adapter>myJMSRA</resource-adapter>

[#50581511_pgfId-1000988]## <user>scott</user>

[#50581511_pgfId-1000989]## <password>secret</password>

[#50581511_pgfId-1001111]## <client-id>MyId</client-id>

[#50581511_pgfId-1000990]## <property>

[#50581511_pgfId-1000991]## <name>Property1</name>

[#50581511_pgfId-1000992]## <value>10</value>

[#50581511_pgfId-1000993]## </property>

[#50581511_pgfId-1000994]## <property>

[#50581511_pgfId-1000995]## <name>Property2</name>

[#50581511_pgfId-1000996]## <value>20</value>

[#50581511_pgfId-1000997]## </property>

[#50581511_pgfId-1000999]## <transactional>false</transactional>

[#50581511_pgfId-1001002]## <max-pool-size>30</max-pool-size>

[#50581511_pgfId-1001003]## <min-pool-size>20</min-pool-size>

[#50581511_pgfId-1001006]##</jms-connection-factory>

[#50581511_pgfId-1001007]## 

[#50581511_pgfId-1001008]##A JMS _ConnectionFactory_ resource may also
be defined using the _JMSConnectionFactoryDefinition_ annotation on a
container-managed class, such as a servlet or enterprise bean class.

[#50581511_pgfId-1001010]##For example:

[#50581511_pgfId-1001011]## 

[#50581511_pgfId-1001012]## _@JMSConnectionFactoryDefinition(_

[#50581511_pgfId-1001408]## _name="java:app/MyJMSCF",_

[#50581511_pgfId-1001013]##
_interfaceName="javax.jms.QueueConnectionFactory",_

[#50581511_pgfId-1001407]## _resourceAdapter="myJMSRA")_

[#50581511_pgfId-1001018]## 

[#50581511_pgfId-1001019]##(As with the _DataSource_ definition, we do
not recommend including passwords to production systems in the code, but
it's often useful while testing. Passwords, or other parts of the
_JMSConnectionFactoryDefinition_ annotation, can be overridden by a
deployment descriptor when the application is deployed.)

[#50581511_pgfId-1001021]##Once defined, a JMS _ConnectionFactory_
resource may be referenced by a component using the _resource-ref_
deployment descriptor element or the _Resource_ annotation. For example,
the above JMS _ConnectionFactory_ could be referenced as follows:

[#50581511_pgfId-1001022]## 

[#50581511_pgfId-1001023]## _@Stateless_

[#50581511_pgfId-1001024]## _public class MySessionBean \{_

[#50581511_pgfId-1001025]## _@Resource(lookup = "java:app/MyJMSCF")_

[#50581511_pgfId-1001026]## _ConnectionFactory myCF;_

[#50581511_pgfId-1001027]## _..._

[#50581511_pgfId-1001028]## _}_

[#50581511_pgfId-1005863]## 

[#50581511_pgfId-1003883]##The following
_JMSConnectionFactoryDefinition_ annotation elements (and corresponding
XML deployment descriptor elements) are considered to specify an address
for a JMS _ConnectionFactory_ resource: _resourceAdapter_ .

[#50581511_pgfId-1003890]##The following
_JMSConnectionFactoryDefinition_ annotation elements (and corresponding
XML deployment descriptor elements) are considered to be quality of
service elements: _maxPoolSize_ , _minPoolSize_ .

======= [#50581511_pgfId-1001030]##Application Component Provider’s Responsibilities

[#50581511_pgfId-1001031]##The Application Component Provider is
responsible for the definition of a JMS _ConnectionFactory_ using a
_JMSConnectionFactoryDefinition_ annotation or the
_jms-connection-factory_ deployment descriptor element.

======= [#50581511_pgfId-1001035]##Deployer’s Responsibilities

[#50581511_pgfId-1003920]##Requirements common to all resource
definition types are described in
link:JavaEE_Platform_Spec.htm#50581511_72429[See Requirements Common to
All Resource Definition Types]”. The following additional requirements
apply:

======= [#50581511_pgfId-1003393]##A resource of the specified interface type (or of the default interface type, if not specified) must be provided.

* [#50581511_pgfId-1003395]##If specified, user name and password should
be used as specified.
* [#50581511_pgfId-1003396]##The transactional specification must be
used as specified.
* [#50581511_pgfId-1003416]##If specified, the client id should be used
as specified.

======= [#50581511_pgfId-1003377]##Java EE Product Provider’s Responsibilities

[#50581511_pgfId-1003939]##Requirements common to all resource
definition types are described in
link:JavaEE_Platform_Spec.htm#50581511_72429[See Requirements Common to
All Resource Definition Types]”.

======= [#50581511_pgfId-1003145]##[#50581511_90666]##JMS Destination Definition

[#50581511_pgfId-1003146]##An application may define a JMS _Destination_
resource. A JMS _Destination_ resource is a JMS Queue or Topic.

[#50581511_pgfId-1001202]##The JMS _Destination_ resource may be defined
in any of the JNDI namespaces described in
link:JavaEE_Platform_Spec.htm#50581511_61227[See Application Component
Environment Namespaces]”.

[#50581511_pgfId-1003157]##A JMS _Destination_ resource may be defined
in a web module, EJB module, application client module, or application
deployment descriptor using the _jms-destination_ element.

[#50581511_pgfId-1001211]##For example:

======= [#50581511_pgfId-1001214]##<jms-destination>

[#50581511_pgfId-1001215]## <description>Sample JMS Destination
definition</description>

[#50581511_pgfId-1001218]## <name> _java:app/MyJMSDestination_ </name>

[#50581511_pgfId-1001219]## <interface-name> _javax.jms.Queue_
</interface-name>

[#50581511_pgfId-1001220]## <resource-adapter>myJMSRA</resource-adapter>

[#50581511_pgfId-1001373]##
<destination-name>myQueue1</destination-name>

[#50581511_pgfId-1001221]## <property>

[#50581511_pgfId-1001225]## <name>Property1</name>

[#50581511_pgfId-1001226]## <value>10</value>

[#50581511_pgfId-1001227]## </property>

[#50581511_pgfId-1001228]## <property>

[#50581511_pgfId-1001229]## <name>Property2</name>

[#50581511_pgfId-1001230]## <value>20</value>

[#50581511_pgfId-1001231]## </property>

[#50581511_pgfId-1001386]##</jms-destination>

[#50581511_pgfId-1001239]## 

[#50581511_pgfId-1001240]##A JMS _Destination_ resource may also be
defined using the _JMSDestinationDefinition_ annotation on a
container-managed class, such as a servlet or enterprise bean class.

[#50581511_pgfId-1001241]##For example:

======= [#50581511_pgfId-1001243]## _@JMSDestinationDefinition(_

[#50581511_pgfId-1001399]## _name="java:app/MyJMSQueue",_

[#50581511_pgfId-1001244]## _interfaceName="javax.jms.Queue",_

[#50581511_pgfId-1001400]## _destinationName="myQueue1")_

[#50581511_pgfId-1001246]## 

[#50581511_pgfId-1001247]##The _JMSDestinationDefinition_ annotation can
be overridden by a deployment descriptor when the application is
deployed.

[#50581511_pgfId-1001249]##Once defined, a JMS _Destination_ resource
may be referenced by a component using either the _resource-env-ref_ or
_message-destination-ref_ deployment descriptor element or the
_Resource_ annotation. For example, the above _Destination_ could be
referenced as follows:

[#50581511_pgfId-1001250]## 

[#50581511_pgfId-1001251]## _@Stateless_

[#50581511_pgfId-1001252]## _public class MySessionBean \{_

[#50581511_pgfId-1001253]## _@Resource(lookup = "java:app/MyJMSQueue")_

[#50581511_pgfId-1001254]## _Queue myQueue;_

[#50581511_pgfId-1001255]## _..._

[#50581511_pgfId-1001256]## _}_

[#50581511_pgfId-1003953]## 

[#50581511_pgfId-1003949]##The following _JMSDestinationDefinition_
annotation elements (and corresponding XML deployment descriptor
elements) are considered to specify an address for a JMS _Destination_
resource: _resourceAdapter_ , _destinationName_ .

======= [#50581511_pgfId-1001257]##Application Component Provider’s Responsibilities

[#50581511_pgfId-1001258]##The Application Component Provider is
responsible for the definition of a JMS _Destination_ using a
_JMSDestinationDefinition_ annotation or the _jms-destination_
deployment descriptor element.

======= [#50581511_pgfId-1001262]##Deployer’s Responsibilities

[#50581511_pgfId-1003966]##Requirements common to all resource
definition types are described in
link:JavaEE_Platform_Spec.htm#50581511_72429[See Requirements Common to
All Resource Definition Types]”. The following additional requirements
apply:

======= [#50581511_pgfId-1003440]##A resource of the specified interface type must be provided.

======= [#50581511_pgfId-1003428]##Java EE Product Provider’s Responsibilities

[#50581511_pgfId-1003977]##Requirements common to all resource
definition types are described in
link:JavaEE_Platform_Spec.htm#50581511_72429[See Requirements Common to
All Resource Definition Types]”.

======= [#50581511_pgfId-1001473]##[#50581511_22739]##Mail Session Definition

[#50581511_pgfId-1001474]##An application may define a Mail _Session_
resource.

[#50581511_pgfId-1001475]##The Mail _Session_ resource may be defined in
any of the JNDI namespaces described in
link:JavaEE_Platform_Spec.htm#50581511_61227[See Application Component
Environment Namespaces]”.

[#50581511_pgfId-1003166]##A Mail _Session_ resource may be defined in a
web module, EJB module, application client module, or application
deployment descriptor using the _mail-session_ element.

[#50581511_pgfId-1001484]##For example:

[#50581511_pgfId-1001485]## 

[#50581511_pgfId-1001486]##<mail-session>

[#50581511_pgfId-1001487]## <description>Sample Mail Session
definition</description>

[#50581511_pgfId-1001488]## <name> _java:app/mail/MySession_ </name>

[#50581511_pgfId-1001489]## <store-protocol> _imap_ </store-protocol>

[#50581511_pgfId-1001491]##
<transport-protocol>smtp</transport-protocol>

[#50581511_pgfId-1001620]## <host>somewhere.myco.com</host>

[#50581511_pgfId-1001621]## <user>linda</user>

[#50581511_pgfId-1001622]## <password>secret</password>

[#50581511_pgfId-1001635]## <from>some.body@myco.com</from>

[#50581511_pgfId-1001492]## <property>

[#50581511_pgfId-1006408]## <name>mail.smtp.starttls.enable</name>

[#50581511_pgfId-1001494]## <value>true</value>

[#50581511_pgfId-1001495]## </property>

[#50581511_pgfId-1001496]## <property>

[#50581511_pgfId-1001497]## <name>mail.imap.connectiontimeout</name>

[#50581511_pgfId-1001498]## <value>500</value>

[#50581511_pgfId-1001499]## </property>

[#50581511_pgfId-1001500]##</mail-session>

[#50581511_pgfId-1001501]## 

[#50581511_pgfId-1001502]##A Mail _Session_ resource may also be defined
using the _MailSessionDefinition_ annotation on a container-managed
class, such as a servlet or enterprise bean class.

[#50581511_pgfId-1001503]##For example:

[#50581511_pgfId-1001504]## 

[#50581511_pgfId-1001505]## _@MailSessionDefinition(_

[#50581511_pgfId-1001506]## _name="java:app/mail/MySession",_

[#50581511_pgfId-1001507]## _host="somewhere.myco.com",_

[#50581511_pgfId-1001508]## _from="some.body@myco.com")_

[#50581511_pgfId-1001509]## 

[#50581511_pgfId-1001510]##The _MailSessionDefinition_ annotation can be
overridden by a deployment descriptor when the application is deployed.

[#50581511_pgfId-1001512]##Once defined, a Mail _Session_ resource may
be referenced by a component using the _resource-ref_ deployment
descriptor element or the _Resource_ annotation. For example, the above
_Destination_ could be referenced as follows:

[#50581511_pgfId-1001513]## 

[#50581511_pgfId-1001514]## _@Stateless_

[#50581511_pgfId-1001515]## _public class MySessionBean \{_

[#50581511_pgfId-1001516]## _@Resource(lookup =
"java:app/mail/MySession")_

[#50581511_pgfId-1001517]## _Session myMailSession;_

[#50581511_pgfId-1001518]## _..._

[#50581511_pgfId-1001519]## _}_

[#50581511_pgfId-1003995]## 

[#50581511_pgfId-1003992]##The following _MailSessionDefinition_
annotation elements (and corresponding XML deployment descriptor
elements) are considered to specify an address for a Mail _Session_
resource: _host_ .

======= [#50581511_pgfId-1001520]##[#50581511_61154]##Application Component Provider’s Responsibilities

[#50581511_pgfId-1001521]##The Application Component Provider is
responsible for the definition of a Mail Session using a
_MailSessionDefinition_ annotation or the _mail-session_ deployment
descriptor element.

[#50581511_pgfId-1003474]##If a mail server resource has been previously
provisioned for the application (e.g., by administrative action), it is
the responsibility of the Application Component Provider to specify the
mail server host name.

======= [#50581511_pgfId-1001525]##Deployer’s Responsibilities

[#50581511_pgfId-1004003]##Requirements common to all resource
definition types are described in
link:JavaEE_Platform_Spec.htm#50581511_72429[See Requirements Common to
All Resource Definition Types]”. The following additional requirements
apply:

* [#50581511_pgfId-1003481]##If store protocol, store protocol class,
transport protocol, or transport protocol class has been specified, a
resource with the specified property or properties should be provided.
* [#50581511_pgfId-1004017]##If specified, the user name and password
should be used as specified.
* [#50581511_pgfId-1003499]##If specified, the from address should be
used as specified.

======= [#50581511_pgfId-1003475]##Java EE Product Provider’s Responsibilities

[#50581511_pgfId-1004023]##Requirements common to all resource
definition types are described in
link:JavaEE_Platform_Spec.htm#50581511_72429[See Requirements Common to
All Resource Definition Types]”.

======= [#50581511_pgfId-1001718]##[#50581511_80497]##Connector Connection Factory Definition

[#50581511_pgfId-1001719]##An application may define Connector
connection factory resources.

[#50581511_pgfId-1001720]##The resource may be defined in any of the
JNDI namespaces described in
link:JavaEE_Platform_Spec.htm#50581511_61227[See Application Component
Environment Namespaces]”.

[#50581511_pgfId-1003175]##A Connector connection factory resource may
be defined in a web module, EJB module, or application deployment
descriptor using the _connection-factory_ element.

[#50581511_pgfId-1001729]##For example:

[#50581511_pgfId-1001730]## 

[#50581511_pgfId-1001731]##< _connection-factory_ >

[#50581511_pgfId-1001732]## <description>Sample Connector resource
definition</description>

[#50581511_pgfId-1001733]## <name> _java:app/myConnectionFactory_
</name>

[#50581511_pgfId-1007625]## <interface-name>

[#50581511_pgfId-1007633]## com.eis.ConnectionFactory

[#50581511_pgfId-1007634]## </interface-name>

[#50581511_pgfId-1007110]## <resource-adapter>MyEISRA</resource-adapter>

[#50581511_pgfId-1007111]## <max-pool-size>20</max-pool-size>

[#50581511_pgfId-1007112]## <min-pool-size>10</min-pool-size>

[#50581511_pgfId-1007620]##
<transaction-support>XATransaction</transaction-support>

[#50581511_pgfId-1001735]## <property>

[#50581511_pgfId-1001747]## <name>Property1</name>

[#50581511_pgfId-1001748]## <value>prop1val</value>

[#50581511_pgfId-1001749]## </property>

[#50581511_pgfId-1001750]## <property>

[#50581511_pgfId-1001751]## <name>Property2</name>

[#50581511_pgfId-1001752]## <value>prop2val</value>

[#50581511_pgfId-1001753]## </property>

[#50581511_pgfId-1001754]##</ _connection-factory_ >

[#50581511_pgfId-1001755]## 

[#50581511_pgfId-1001756]##A Connector connection factory resource may
also be defined using the _ConnectionFactoryDefinition_ annotation on a
container-managed class, such as a servlet or enterprise bean class.

[#50581511_pgfId-1001757]##For example:

[#50581511_pgfId-1001758]## 

[#50581511_pgfId-1001759]## _@ConnectionFactoryDefinition(_

[#50581511_pgfId-1001760]## _name="java:app/myConnectionFactory",_

[#50581511_pgfId-1001761]## _interfaceName="com.eis.ConnectionFactory",_

[#50581511_pgfId-1007120]## _resourceAdapter="MyESRA")_

[#50581511_pgfId-1001763]## 

[#50581511_pgfId-1001764]##The _ConnectionFactoryDefinition_ annotation
can be overridden by a deployment descriptor when the application is
deployed.

[#50581511_pgfId-1001766]##Once defined, a Connector connection factory
resource may be referenced by a component using the _resource-ref_
deployment descriptor element or the _Resource_ annotation. For example,
the above Connector connection factory resource could be referenced as
follows:

[#50581511_pgfId-1001767]## 

[#50581511_pgfId-1001768]## _@Stateless_

[#50581511_pgfId-1001769]## _public class MySessionBean \{_

[#50581511_pgfId-1001770]## _@Resource(lookup =
"java:app/myConnectionFactory")_

[#50581511_pgfId-1001771]## _ConnectionFactory myCF;_

[#50581511_pgfId-1001772]## _..._

[#50581511_pgfId-1001773]## _}_

======= [#50581511_pgfId-1001774]##Application Component Provider’s Responsibilities

[#50581511_pgfId-1001775]##The Application Component Provider is
responsible for the definition of a Connector connection factory
resource using a _ConnectionFactoryDefinition_ annotation or the
_connection-factory_ deployment descriptor element.

======= [#50581511_pgfId-1001779]##Deployer’s Responsibilities

[#50581511_pgfId-1004039]##Requirements common to all resource
definition types are described in
link:JavaEE_Platform_Spec.htm#50581511_72429[See Requirements Common to
All Resource Definition Types]”. The following additional requirements
apply:

* [#50581511_pgfId-1003513]##A resource of the specified type must be
provided.

======= [#50581511_pgfId-1003507]##Java EE Product Provider’s Responsibilities

[#50581511_pgfId-1004030]##Requirements common to all resource
definition types are described in
link:JavaEE_Platform_Spec.htm#50581511_72429[See Requirements Common to
All Resource Definition Types]”.

======= [#50581511_pgfId-1004520]##[#50581511_85453]##Connector Administered Object Definition

[#50581511_pgfId-1004528]##An application may define a Connector
administered object resource. The administered object resource may be
defined in any of the JNDI namespaces described in
link:JavaEE_Platform_Spec.htm#50581511_61227[See Application Component
Environment Namespaces]”.

[#50581511_pgfId-1004810]##An administered object resource may be
defined in a web module, EJB module, or application deployment
descriptor using the _administered-object_ element. Properties that are
specified are used in the configuration of the administered object, as
described in the Connector specification.

[#50581511_pgfId-1004535]##For example:

======= [#50581511_pgfId-1004592]##<administered-object>

[#50581511_pgfId-1004593]## <description>Sample Admin Object
definition</description>

[#50581511_pgfId-1004594]## <name> _java:app/MyAdminObject_ </name>

[#50581511_pgfId-1004595]## <class-name> _com.extraServices.AdminObject_
</class-name>

[#50581511_pgfId-1004596]## <resource-adapter>myESRA</resource-adapter>

[#50581511_pgfId-1004598]## <property>

[#50581511_pgfId-1004599]## <name>Property1</name>

[#50581511_pgfId-1004600]## <value>10</value>

[#50581511_pgfId-1004601]## </property>

[#50581511_pgfId-1004602]## <property>

[#50581511_pgfId-1004603]## <name>Property2</name>

[#50581511_pgfId-1004604]## <value>20</value>

[#50581511_pgfId-1004605]## </property>

[#50581511_pgfId-1004606]##</administered-object>

[#50581511_pgfId-1004589]## 

[#50581511_pgfId-1004541]##An administered object resource may also be
defined using the _AdministeredObjectDefinition_ annotation on a
container-managed class, such as a servlet or enterprise bean class.

[#50581511_pgfId-1004542]##For example:

[#50581511_pgfId-1004636]## 

[#50581511_pgfId-1004637]##@AdministeredObjectDefinition(

[#50581511_pgfId-1004638]## name= _"_ java:app/myAdminObject _"_ ,

[#50581511_pgfId-1004639]## className= _"_ com.extraServices.AdminObject
_",_

[#50581511_pgfId-1007167]## resourceAdapter= _"_ myESRA _"_ )

[#50581511_pgfId-1004543]## 

[#50581511_pgfId-1004544]##The _AdministeredObjectDefinition_ annotation
can be overridden by a deployment descriptor when the application is
deployed.

[#50581511_pgfId-1004548]##Once defined, an administered object resource
may be referenced by a component using the _resource-env-ref_ deployment
descriptor element or the _Resource_ annotation. For example, the above
administered object resource could be referenced as follows:

[#50581511_pgfId-1004662]## 

[#50581511_pgfId-1004663]## _@Stateless public class MySessionBean \{_

[#50581511_pgfId-1004665]## _@Resource(lookup =
"java:app/myAdminObject")_

[#50581511_pgfId-1004666]## _AdminObject myAdminObject;_

[#50581511_pgfId-1004667]## _..._

[#50581511_pgfId-1004668]## _}_

======= [#50581511_pgfId-1004562]##Application Component Provider’s Responsibilities

[#50581511_pgfId-1004566]##The Application Component Provider is
responsible for the definition of an administered object resource using
an _AdministeredObjectDefinition_ annotation or the
_administered-object_ deployment descriptor element.

======= [#50581511_pgfId-1004568]##Deployer’s Responsibilities

[#50581511_pgfId-1004575]##Requirements common to all resource
definition types are described in
link:JavaEE_Platform_Spec.htm#50581511_72429[See Requirements Common to
All Resource Definition Types]”. The following additional requirements
apply:

[#50581511_pgfId-1004579]##If a class name is specified, an administered
object resource of the specified class (or a subclass) must be provided.

======= [#50581511_pgfId-1004580]##Java EE Product Provider’s Responsibilities

[#50581511_pgfId-1004585]##Requirements common to all resource
definition types are described in
link:JavaEE_Platform_Spec.htm#50581511_72429[See Requirements Common to
All Resource Definition Types].”

==== [#50581511_pgfId-1002994]##[#50581511_90595]##Default Data Source

[#50581511_pgfId-1004876]##The Java EE Platform requires that a Java EE
Product Provider provide a database in the operational environment (see
link:JavaEE_Platform_Spec.htm#50581512_26144[See Database]”). The Java
EE Product Provider must also provide a preconfigured, default data
source for use by the application in accessing this database.

[#50581511_pgfId-1006129]##The Java EE Product Provider must make the
default data source accessible to the application under the JNDI name
_java:comp/DefaultDataSource_ .

[#50581511_pgfId-1006142]##The Application Component Provider or
Application Assembler may explicitly bind a DataSource resource
reference to the default data source using the _lookup_ element of the
_Resource_ annotation or the _lookup-name_ element of the _resource-ref_
deployment descriptor element. For example,

[#50581511_pgfId-1004882]## 

[#50581511_pgfId-1006646]##@Resource(lookup="java:comp/DefaultDataSource")

[#50581511_pgfId-1004883]##DataSource myDS;

[#50581511_pgfId-1006154]## 

[#50581511_pgfId-1006150]##In the absence of such a binding, or an
equivalent product-specific binding, the mapping of the reference will
default to the product's default data source.

[#50581511_pgfId-1006160]##For example, the following will map to a
preconfigured data source for the product's default database:

[#50581511_pgfId-1004889]## 

[#50581511_pgfId-1006647]##@Resource

[#50581511_pgfId-1004874]##DataSource myDS;

======= [#50581511_pgfId-1004937]##[#50581511_67004]##Java EE Product Provider's Responsibilities

[#50581511_pgfId-1004954]##The Java EE Product Provider must provide a
database in the operational environment. The Java EE Product Provider
must also provide a preconfigured, default data source for use by the
application in accessing this database under the JNDI name
_java:comp/DefaultDataSource_ .

[#50581511_pgfId-1006169]##If a DataSource resource reference is not
mapped to a specific data source by the Application Component Provider,
Application Assembler, or Deployer, it must be mapped by the Java EE
Product Provider to a preconfigured data source for the Java EE Product
Provider's default database.

==== [#50581511_pgfId-1004873]##[#50581511_52679]##Default JMS Connection Factory

[#50581511_pgfId-1004969]##The Java EE Platform requires that a Java EE
Product Provider provide a JMS provider in the operational environment
(see link:JavaEE_Platform_Spec.htm#50581512_83297[See Java™ Message
Service (JMS)]”) . The Java EE Product Provider must also provide a
preconfigured, JMS ConnectionFactory for use by the application in
accessing this JMS provider.

[#50581511_pgfId-1006176]##The Java EE Product Provider must make the
default JMS connection factory accessible to the application under the
JNDI name _java:comp/DefaultJMSConnectionFactory_ .

[#50581511_pgfId-1006181]##The Application Component Provider or
Application Assembler may explicitly bind a JMS ConnectionFactory
resource reference to the default connection factory using the _lookup_
element of the _Resource_ annotation or the _lookup-name_ element of the
_resource-ref_ deployment descriptor element. For example,

[#50581511_pgfId-1006363]## 

[#50581511_pgfId-1004975]##@Resource(name="myJMSCF",

[#50581511_pgfId-1005012]##
lookup="java:comp/DefaultJMSConnectionFactory")

[#50581511_pgfId-1004976]##ConnectionFactory myJMScf;

[#50581511_pgfId-1004977]## 

[#50581511_pgfId-1004979]##In the absence of such a binding, or an
equivalent product-specific binding, the mapping of the reference will
default to a JMS connection factory for the product's JMS provider.

[#50581511_pgfId-1004981]##For example, the following will map to a
preconfigured connection factory for the product's default JMS provider:

[#50581511_pgfId-1006204]## 

[#50581511_pgfId-1006203]##@Resource(name="myJMSCF")

[#50581511_pgfId-1004967]##ConnectionFactory myJMScf;

======= [#50581511_pgfId-1005023]##[#50581511_99657]##Java EE Product Provider's Responsibilities

[#50581511_pgfId-1005033]##The Java EE Product Provider must provide a
JMS provider in the operational environment. The Java EE Product
Provider must also provide a preconfigured, default JMS connection
factory for use by the application in accessing this provider under the
JNDI name _java:comp/DefaultJMSConnectionFactory_ .

[#50581511_pgfId-1006238]##If a JMS ConnectionFactory resource reference
is not mapped to a specific JMS connection factory by the Application
Component Provider, Application Assembler, or Deployer, it must be
mapped by the Java EE Product Provider to a preconfigured JMS connection
factory for the Java EE Product Provider's default JMS provider.

==== [#50581511_pgfId-1007467]##[#50581511_67316]##Default Concurrency Utilities Objects

[#50581511_pgfId-1007468]##The Java EE Platform requires that a Java EE
Product Provider provide a preconfigured default managed executor
service, a preconfigured default managed scheduled executor service, a
preconfigured default managed thread factory, and a preconfigured
default context service for use by the application.

[#50581511_pgfId-1007472]##The Java EE Product Provider must make the
default Concurrency Utilities for Java EE objects accessible to the
application under the following JNDI names:

======= [#50581511_pgfId-1007473]## _java:comp/ DefaultManagedExecutorService_ for the preconfigured managed executor service

* [#50581511_pgfId-1007474]##
_java:comp/DefaultManagedScheduledExecutorService_ for the preconfigured
managed scheduled executor service
* [#50581511_pgfId-1007475]##j _ava:comp/DefaultManagedThreadFactory_
for the preconfigured managed thread factory
* [#50581511_pgfId-1007476]## _java:comp/DefaultContextService_ for the
preconfigured context service

[#50581511_pgfId-1007477]##The Application Component Provider or
Application Assembler may explicitly bind a resource reference to a
default Concurrency Utilities object using the _lookup_ element of the
_Resource_ annotation or the _lookup-name_ element of the _resource-ref_
deployment descriptor element. For example,

[#50581511_pgfId-1007478]## 

[#50581511_pgfId-1007479]##@Resource(name="myManagedExecutorService,

[#50581511_pgfId-1007480]##
lookup="java:comp/DefaultManagedExecutorService")

[#50581511_pgfId-1007481]##ManagedExecutorService
myManagedExecutorService;

[#50581511_pgfId-1007482]## 

[#50581511_pgfId-1007483]##In the absence of such a binding, or an
equivalent product-specific binding, the mapping of the reference will
default to the product's default managed executor service.

[#50581511_pgfId-1007484]##For example, the following will map to a
preconfigured default managed executor service for the product:

[#50581511_pgfId-1007485]## 

[#50581511_pgfId-1007486]##@Resource(name="myManagedExecutorService")

[#50581511_pgfId-1007487]##ManagedExecutorService
myManagedExecutorService;

======= [#50581511_pgfId-1007488]##[#50581511_38942]##Java EE Product Provider's Responsibilities

[#50581511_pgfId-1007489]##The Java EE Product Provider must provide the
following:

======= [#50581511_pgfId-1007491]##a preconfigured, default managed executor service for use by the application in accessing this service under the JNDI name _java:comp/DefaultManagedExecutorService_ ;

* [#50581511_pgfId-1007492]##a preconfigured, default managed scheduled
executor service for use by the application in accessing this service
under the JNDI name _java:comp/DefaultManagedScheduledExecutorService_ ;
* [#50581511_pgfId-1007493]##a preconfigured, default managed thread
factory for use by the application in accessing this factory under the
JNDI name _java:comp/DefaultManagedThreadFactory_ ;
* [#50581511_pgfId-1007494]##a preconfigured, default context service
for use by the application in accessing this service under the JNDI name
_java:comp/DefaultContextService_ .

[#50581511_pgfId-1007495]##If a Concurrency Utilities object resource
environment reference is not mapped to a specific configured object by
the Application Component Provider, Application Assembler, or Deployer,
it must be mapped by the Java EE Product Provider to a preconfigured
Concurrency Utilities object for the Java EE Product Provider.

==== [#50581511_pgfId-1004869]##[#50581511_20225]##Managed Bean References

[#50581511_pgfId-1004870]##This section describes the metadata
annotations and deployment descriptor entries that allow an application
to obtain instances of a Managed Bean.

[#50581511_pgfId-998742]##An instance of a named Managed Bean can be
obtained by looking up its name in JNDI using the same naming scheme
used for EJB components:

[#50581511_pgfId-998743]## 

[#50581511_pgfId-998744]##java:app/<module-name>/<bean-name>

[#50581511_pgfId-998745]## 

[#50581511_pgfId-998746]##java:module/<bean-name>

[#50581511_pgfId-998747]## 

[#50581511_pgfId-998751]##The latter will only work within the module
the Managed Bean is declared in.

[#50581511_pgfId-998752]##Each such lookup must return a new instance.

[#50581511_pgfId-998754]##Alternatively, the _Resource_ annotation can
be used to request the injection of a Managed Bean given either its type
or its name. If a name is specified using the _lookup_ element then the
type of the resource can be any of the types that the Managed Bean class
implements, including any of its interfaces. If no name is specified,
the type must be the Managed Bean class itself. (Note that the _name_
element of the _Resource_ annotation serves an entirely different
purpose than the _lookup_ element, consistently with other uses of
_Resource_ in this specification.) The _authenticationType_ and
_shareable_ elements of the _Resource_ annotation must not be specified.

[#50581511_pgfId-998756]##For example, given a _ShoppingCartBean_ bean
named _“cart”_ defined in the same module as the client code and
implementing the _ShoppingCart_ interface, a client may use any of the
following methods to obtain an instance of the bean class:

[#50581511_pgfId-998757]## 

[#50581511_pgfId-998758]##@Resource ShoppingCartBean cart;

[#50581511_pgfId-998759]## 

[#50581511_pgfId-998760]##@Resource(lookup= _"_ java:module/cart")
ShoppingCart cart;

[#50581511_pgfId-998761]## 

[#50581511_pgfId-998762]##ShoppingCart cart = (ShoppingCart)
context.lookup("java:module/cart");

[#50581511_pgfId-998763]## 

[#50581511_pgfId-999728]##References to managed beans can be declared in
the deployment descriptor using the _resource-ref_ element. The
_res-type_ element must contain a type that the managed bean implements.
The _lookup-name_ must be present and refer to a managed bean by name.
The _res-sharing-scope_ and _res-auth_ elements may be omitted; if
present, they must have the values _Shareable_ and _Container_
respectively, so as to match the default values of the corresponding
elements of the _Resource_ annotation.

[#50581511_pgfId-999764]##The following example shows how to declare
references to the shopping cart bean of the previous example, this time
using descriptors. (To make the example somewhat more realistic, one
should add an _injection-target_ child element to _resource-ref_ .)

[#50581511_pgfId-999780]## 

[#50581511_pgfId-999770]##<resource-ref>

[#50581511_pgfId-999776]## <res-ref-name>bean/cart</ref-ref-name>

[#50581511_pgfId-999778]## <ref-type>com.acme.ShoppingCart</ref-type>

[#50581511_pgfId-999779]## <lookup-name>java:module/cart</lookup-name>

[#50581511_pgfId-999777]##</resource-ref>

[#50581511_pgfId-999787]## 

======= [#50581511_pgfId-998764]##Application Component Provider’s Responsibilities

[#50581511_pgfId-998765]##The Application Component Provider is
responsible for requesting injection of a Managed Bean or for looking it
up in JNDI using an appropriate name.

======= [#50581511_pgfId-998766]##Java EE Product Provider’s Responsibilities

[#50581511_pgfId-998767]##The Java EE Product Provider is responsible
for providing appropriate instances of the requested Managed Bean class
as required by this specification.

==== [#50581511_pgfId-1007314]##[#50581511_17023]##Bean Manager References

[#50581511_pgfId-1000260]##This section describes the metadata
annotations and deployment descriptor entries that allow an application
to obtain instances of the CDI _BeanManager_ type.

[#50581511_pgfId-1000261]##Typically, only portable extensions using the
CDI SPI need to access a _BeanManager_ . Application code may
occasionally require access to that interface; in that case, the
application should either look up a _BeanManager_ instance in JNDI under
the name _java:comp/BeanManager_ , or request the injection of an object
of type _javax.enterprise.inject.spi.BeanManager_ via the _Resource_
annotation. If the latter, the _authenticationType_ and _shareable_
elements of the _Resource_ annotation must not be specified.

======= [#50581511_pgfId-1000262]##@Resource BeanManager manager;

[#50581511_pgfId-1000266]## 

[#50581511_pgfId-1000281]##Per the CDI specification, a bean can also
request the injection of a _BeanManager_ using the _Inject_ annotation.

======= [#50581511_pgfId-1000371]##@Inject BeanManager manager;

[#50581511_pgfId-1000369]## 

[#50581511_pgfId-1000361]##A _BeanManager_ object reference may also be
declared in a deployment descriptor in the same way as a resource
environment reference.

======= [#50581511_pgfId-1000286]##Application Component Provider’s Responsibilities

[#50581511_pgfId-1000287]##The Application Component Provider is
responsible for requesting injection of a _BeanManager_ instance using a
_Resource_ annotation, or using the defined name to look up an instance
in JNDI.

======= [#50581511_pgfId-1000292]##Java EE Product Provider’s Responsibilities

[#50581511_pgfId-1000296]##The Java EE Product Provider is responsible
for providing appropriate _BeanManager_ instances as required by this
specification.

==== [#50581511_pgfId-1000182]##[#50581511_62440]##Support for Dependency Injection

[#50581511_pgfId-1000183]##In Java EE, support for dependency injection
annotations as specified in the Dependency Injection for Java
specification is mediated by CDI. Containers must support injection
points annotated with the _javax.inject.Inject_ annotation only to the
extent dictated by CDI.

[#50581511_pgfId-999391]##Per the CDI specification, dependency
injection is supported on managed beans. There are currently three ways
for a class to become a managed bean:

. [#50581511_pgfId-999392]##Being an EJB session bean component.
. [#50581511_pgfId-999403]##Being annotated with the _ManagedBean_
annotation.
. [#50581511_pgfId-999413]##Satisfying the conditions described in the
CDI specification.

[#50581511_pgfId-999393]##Classes that satisfy at least one of these
conditions will be eligible for full dependency injection support as
described in the CDI specification.

[#50581511_pgfId-1006961]##Component classes listed in
link:JavaEE_Platform_Spec.htm#50581511_19779[See Component classes
supporting injection] that satisfy the third condition above, but
neither the first nor the second condition, can also be used as CDI
managed beans if they are annotated with a CDI bean-defining annotation
or contained in a bean archive for which CDI is enabled. However, if
they are used as CDI managed beans (e.g., injected into other managed
classes), the instances that are managed by CDI may not be the instances
that are managed by the Java EE container.

[#50581511_pgfId-999422]##Therefore, to make injection support more
uniform across all Java EE component types, Java EE containers are
required to support field, method, and constructor injection using the
_javax.inject.Inject_ annotation into all component classes listed in
link:JavaEE_Platform_Spec.htm#50581511_19779[See Component classes
supporting injection] as having the “Standard” level of injection
support, as well as the use of interceptors for these classes. Such
injection must be performed in the same logical phase as resource
injection of fields and methods annotated with the _Resource_
annotation. In particular, dependency injection must precede the
invocation of any methods annotated with the _PostConstruct_ annotation.
In supporting such injection points, the container must behave as if it
carried out the following steps, involving the use of the CDI SPI. Note
that using these steps causes the container to create a non-contextual
instance, which is not managed by CDI but rather by the Java EE
container.

. [#50581511_pgfId-999449]##Obtain a _BeanManager_ instance.
. [#50581511_pgfId-1006510]##Create an _AnnotatedType_ instance for the
component into which injection is to occur.
. [#50581511_pgfId-1006518]##Create an _InjectionTarget_ instance for
the annotated type.
. [#50581511_pgfId-1006519]##Create a _CreationalContext_ , passing in
_null_ to the _BeanManager_ _createCreationalContext_ method.
. [#50581511_pgfId-1006520]##Instantiate the component by calling the
_InjectionTarget_ _produce_ method.
. [#50581511_pgfId-1006521]##Inject the component instance by calling
the _InjectionTarget_ _inject_ method on the instance.
. [#50581511_pgfId-1006524]##Invoke the _PostConstruct_ callback, if
any, by calling the _InjectionTarget_ _postConstruct_ method on the
instance.

[#50581511_pgfId-999447]##When such a non-contextual instance is to be
destroyed, the container should behave as if it carried out the
following steps.

. [#50581511_pgfId-1007798]##Invoke the _PreDestroy_ callback, if any,
by calling the _InjectionTarget_ _preDestroy_ method on the instance.
. [#50581511_pgfId-1007804]##Invoke the _InjectionTarget_ _dispose_
method on the instance.
. [#50581511_pgfId-1007812]##Invoke the _CreationalContext_ _release_
method to destroy any dependent objects of the instance.

[#50581511_pgfId-1007795]##Containers may optimize the steps above,
e.g., by avoiding calls to the actual CDI SPI and relying on
container-specific interfaces instead, as long as the outcome is the
same.

======= [#50581515_pgfId-874]##CHAPTER __ [#50581515_32725]##

[#50581515_pgfId-1019297]##[#50581515_23254]##Application Programming
Interface

[#50581515_pgfId-1020138]## _T_ his chapter describes API requirements
for the Java™ Platform, Enterprise Edition (Java EE). Java EE requires
the provision of a number of APIs for use by Java EE applications,
starting with the core Java APIs and including many additional Java
technologies.

==== [#50581515_pgfId-1020146]##[#50581515_69518]##Required APIs

[#50581515_pgfId-1000502]##Java EE application components execute in
runtime environments provided by the containers that are a part of the
Java EE platform. The full Java EE platform supports four types of
containers corresponding to Java EE application component types:
application client containers; applet containers; web containers for
servlets, JSP pages, JSF applications, JAX-RS applications; and
enterprise bean containers. A Java EE profile may support only a subset
of these component types, as defined by the individual Java EE profile
specification.

[#50581515_pgfId-1020149]##The per-technology requirements in this
chapter apply to any Java EE product that includes the technology. Note
that even though a Java EE profile might not require support for a
particular technology, a Java EE product based on that Java EE profile
might nonetheless include support for the technology. In such a case,
the requirements for that technology described in this chapter would
apply.

======= [#50581515_pgfId-1005972]##Java Compatible APIs

[#50581515_pgfId-1005962]##The containers provide all application
components with at least the Java Platform, Standard Edition, v8 (Java
SE) APIs. Containers may provide newer versions of the Java SE platform,
provided they meet all the Java EE platform requirements. The Java SE
platform includes the following enterprise technologies:

======= [#50581515_pgfId-6958]##Java IDL

* [#50581515_pgfId-6959]##JDBC
* [#50581515_pgfId-1004158]##RMI-IIOP
* [#50581515_pgfId-1017458]##JNDI
* [#50581515_pgfId-1017459]##JAXP
* [#50581515_pgfId-1019510]##StAX
* [#50581515_pgfId-1017466]##JAAS
* [#50581515_pgfId-1017584]##JMX
* [#50581515_pgfId-1019480]##JAX-WS
* [#50581515_pgfId-1019483]##JAXB
* [#50581515_pgfId-1019481]##JAF
* [#50581515_pgfId-1019482]##SAAJ

======= [#50581515_pgfId-1019484]##Common Annotations

[#50581515_pgfId-1017460]##In particular, the applet execution
environment must be Java SE 8 compatible. Since typical browsers don’t
yet provide such support, Java EE products may make use of the Java
Plugin to provide the required applet execution environment. Use of the
Java Plugin is not required, but is one method of meeting the
requirement to provide a Java SE 8 compatible applet execution
environment. This specification adds no requirements to the applet
container beyond those specified by Java SE.

[#50581515_pgfId-1019509]##Some of the enterprise technologies that are
included in Java SE 8 are also available independently of the Java SE
platform, and this specification requires newer versions of some of
these technologies, as described in the following section.

[#50581515_pgfId-1002405]##The specifications for the Java SE APIs are
available at _http://docs.oracle.com/javase/8/docs/_ .

======= [#50581515_pgfId-1005973]##[#50581515_25497]##Required Java Technologies

[#50581515_pgfId-1020153]##The full Java EE platform also provides a
number of Java technologies in each of the containers defined by this
specification. _link:JavaEE_Platform_Spec.htm#50581515_TABLE%206-1[See
Java EE Technologies]_ indicates the technologies with their required
versions, which containers include the technologies, and whether the
technology is required (REQ), proposed optional (POPT), or optional
(OPT). Each Java EE profile specification will include a similar table
describing which technologies are required for the profile. Note that
some technologies are marked Optional, as described in the next section.

======= [#50581515_pgfId-1022505]##[#50581515_TABLE 6-1]##Java EE Technologies

[#50581515_pgfId-1022515]##Java Technology

[#50581515_pgfId-1022517]##App Client

[#50581515_pgfId-1022519]##Web

[#50581515_pgfId-1022521]##EJB

[#50581515_pgfId-1022523]##Status

[#50581515_pgfId-1022525]##EJB 3.2

{empty}[#50581515_pgfId-1022530]##Ylink:#pgfId-1022529[14]

[#50581515_pgfId-1022532]##Y

[#50581515_pgfId-1022534]##Y

{empty}[#50581515_pgfId-1022539]##REQ, OPTlink:#pgfId-1022538[15],
POPTlink:#pgfId-1027175[16]

[#50581515_pgfId-1022541]##Servlet 4.0

[#50581515_pgfId-1022543]##N

[#50581515_pgfId-1022545]##Y

[#50581515_pgfId-1022547]##N

[#50581515_pgfId-1022549]##REQ

[#50581515_pgfId-1022551]##JSP 2.3

[#50581515_pgfId-1022553]##N

[#50581515_pgfId-1022555]##Y

[#50581515_pgfId-1022557]##N

[#50581515_pgfId-1022559]##REQ

[#50581515_pgfId-1022561]##EL 3.0

[#50581515_pgfId-1022563]##N

[#50581515_pgfId-1022565]##Y

[#50581515_pgfId-1022567]##N

[#50581515_pgfId-1022569]##REQ

[#50581515_pgfId-1022571]##JMS 2.0

[#50581515_pgfId-1022573]##Y

[#50581515_pgfId-1022575]##Y

[#50581515_pgfId-1022577]##Y

[#50581515_pgfId-1022579]##REQ

[#50581515_pgfId-1022581]##JTA 1.2

[#50581515_pgfId-1022583]##N

[#50581515_pgfId-1022585]##Y

[#50581515_pgfId-1022587]##Y

[#50581515_pgfId-1022589]##REQ

[#50581515_pgfId-1022591]##JavaMail 1.6

[#50581515_pgfId-1022593]##Y

[#50581515_pgfId-1022595]##Y

[#50581515_pgfId-1022597]##Y

[#50581515_pgfId-1022599]##REQ

[#50581515_pgfId-1022601]##Connector 1.7

[#50581515_pgfId-1022603]##N

[#50581515_pgfId-1022605]##Y

[#50581515_pgfId-1022607]##Y

[#50581515_pgfId-1022609]##REQ

[#50581515_pgfId-1022611]##Web Services 1.4

[#50581515_pgfId-1022613]##Y

[#50581515_pgfId-1022615]##Y

[#50581515_pgfId-1022617]##Y

[#50581515_pgfId-1022619]##REQ

[#50581515_pgfId-1022621]##JAX-RPC 1.1

[#50581515_pgfId-1022623]##Y

[#50581515_pgfId-1022625]##Y

[#50581515_pgfId-1022627]##Y

[#50581515_pgfId-1022629]##OPT

[#50581515_pgfId-1022641]##JAX-RS 2.1

[#50581515_pgfId-1022643]##N

[#50581515_pgfId-1022645]##Y

[#50581515_pgfId-1022647]##N

[#50581515_pgfId-1022649]##REQ

[#50581515_pgfId-1025594]##WebSocket 1.1

[#50581515_pgfId-1025596]##N

[#50581515_pgfId-1025598]##Y

[#50581515_pgfId-1025600]##N

[#50581515_pgfId-1025602]##REQ

[#50581515_pgfId-1025584]##JSON-P 1.1

[#50581515_pgfId-1025586]##Y

[#50581515_pgfId-1025588]##Y

[#50581515_pgfId-1025590]##Y

[#50581515_pgfId-1025592]##REQ

[#50581515_pgfId-1026889]##JSON-B 1.0

[#50581515_pgfId-1026891]##Y

[#50581515_pgfId-1026893]##Y

[#50581515_pgfId-1026895]##Y

[#50581515_pgfId-1026897]##REQ

[#50581515_pgfId-1025982]##Concurrency Utilities for Java EE 1.0

[#50581515_pgfId-1025984]##N

[#50581515_pgfId-1025986]##Y

[#50581515_pgfId-1025988]##Y

[#50581515_pgfId-1025990]##REQ

[#50581515_pgfId-1025574]##Batch 1.0

[#50581515_pgfId-1025576]##N

[#50581515_pgfId-1025578]##Y

[#50581515_pgfId-1025580]##Y

[#50581515_pgfId-1025582]##REQ

[#50581515_pgfId-1022661]##JAXR 1.0

[#50581515_pgfId-1022663]##Y

[#50581515_pgfId-1022665]##Y

[#50581515_pgfId-1022667]##Y

[#50581515_pgfId-1022669]##OPT

[#50581515_pgfId-1022671]##Java EE Management 1.1

[#50581515_pgfId-1022673]##Y

[#50581515_pgfId-1022675]##Y

[#50581515_pgfId-1022677]##Y

[#50581515_pgfId-1022679]##REQ

{empty}[#50581515_pgfId-1022687]##Java EE Deployment
1.2link:#pgfId-1022686[17]

[#50581515_pgfId-1022689]##N

[#50581515_pgfId-1022691]##N

[#50581515_pgfId-1022693]##N

[#50581515_pgfId-1022695]##OPT

[#50581515_pgfId-1022697]##JACC 1.5

[#50581515_pgfId-1022699]##N

[#50581515_pgfId-1022701]##Y

[#50581515_pgfId-1022703]##Y

[#50581515_pgfId-1022705]##REQ

[#50581515_pgfId-1022707]##JASPIC 1.1

[#50581515_pgfId-1022709]##N

[#50581515_pgfId-1022711]##Y

[#50581515_pgfId-1022713]##Y

[#50581515_pgfId-1022715]##REQ

[#50581515_pgfId-1027353]##Java EE Security API 1.0

[#50581515_pgfId-1027355]##N

[#50581515_pgfId-1027357]##Y

[#50581515_pgfId-1027359]##Y

[#50581515_pgfId-1027361]##REQ

[#50581515_pgfId-1022717]##JSP Debugging 1.0

[#50581515_pgfId-1022719]##N

[#50581515_pgfId-1022721]##Y

[#50581515_pgfId-1022723]##N

[#50581515_pgfId-1022725]##REQ

[#50581515_pgfId-1022727]##JSTL 1.2

[#50581515_pgfId-1022729]##N

[#50581515_pgfId-1022731]##Y

[#50581515_pgfId-1022733]##N

[#50581515_pgfId-1022735]##REQ

[#50581515_pgfId-1022737]##Web Services Metadata 2.1

[#50581515_pgfId-1022739]##Y

[#50581515_pgfId-1022741]##Y

[#50581515_pgfId-1022743]##Y

[#50581515_pgfId-1022745]##REQ

[#50581515_pgfId-1022747]##JSF 2.3

[#50581515_pgfId-1022749]##N

[#50581515_pgfId-1022751]##Y

[#50581515_pgfId-1022753]##N

[#50581515_pgfId-1022755]##REQ

[#50581515_pgfId-1022757]##Common Annotations 1.3

[#50581515_pgfId-1022759]##Y

[#50581515_pgfId-1022761]##Y

[#50581515_pgfId-1022763]##Y

[#50581515_pgfId-1022765]##REQ

[#50581515_pgfId-1022767]##Java Persistence 2.2

[#50581515_pgfId-1022769]##Y

[#50581515_pgfId-1022771]##Y

[#50581515_pgfId-1022773]##Y

[#50581515_pgfId-1022775]##REQ

[#50581515_pgfId-1022777]##Bean Validation 2.0

[#50581515_pgfId-1022779]##Y

[#50581515_pgfId-1022781]##Y

[#50581515_pgfId-1022783]##Y

[#50581515_pgfId-1022785]##REQ

[#50581515_pgfId-1022787]##Managed Beans 1.0

[#50581515_pgfId-1022789]##Y

[#50581515_pgfId-1022791]##Y

[#50581515_pgfId-1022793]##Y

[#50581515_pgfId-1022795]##REQ

[#50581515_pgfId-1022797]##Interceptors 1.2

[#50581515_pgfId-1022799]##Y

[#50581515_pgfId-1022801]##Y

[#50581515_pgfId-1022803]##Y

[#50581515_pgfId-1022805]##REQ

[#50581515_pgfId-1022807]##Contexts and Dependency Injection for Java EE
2.0

[#50581515_pgfId-1022809]##Y

[#50581515_pgfId-1022811]##Y

[#50581515_pgfId-1022813]##Y

[#50581515_pgfId-1022815]##REQ

[#50581515_pgfId-1022817]##Dependency Injection for Java 1.0

[#50581515_pgfId-1022819]##Y

[#50581515_pgfId-1022821]##Y

[#50581515_pgfId-1022823]##Y

[#50581515_pgfId-1022825]##REQ

{empty}[#50581515_pgfId-999934]##All classes and interfaces required by
the specifications for the APIs must be provided by the Java EE
containers indicated above. In some cases, a Java EE product is not
required to provide objects that implement interfaces intended to be
implemented by an application server, nevertheless, the definitions of
such interfaces must be included in the Java EE platform. If an
implementation includes support for a technology marked as Optional,
that technology must be supported in the containers specified above. If
a product implementation does not support a technology marked as
Optional, it must not include the APIs for that
technology.link:#pgfId-1024346[18]

======= [#50581515_pgfId-1019577]##[#50581515_20153]##Pruned Java Technologies

[#50581515_pgfId-1019578]##As the Java EE specification has evolved,
some of the technologies originally included in Java EE are no longer as
relevant as they were when they were introduced to the platform. The
Java EE expert group follows a process first defined by the Java SE
expert group ( _http://mreinhold.org/blog/removing-features_ ) to prune
technologies from the platform in a careful and orderly way that
minimizes the impact to developers using these technologies, while
allowing the platform to grow even stronger. In short, the process
defines two steps:

[#50581515_pgfId-1019593]## 

. [#50581515_pgfId-1019581]##The Umbrella Expert Group (UEG) for release
N of the platform decides to propose that a particular feature be
removed. The specification for that release documents the proposal.
. [#50581515_pgfId-1019582]##The UEG for release N+1 decides whether to
remove the feature from that release, retain it as a required component,
or leave it in the "proposed removal" state for the next UEG to decide.

[#50581515_pgfId-1019583]## 

[#50581515_pgfId-1019579]##The result of successfully applying this
policy to a feature is not the actual deletion of the feature but rather
the conversion of the feature from a required component of the platform
into an optional component. No actual removal from the specification
occurs, although the feature may be removed from products at the choice
of the product vendor.

[#50581515_pgfId-1019598]##Technologies that have been pruned as of Java
EE 8 are marked Optional in
link:JavaEE_Platform_Spec.htm#50581515_TABLE%206-1[See Java EE
Technologies]. Technologies that may be pruned in a future release are
marked Proposed Optional in
link:JavaEE_Platform_Spec.htm#50581515_TABLE%206-1[See Java EE
Technologies].

==== [#50581515_pgfId-6979]##[#50581515_98360]##Java Platform, Standard Edition (Java SE) Requirements

======= [#50581515_pgfId-6980]##[#50581515_62473]##Programming Restrictions

[#50581515_pgfId-1003294]## _The_ Java EE _programming model divides
responsibilities between Application Component Providers and_ Java EE
_Product Providers: Application Component Providers focus on writing
business logic and the_ Java EE _Product Providers focus on providing a
managed system infrastructure in which the application components can be
deployed._

[#50581515_pgfId-1006084]## _This division leads to a restriction on the
functionality that application components can contain. If application
components contain the same functionality provided by Java EE system
infrastructure, there are clashes and mis-management of the
functionality._

[#50581515_pgfId-1006075]## _For example, if enterprise beans were
allowed to manage threads, the_ Java EE _platform could not manage the
life cycle of the enterprise beans, and it could not properly manage
transactions._

[#50581515_pgfId-1000581]##Since we do not want to subset the Java SE
platform, and we want Java EE Product Providers to be able to use Java
SE products without modification in the Java EE platform, we use the
Java SE security permissions mechanism to express the programming
restrictions imposed on Application Component Providers.

[#50581515_pgfId-1024371]##In this section, we specify the Java SE
security permissions that the Java EE Product Provider must provide for
each application component type. We call these permissions the Java EE
security permissions set. The Java EE security permissions set is a
required part of the Java EE API contract. We also specify the set of
permissions that the Java EE Product Provider must be able to restrict
from being provided to application components. In addition, we specify
the means by which application component providers may declare the need
for specific permissions and how these declarations must be processed by
Java EE products.

[#50581515_pgfId-1024387]##The Java SE security permissions are fully
described in
_http://docs.oracle.com/javase/8/docs/technotes/guides/security/permissions.html_
.

======= [#50581515_pgfId-1006088]##[#50581515_18341]##Java EE Security Manager Related Requirements

[#50581515_pgfId-1024426]##Every Java EE product must be capable of
running with a Java security manager that enforces Java security
permissions and that prevents application components from performing
operations for which they have not been provided the required
permissions.

======= [#50581515_pgfId-1024429]##Java EE Product Provider’s Responsibilities

[#50581515_pgfId-1025429]##A Java EE product may allow application
components to run without a security manager, but every Java EE product
must be capable of running application components with a security
manager that enforces security permissions, as described below.

[#50581515_pgfId-1024457]##The set of security permissions provided to
application components by a particular installation is a matter of
policy outside the scope of this specification, however, every Java EE
product must be capable of running with a configuration that provides
application classes and packaged libraries the permissions defined in
link:JavaEE_Platform_Spec.htm#50581515_15027[See Java EE Security
Permissions Set].

[#50581515_pgfId-1024487]##All Java EE products must allow the set of
permissions available to application classes in a module to be
configurable, providing application components in some modules with
different permissions than those described in
link:JavaEE_Platform_Spec.htm#50581515_15027[See Java EE Security
Permissions Set].

[#50581515_pgfId-1024505]##As defined in
link:JavaEE_Platform_Spec.htm#50581515_61934[See Declaring Permissions
Required by Application Components],” a component provider may declare
the permissions required by the application classes and libraries
packaged in a module. When a component provider has declared the
permissions required by a module, on successful deployment of the
module, at least the declared permissions must have been granted to the
application classes and libraries packaged in the module. If security
permissions are declared that conflict with the policy of the product
installation, the Java EE product must fail deployment of the
application module. If an application module does not contain a
declaration of required security permissions and deployment otherwise
succeeds, the Java EE product must grant the application classes and
libraries the permissions established by the security policy of the
installation. The Java EE product must ensure that the system
administrator for the installation be able to define the security policy
for the installation to include the permissions in
link:JavaEE_Platform_Spec.htm#50581515_15027[See Java EE Security
Permissions Set].

[#50581515_pgfId-1024551]##Note that, on some installations of Java EE
products, the security policy of the installation may be such that
applications are granted fewer permissions than those defined in
link:JavaEE_Platform_Spec.htm#50581515_15027[See Java EE Security
Permissions Set] and, as a result, some applications that declare only
the permissions defined in
link:JavaEE_Platform_Spec.htm#50581515_15027[See Java EE Security
Permissions Set] may not be deployable. Other applications that require
the same permissions but do not declare them may deploy but will
encounter runtime failures when the missing permission is required by
the application component.

[#50581515_pgfId-1024578]##Every Java EE product must be capable of
running with a Java security manager and with an installation policy
that does not grant the permissions described in
link:JavaEE_Platform_Spec.htm#50581515_93111[See Restrictable Java EE
Security Permissions] to Web, EJB, and resource adapter components. That
environment must otherwise fully support the requirements of this
specification.

======= [#50581515_pgfId-1024548]##Application Component Provider’s Responsibilities

[#50581515_pgfId-1025332]##To ensure that application deployment will
only succeed if required permissions are compatible with security policy
of the installation environment, application component providers should
declare all Java security permissions required by their application
components.

[#50581515_pgfId-1025358]##link:JavaEE_Platform_Spec.htm#50581515_61934[See
Declaring Permissions Required by Application Components],” defines the
mechanism(s) by which required permissions may be declared.

[#50581515_pgfId-1025359]##Note that, while FilePermissions or
SocketPermissions for specific resources may be granted as a result of
application components declaring them as required, the local operating
system or network security policy may restrict access to the requested
resources. This may result in a runtime failure to access these
resources even though deployment of the application has succeeded.

======= [#50581515_pgfId-1025325]##System Administrator’s Responsibilities

[#50581515_pgfId-1024598]##Security policy requirements differ from one
installation environment to another. The system administrator is
responsible for configuring the permissions available to application
modules to meet the security policy requirements of the installation
environment. For example, cloud environments may require greater
restrictions on the system resources available to applications than
on-premise enterprise installations. Note that restricting the
permissions beyond those in
link:JavaEE_Platform_Spec.htm#50581515_15027[See Java EE Security
Permissions Set] may prevent some applications from working correctly.

[#50581515_pgfId-1024647]##Care should be taken by the system
administrator to ensure that resources that are expected to be available
to application components are appropriately represented in the security
policy of the operational environment.

[#50581515_pgfId-1024664]##In particular, the temporary file directory
made available through the ServletContext attribute
_javax.servlet.context.tempdir_ should be available to deployed
applications. The security policy of the operational environment should
grant the application server process access to the corresponding part of
the file system. The Java EE Product must be capable of using the
security manager to enforce that an application only has access to the
part of the filesystem namespace named by the
_javax.security.context.tempdir_ attribute, and that that part of the
filesystem namespace is separate from the corresponding filesystem
namespace available to other applications.

======= [#50581515_pgfId-1024661]##Listing of the Java EE Security Permissions Set

[#50581515_pgfId-1024698]##link:JavaEE_Platform_Spec.htm#50581515_15027[See
Java EE Security Permissions Set] lists the Java permissions that Java
EE components (by type) can reliably be granted by a Java EE product,
given appropriate local installation configuration.

======= [#50581515_pgfId-1002638]##[#50581515_15027]##Java EE Security Permissions Set

[#50581515_pgfId-1002644]##[#50581515_94812]##Security Permissions

[#50581515_pgfId-1002646]##Target

[#50581515_pgfId-1002648]##Action

[#50581515_pgfId-1002650]##Application Clients

[#50581515_pgfId-1002652]## 

[#50581515_pgfId-1002654]## 

[#50581515_pgfId-1002656]## _java.awt.AWTPermission_

[#50581515_pgfId-1002658]##accessClipboard

[#50581515_pgfId-1002660]## 

[#50581515_pgfId-1002662]## _java.awt.AWTPermission_

[#50581515_pgfId-1002664]##accessEventQueue

[#50581515_pgfId-1002666]## 

[#50581515_pgfId-1002680]## _java.awt.AWTPermission_

[#50581515_pgfId-1004016]##showWindowWithout

[#50581515_pgfId-1006408]##WarningBanner

[#50581515_pgfId-1002684]## 

[#50581515_pgfId-1002794]## _java.lang.RuntimePermission_

[#50581515_pgfId-1002790]##exitVM

[#50581515_pgfId-1002792]## 

[#50581515_pgfId-1002686]## _java.lang.RuntimePermission_

[#50581515_pgfId-1002688]##loadLibrary.*

[#50581515_pgfId-1002690]## 

[#50581515_pgfId-1002692]## _java.lang.RuntimePermission_

[#50581515_pgfId-1002694]##queuePrintJob

[#50581515_pgfId-1002696]## 

[#50581515_pgfId-1002698]## _java.net.SocketPermission_

[#50581515_pgfId-1002700]##*

[#50581515_pgfId-1002702]##connect

[#50581515_pgfId-1002850]## _java.net.SocketPermission_

[#50581515_pgfId-1002852]##localhost:1024-

[#50581515_pgfId-1002854]##accept,listen

[#50581515_pgfId-1002704]## _java.io.FilePermission_

[#50581515_pgfId-1002706]##*

[#50581515_pgfId-1002708]##read,write

[#50581515_pgfId-1002710]## _java.util.PropertyPermission_

[#50581515_pgfId-1002712]##*

[#50581515_pgfId-1002714]##read

[#50581515_pgfId-1002716]##Applet Clients

[#50581515_pgfId-1002718]## 

[#50581515_pgfId-1002720]## 

[#50581515_pgfId-1002722]## _java.net.SocketPermission_

[#50581515_pgfId-1002724]## _codebase_

[#50581515_pgfId-1002726]##connect

[#50581515_pgfId-1002728]## _java.util.PropertyPermission_

[#50581515_pgfId-1002730]## _limited_

[#50581515_pgfId-1002732]##read

[#50581515_pgfId-1002734]##Web, EJB, and Resource Adapter

[#50581515_pgfId-1026109]##Components

[#50581515_pgfId-1002736]## 

[#50581515_pgfId-1002738]## 

[#50581515_pgfId-1002740]## _java.lang.RuntimePermission_

[#50581515_pgfId-1002742]##loadLibrary.*

[#50581515_pgfId-1002744]## 

[#50581515_pgfId-1002746]## _java.lang.RuntimePermission_

[#50581515_pgfId-1002748]##queuePrintJob

[#50581515_pgfId-1002750]## 

[#50581515_pgfId-1002752]## _java.net.SocketPermission_

[#50581515_pgfId-1002754]##*

[#50581515_pgfId-1002756]##connect

[#50581515_pgfId-1002758]## _java.io.FilePermission_

[#50581515_pgfId-1002760]##*

{empty}[#50581515_pgfId-1002762]##read,write link:#pgfId-1024756[19]

[#50581515_pgfId-1024759]##java.io.FilePermission

[#50581515_pgfId-1024761]##file:$\{javax.servlet.context.tempdir}

{empty}[#50581515_pgfId-1024763]##read, write link:#pgfId-1024771[20]

[#50581515_pgfId-1002764]## _java.util.PropertyPermission_

[#50581515_pgfId-1002766]##*

[#50581515_pgfId-1002768]##read

======= [#50581515_pgfId-1002303]##Restrictable Java EE Security Permissions

[#50581515_pgfId-1024779]##link:JavaEE_Platform_Spec.htm#50581515_93111[See
Restrictable Java EE Security Permissions] lists the Java permissions
that a Java EE product must be capable of restricting when running a Web
or EJB application component. If the Target field is empty, a Java EE
product must be capable of deploying application modules such that no
instances of that permission are granted to the components in the
application module.

[#50581515_pgfId-1024808]##  

======= [#50581515_pgfId-1024816]##[#50581515_93111]##Restrictable Java EE Security Permissions

[#50581515_pgfId-1024823]##Security Permissions

[#50581515_pgfId-1024825]##Target

[#50581515_pgfId-1024827]##Action

[#50581515_pgfId-1024914]##Web, EJB, and Resource Adapter Components

[#50581515_pgfId-1024916]## 

[#50581515_pgfId-1024918]## 

[#50581515_pgfId-1024974]##java.security.AllPermission

[#50581515_pgfId-1024976]## 

[#50581515_pgfId-1024978]## 

[#50581515_pgfId-1024980]##java.security.SecurityPermission

[#50581515_pgfId-1024982]## 

[#50581515_pgfId-1024984]## 

[#50581515_pgfId-1024986]##java.security.UnresolvedPermission

[#50581515_pgfId-1024988]## 

[#50581515_pgfId-1024990]## 

[#50581515_pgfId-1024992]##java.awt.AWTPermission

[#50581515_pgfId-1024994]## 

[#50581515_pgfId-1024996]## 

[#50581515_pgfId-1024998]##java.io.SerializablePermission

[#50581515_pgfId-1025000]## 

[#50581515_pgfId-1025002]## 

[#50581515_pgfId-1025004]##java.lang.reflect.ReflectPermission

[#50581515_pgfId-1025006]## 

[#50581515_pgfId-1025008]## 

[#50581515_pgfId-1024920]## _java.lang.RuntimePermission_

{empty}[#50581515_pgfId-1024922]##<any except loadLibrary.* and
queuePrintJob> link:#pgfId-1025010[21]

[#50581515_pgfId-1024924]## 

[#50581515_pgfId-1024926]## _java.net.NetPermission_

[#50581515_pgfId-1024928]## 

[#50581515_pgfId-1024930]## 

[#50581515_pgfId-1024932]## _java.sql.SQLPermission_

[#50581515_pgfId-1024934]## 

[#50581515_pgfId-1024936]## 

[#50581515_pgfId-1024956]## _java.util.PropertyPermission_

[#50581515_pgfId-1024958]##<any>

{empty}[#50581515_pgfId-1024960]##write link:#pgfId-1025028[22]

[#50581515_pgfId-1025067]##java.util.logging.LoggingPermission

[#50581515_pgfId-1025069]## 

[#50581515_pgfId-1025071]## 

[#50581515_pgfId-1025061]##javax.net.ssl.SSLPermission

[#50581515_pgfId-1025063]## 

[#50581515_pgfId-1025065]## 

[#50581515_pgfId-1025055]##java.security.auth.AuthPermission

[#50581515_pgfId-1025057]## 

[#50581515_pgfId-1025059]## 

[#50581515_pgfId-1025049]##java.security.auth.PrivateCredentialPermission

[#50581515_pgfId-1025051]## 

[#50581515_pgfId-1025053]## 

[#50581515_pgfId-1025043]##java.security.auth.kerberos.DelegationPermission

[#50581515_pgfId-1025045]## 

[#50581515_pgfId-1025047]## 

[#50581515_pgfId-1025037]##java.security.auth.kerberos.ServicePermission

[#50581515_pgfId-1025039]## 

[#50581515_pgfId-1025041]## 

[#50581515_pgfId-1025031]##javax.sound.sampled.AudioPermission

[#50581515_pgfId-1025033]## 

[#50581515_pgfId-1025035]## 

======= [#50581515_pgfId-1024775]##[#50581515_61934]##Declaring Permissions Required by Application Components

[#50581515_pgfId-1025105]##By declaring the permissions required by an
application as described in this section, an application component
provider is ensured, through the successful deployment of his or her
application, that the Java EE Product has granted at least the declared
permissions to the classes and libraries packaged in the application
module.

[#50581515_pgfId-1025133]##Since the specific set of permissions granted
to a successfully deployed application is a function of the security
policy for the installation and the permissions declared within the
_permissions.xml_ files, the application component provider is ensured
that the effective permission set consists of at least those permissions
that are declared within the application.

[#50581515_pgfId-1025154]##Permission declarations must be stored in
_META-INF/permissions.xml_ file within an EJB, web, application client,
or resource adapter archive in order for them to be located and
subsequently processed by the deployment machinery of the Java EE
Product. The Java EE Product is not required to support
_permissions.xml_ files that specify permission classes that are
packaged in the application.

[#50581515_pgfId-1025900]##The permissions for a packaged library are
the same as the permissions for the module. Thus, if a library is
packaged in a _.war_ file, it gets the permissions of the _.war_ file.

[#50581515_pgfId-1026077]##For applications packaged in an _.ear_ file,
the declaration of permissions must be at _.ear_ file level. This
permission set is applied to all modules and libraries packaged within
the _.ear_ file or within its contained modules. Any _permissions.xml_
files within such packaged modules are ignored, regardless of whether a
_permissions.xml_ file has been supplied for the _.ear_ file itself.

[#50581515_pgfId-1025173]##The fact that these permission declarations
are being made from within the context of a particular application
implies the codeBase(s) to which the grant should be made. This
simplifies the syntax that is needed to just the Permission class name
and two String arguments. This aligns the declaration syntax with the
default policy language and the constructor signature for permissions
that is compliant with the default policy syntax.

[#50581515_pgfId-1025205]## 

[#50581515_pgfId-1025211]##permission <class> [<name> [, <action
list>]];

[#50581515_pgfId-1026112]## 

[#50581515_pgfId-1026133]##The following is an example of a permission
set declaration:

[#50581515_pgfId-1026141]##...

[#50581515_pgfId-1026154]##<permissions>

[#50581515_pgfId-1026142]## <permission>

[#50581515_pgfId-1026143]##
<class-name>java.io.FilePermission</class-name>

[#50581515_pgfId-1026144]## <name>/tmp/abc</name>

[#50581515_pgfId-1026145]## <actions>read,write</actions>

[#50581515_pgfId-1026146]## </permission>

[#50581515_pgfId-1026147]## <permission>

[#50581515_pgfId-1026148]##
<class-name>java.lang.RuntimePermission</class-name>

[#50581515_pgfId-1026149]## <name>createClassLoader</name>

[#50581515_pgfId-1026150]## </permission>

[#50581515_pgfId-1026151]##</permissions>

[#50581515_pgfId-1026155]##...

[#50581515_pgfId-1026137]## 

[#50581515_pgfId-1026113]##The Java EE permissions XML Schema is located
at _http://xmlns.jcp.org/xml/ns/javaee/permissions_8.xsd_ .

======= [#50581515_pgfId-1025274]##Additional Requirements

======= [#50581515_pgfId-7509]##[#50581515_12091]##Networking

[#50581515_pgfId-7510]##The Java SE platform includes a pluggable
mechanism for supporting multiple URL protocols through the
_java.net.URLStreamHandler_ class and the
_java.net.URLStreamHandlerFactory_ interface.

[#50581515_pgfId-7511]##The following URL protocols must be supported:

* [#50581515_pgfId-7512]## _file_ _:_ Only reading from a _file_ URL
need be supported. That is, the corresponding _URLConnection_ object’s
_getOutputStream_ method may fail with an _UnknownServiceException_ .
File access is restricted according to the permissions described above.
* [#50581515_pgfId-7514]## _http_ _:_ Version 1.1 of the HTTP protocol
must be supported. An _http_ URL must support both input and output.
* [#50581515_pgfId-7516]## _https_ : SSL version 3.0 and TLS version 1.2
must be supported by _https_ URL objects. Both input and output must be
supported.

[#50581515_pgfId-7518]##The Java SE platform also includes a mechanism
for converting a URL’s byte stream to an appropriate object, using the
_java.net.ContentHandler_ class and _java.net.ContentHandlerFactory_
interface. A _ContentHandler_ object can convert a MIME byte stream to
an object. _ContentHandler_ objects are typically accessed indirectly
using the _getContent_ method of _URL_ and _URLConnection_ .

[#50581515_pgfId-7519]##When accessing data of the following MIME types
using the _getContent_ method, objects of the corresponding Java type
listed in _link:JavaEE_Platform_Spec.htm#50581515_23457[See Java Type of
Objects Returned When Using the getContent Method]_ must be returned.

======= [#50581515_pgfId-8107]##Java Type of Objects Returned When Using[#50581515_23457]## the getContent Method

[#50581515_pgfId-8111]##MIME Type

[#50581515_pgfId-8113]##Java Type

[#50581515_pgfId-8115]## _image/gif_

[#50581515_pgfId-8117]## _java.awt.Image_

[#50581515_pgfId-8119]## _image/jpeg_

[#50581515_pgfId-8121]## _java.awt.Image_

[#50581515_pgfId-1018714]## _image/png_

[#50581515_pgfId-1018716]## _java.awt.Image_

[#50581515_pgfId-7523]##Many environments will use HTTP proxies rather
than connecting directly to HTTP servers. If HTTP proxies are being used
in the local environment, the HTTP support in the Java SE platform
should be configured to use the proxy appropriately. Application
components must not be required to configure proxy support in order to
use an _http_ URL.

[#50581515_pgfId-1002549]##Most enterprise environments will include a
firewall that limits access from the internal network (intranet) to the
public Internet, and vice versa. It is typical for access using the HTTP
protocol to pass through such firewalls, perhaps by using proxy servers.
It is not typical that general TCP/IP traffic, including RMI-JRMP, and
RMI-IIOP, can pass through firewalls.

[#50581515_pgfId-1006172]##These considerations have implications on the
use of various protocols to communicate between application components.
This specification requires that HTTP access through firewalls be
possible where local policy allows. Some Java EE products may provide
support for tunneling other communication through firewalls, but this is
neither specified nor required. Application developers should consider
the impact of these issues in the design of applications, particularly
in view of cloud environments, where a cloud platform provider might
only allow HTTP-based access.

======= [#50581515_pgfId-7526]##[#50581515_57630]##JDBC™ API

[#50581515_pgfId-7527]##The JDBC API, which is part of the Java SE
platform, allows for access to a wide range of data storage systems. The
Java SE platform, however, does not require that a system meeting the
Java Compatible™ quality standards provide a database that is accessible
through the JDBC API.

[#50581515_pgfId-1006187]##To allow for the development of portable
applications, the Java EE specification does require that such a
database be available and accessible from a Java EE product through the
JDBC API. Such a database must be accessible from web components,
enterprise beans, and application clients, but need not be accessible
from applets. In addition, the driver for the database must meet the
JDBC Compatible requirements in the JDBC specification.

[#50581515_pgfId-1000473]##Java EE applications should not attempt to
load JDBC drivers directly. Instead, they should use the technique
recommended in the JDBC specification and perform a JNDI lookup to
locate a _DataSource_ object. The JNDI name of the _DataSource_ object
should be chosen as described in
link:JavaEE_Platform_Spec.htm#50581511_11574[See Resource Manager
Connection Factory References].” The Java EE platform must be able to
supply a _DataSource_ that does not require the application to supply
any authentication information when obtaining a database connection. Of
course, applications may also supply a user name and password when
connecting to the database.

[#50581515_pgfId-1006222]##When a JDBC API connection is used in an
_enterprise bean_ , the transaction characteristics will typically be
controlled by the container. The component should not attempt to change
the transaction characteristics of the connection, commit the
transaction, roll back the transaction, or set autocommit mode. Attempts
to make changes that are incompatible with the current transaction
context may result in a _SQLException_ being thrown. The EJB
specification contains the precise rules for _enterprise beans._

[#50581515_pgfId-1006388]##Note that the same restrictions apply when a
component creates a transaction using the JTA _UserTransaction_
interface. The component should not attempt the operations listed above
on the JDBC _Connection_ object that would conflict with the transaction
context.

[#50581515_pgfId-1019545]##Drivers supporting the JDBC API in a Java EE
environment must meet the JDBC API Compliance requirements as specified
in the JDBC specification.

[#50581515_pgfId-1016817]##The JDBC API includes APIs for connection
naming via JNDI, connection pooling, and distributed transaction
support. The connection pooling and distributed transaction features are
intended for use by JDBC drivers to coordinate with an application
server. Java EE products are not required to support the application
server facilities described by these APIs, although they may prove
useful.

[#50581515_pgfId-1027450]##The Connector architecture defines an SPI
that essentially extends the functionality of the JDBC SPI with
additional security functionality, and a full packaging and deployment
functionality for resource adapters. A Java EE product that supports the
Connector architecture must support deploying and using a JDBC driver
that has been written and packaged as a resource adapter using the
Connector architecture.

[#50581515_pgfId-1027451]##The JDBC 4.2 specification is available at
_https://jcp.org/en/jsr/detail?id=221_ .

======= [#50581515_pgfId-1027453]##[#50581515_47538]##Java™ API for XML Web Services (JAX-WS) Requirements

[#50581515_pgfId-1027320]##The JAX-WS specification provides support for
web services that use the JAXB API for binding XML data to Java objects.
The JAX-WS specification defines client APIs for accessing web services
as well as techniques for implementing web service endpoints. The Web
Services for Java EE specification describes the deployment of
JAX-WS-based services and clients. The EJB and Servlet specifications
also describe aspects of such deployment. It must be possible to deploy
JAX-WS-based applications using any of these deployment models.

[#50581515_pgfId-1027321]##The JAX-WS specification describes the
support for message handlers that can process message requests and
responses. In general, these message handlers execute in the same
container and with the same privileges and execution context as the
JAX-WS client or endpoint component with which they are associated.
These message handlers have access to the same JNDI _java:comp/env_
namespace as their associated component. Custom serializers and
deserializers, if supported, are treated in the same way as message
handlers.

[#50581515_pgfId-1027322]##The JAX-WS specification is available at
_http://jcp.org/en/jsr/summary?id=224_ .

======= [#50581515_pgfId-1001992]##[#50581515_92423]##Java IDL (Proposed Optional)

[#50581515_pgfId-1003184]##The requirements in this section only apply
to Java EE products that support interoperability using CORBA.

[#50581515_pgfId-1020480]##Java IDL allows applications to access any
CORBA object, written in any language, using the standard IIOP protocol.
The Java EE security restrictions typically prevent all application
component types except application clients from creating and exporting a
CORBA object, but all Java EE application component types can be clients
of CORBA objects.

[#50581515_pgfId-1004757]##A Java EE product must support Java IDL as
defined by chapters 1 - 8, 13, and 15 of the CORBA 2.3.1 specification,
available at _http://www.omg.org/cgi-bin/doc?formal/99-10-07_ , and the
IDL To Java Language Mapping Specification, available at
_http://www.omg.org/cgi-bin/doc?ptc/2000-01-08_ .

[#50581515_pgfId-1017076]##The IIOP protocol supports the ability to
multiplex calls over a single connection. All Java EE products must
support requests from clients that multiplex calls on a connection to
either Java IDL server objects or RMI-IIOP server objects (such as
enterprise beans). The server must allow replies to be sent in any
order, to avoid deadlocks where one call would be blocked waiting for
another call to complete. Java EE clients are not required to multiplex
calls, although such support is highly recommended.

[#50581515_pgfId-1018085]##A Java EE product must provide support for a
CORBA Portable Object Adapter (POA) to support portable stub, skeleton,
and tie classes. A Java EE application that defines or uses CORBA
objects other than enterprise beans must include such portable stub,
skeleton, and tie classes in the application package.

[#50581515_pgfId-1004877]##Java EE applications need to use an instance
of _org.omg.CORBA.ORB_ to perform many Java IDL and RMI-IIOP operations.
The default ORB returned by a call to _ORB.init(new String[0], null)_
must be usable for such purposes; an application need not be aware of
the implementation classes used for the ORB and RMI-IIOP support.

[#50581515_pgfId-1004949]##In addition, for performance reasons it is
often advantageous to share an ORB instance among components in an
application. To support such usage, all web, enterprise bean, and
application client containers are required to provide an ORB instance in
the JNDI namespace under the name _java:comp/ORB_ . The container is
allowed, but not required, to share this instance between components.
The container may also use this ORB instance itself. To support
isolation between applications, an ORB instance should not be shared
between components in different applications. To allow this ORB instance
to be safely shared between components, portable components must
restrict their usage of certain ORB APIs and functionality:

* [#50581515_pgfId-1004960]##Do not call the ORB _shutdown_ method.
* [#50581515_pgfId-1004961]##Do not call the _org.omg.CORBA_2_3.ORB_
methods _register_value_factory_ and _unregister_value_factory_ with an
_id_ used by the container.

[#50581515_pgfId-1004687]##A Java EE product must provide a COSNaming
service to support the EJB interoperability requirements. It must be
possible to access this COSNaming service using the Java IDL COSNaming
APIs. Applications with appropriate privileges must be able to lookup
objects in the COSNaming service. COSNaming is defined in the
Interoperable Naming Service specification, available at
_http://www.omg.org/cgi-bin/doc?formal/2000-06-19_ .

======= [#50581515_pgfId-1003196]##RMI-JRMP

[#50581515_pgfId-1004721]##JRMP is the Java technology-specific Remote
Method Invocation (RMI) protocol. The Java EE security restrictions
typically prevent all application component types except application
clients from creating and exporting an RMI object, but all Java EE
application component types can be clients of RMI objects.

======= [#50581515_pgfId-1004163]##[#50581515_13978]##RMI-IIOP (Proposed Optional)

[#50581515_pgfId-1004168]##The requirements in this section only apply
to Java EE products that include an EJB container and support
interoperability using RMI-IIOP.

[#50581515_pgfId-1020484]##RMI-IIOP allows objects defined using RMI
style interfaces to be accessed using the IIOP protocol. It must be
possible to make any remote _enterprise bean accessible via_ RMI-IIOP.
Some Java EE products will simply make all remote enterprise beans
always (and only) accessible via RMI-IIOP; other products might control
this via an administrative or deployment action. These and other
approaches are allowed, provided that any remote enterprise bean (or by
extension, all remote enterprise beans) can be made accessible using
RMI-IIOP.

[#50581515_pgfId-1004595]##Components accessing remote _enterprise
beans_ may need to use the _narrow_ method of the
_javax.rmi.PortableRemoteObject_ class, under circumstances described in
the EJB specification. Because remote enterprise beans may be deployed
using other RMI protocols, portable applications must not depend on the
characteristics of RMI-IIOP objects (for example, the use of the _Stub_
and _Tie_ base classes) beyond what is specified in the EJB
specification.

[#50581515_pgfId-1006246]##The Java EE security restrictions typically
prevent all application component types, except application clients,
from creating and exporting an RMI-IIOP object. All Java EE application
component types can be clients of RMI-IIOP objects. Java EE applications
should also use JNDI to lookup non-EJB RMI-IIOP objects. The JNDI names
used for such non-EJB RMI-IIOP objects should be configured at
deployment time using the standard environment entries mechanism (see
link:JavaEE_Platform_Spec.htm#50581511_50670[See JNDI Naming Context]”).
The application should fetch a name from JNDI using an environment
entry, and use the name to lookup the RMI-IIOP object. Typically such
names will be configured to be names in the COSNaming name service.

[#50581515_pgfId-1004811]##This specification does not provide a
portable way for applications to bind objects to names in a name
service. Some products may support use of JNDI and COSNaming for binding
objects, but this is not required. Portable Java EE application clients
can create non-EJB RMI-IIOP server objects for use as callback objects,
or to pass in calls to other RMI-IIOP objects.

[#50581515_pgfId-1004402]##Note that while RMI-IIOP doesn’t specify how
to propagate the current security context or transaction context, the
EJB interoperability specification does define such context propagation.
This specification only requires that the propagation of context
information as defined in the EJB specification be supported in the use
of RMI-IIOP to access enterprise beans. The propagation of context
information is not required in the uses of RMI-IIOP to access objects
other than enterprise beans.

[#50581515_pgfId-1018101]##The RMI-IIOP specification describes how
portable Stub and _Tie_ classes can be created. To be portable to all
implementations that use a CORBA Portable Object Adapter (POA), the
_Tie_ classes must extend the _org.omg.PortableServer.Servant_ class.
This is typically done by using the _-poa_ option to the _rmic_ command.
A Java EE product must provide support for these portable _Stub_ and
_Tie_ classes, typically using the required CORBA POA. However, for
portability to systems that do not use a POA to implement RMI-IIOP,
applications should not depend on the fact that the _Tie_ extends the
_Servant_ class. A Java EE application that defines or uses RMI-IIOP
objects other than enterprise beans must include such portable _Stub_
and _Tie_ classes in the application package. _Stub_ and _Tie_ objects
for enterprise beans, however, must not be included with the
application: they will be generated, if needed, by the Java EE product
at deployment time or at run time.

[#50581515_pgfId-1004663]##RMI-IIOP is defined by chapters 5, 6, 13, 15,
and section 10.6.2 of the CORBA 2.3.1 specification, available at
_http://www.omg.org/cgi-bin/doc?formal/99-10-07_ , and by the Java™
Language To IDL Mapping Specification, available at
_http://www.omg.org/cgi-bin/doc?ptc/2000-01-06_ .

======= [#50581515_pgfId-1004292]##[#50581515_90330]##JNDI

[#50581515_pgfId-1004296]##A Java EE product that supports the following
types of objects must be able to make them available in the
application’s JNDI namespace: _EJBHome_ objects, _EJBLocalHome_ objects,
EJB business interface objects, JTA _UserTransaction_ objects, JDBC API
_DataSource_ objects, JMS _ConnectionFactory_ and _Destination_ objects,
JavaMail _Session_ objects, _URL_ objects, resource manager
_ConnectionFactory_ objects (as specified in the Connector
specification), _ORB_ objects, _EntityManagerFactory_ objects, and other
Java language objects as described in
link:JavaEE_Platform_Spec.htm#50581511_16122[See Resources, Naming, and
Injection].” The JNDI implementation in a Java EE product must be
capable of supporting all of these uses in a single application
component using a single JNDI _InitialContext_ . Application components
will generally create a JNDI _InitialContext_ using the default
constructor with no arguments. The application component may then
perform lookups on that _InitialContext_ to find objects as specified
above.

[#50581515_pgfId-1004303]##The names used to perform lookups for Java EE
objects are application dependent. The application component’s metadata
annotations and/or deployment descriptor are used to list the names and
types of objects expected. The Deployer configures the JNDI namespace to
make appropriate components available. The JNDI names used to lookup
such objects must be in the JNDI _java:_ namespace. See
link:JavaEE_Platform_Spec.htm#50581511_16122[See Resources, Naming, and
Injection]” for details.

[#50581515_pgfId-1004307]##Particular names are defined by this
specification for the cases when the Java EE product includes the
corresponding technology. For all application components that have
access to the JTA _UserTransaction_ interface, the appropriate
_UserTransaction_ object can be found using the name
_java:comp/UserTransaction_ . In all containers except the applet
container, application components may lookup a CORBA _ORB_ instance
using the name _java:comp/ORB_ . For all application components that
have access to the CDI _BeanManager_ interface, the appropriate
_BeanManager_ object can be found using the name _java:comp/BeanManager_
. For all application components that have access to the Validation
APIs, the appropriate _Validator_ and _ValidatorFactory_ objects can be
found using the names _java:comp/Validator_ and
_java:comp/ValidatorFactory_ respectively.

[#50581515_pgfId-1004311]##The name used to lookup a particular Java EE
object may be different in different application components. In general,
JNDI names can not be meaningfully passed as arguments in remote calls
from one application component to another remote component (for example,
in a call to an _enterprise bean_ ).

[#50581515_pgfId-1004312]##The JNDI _java:_ namespace is commonly
implemented as symbolic links to other naming systems. Different
underlying naming services may be used to store different kinds of
objects, or even different instances of objects. It is up to a Java EE
product to provide the necessary JNDI service providers for accessing
the various objects defined in this specification.

[#50581515_pgfId-1006288]##This specification requires that the Java EE
platform provide the ability to perform lookup operations as described
above. Different JNDI service providers may provide different
capabilities, for instance, some service providers may provide only
read-only access to the data in the name service.

[#50581515_pgfId-1006291]##A Java EE product may be required to provide
a COSNaming name service to meet the EJB interoperability requirements.
In such a case, a COSNaming JNDI service provider must be available
through the web, EJB, and application client containers. It will also
typically be available in the applet container, but this is not
required.

[#50581515_pgfId-1006292]##A COSNaming JNDI service provider is a part
of the Java SE 8 SDK and JRE from Oracle, but is not a required
component of the Java SE specification. The COSNaming JNDI service
provider specification is available at
_http://docs.oracle.com/javase/8/docs/technotes/guides/jndi/jndi-cos.html_
.

[#50581515_pgfId-1004326]##See
link:JavaEE_Platform_Spec.htm#50581511_16122[See Resources, Naming, and
Injection]” for the complete naming requirements for the Java EE
platform. The JNDI specification is available at
_http://docs.oracle.com/javase/8/docs/technotes/guides/jndi/index.html_
.

======= [#50581515_pgfId-1016403]##[#50581515_77543]##Context Class Loader

[#50581515_pgfId-1016406]##This specification requires that Java EE
containers provide a per thread context class loader for the use of
system or library classes in dynamically loading classes provided by the
application. The EJB specification requires that all EJB client
containers provide a per thread context class loader for dynamically
loading system value classes. The per thread context class loader is
accessed using the _Thread_ method _getContextClassLoader_ .

[#50581515_pgfId-1016408]##The classes used by an application will
typically be loaded by a hierarchy of class loaders. There may be a top
level application class loader, an extension class loader, and so on,
down to a system class loader. The top level application class loader
delegates to the lower class loaders as needed. Classes loaded by lower
class loaders, such as portable EJB system value classes, need to be
able to discover the top level application class loader used to
dynamically load application classes.

[#50581515_pgfId-1016410]##This specification requires that containers
provide a per thread context class loader that can be used to load top
level application classes as described above. See
link:JavaEE_Platform_Spec.htm#50581519_59174[See Dynamic Class Loading]”
for recommendations for libraries that dynamically load classes.

======= [#50581515_pgfId-1016869]##Java™ Authentication and Authorization Service (JAAS) Requirements

[#50581515_pgfId-1016870]##All EJB containers and all web containers
must support the use of the JAAS APIs as specified in the Connector
specification. All application client containers must support use of the
JAAS APIs as specified in
link:JavaEE_Platform_Spec.htm#50581520_24744[See Application Clients].”

[#50581515_pgfId-1016874]##A reference guide to the JAAS APIs is
available at
_http://docs.oracle.com/javase/8/docs/technotes/guides/security/jaas/JAASRefGuide.html_
.

======= [#50581515_pgfId-1016785]##[#50581515_10389]##Logging API Requirements

[#50581515_pgfId-1017281]##The Logging API provides classes and
interfaces in the _java.util.logging_ package that are the Java™
platform’s core logging facilities. This specification does not require
any additional support for logging. A Java EE application typically will
not have the _LoggingPermission_ necessary to control the logging
configuration, but may use the logging API to produce log records. A
future version of this specification may require that the Java EE
containers use the logging API to log certain events.

======= [#50581515_pgfId-1017282]##[#50581515_72318]##Preferences API Requirements

[#50581515_pgfId-1017307]##The Preferences API in the _java.util.prefs_
package allows applications to store and retrieve user and system
preference and configuration data. A Java EE application typically will
not have the _RuntimePermission("preferences")_ necessary to use the
Preferences API. This specification does not define any relationship
between the principal used by a Java EE application and the user
preferences tree defined by the Preferences API. A future version of
this specification may define the use of the Preferences API by Java EE
applications.

==== [#50581515_pgfId-1004138]##[#50581515_88234]##Enterprise JavaBeans™ (EJB) 3.2 Requirements

[#50581515_pgfId-1004139]##This specification requires that a Java EE
product provide support for _enterprise beans_ as specified in the EJB
specification. The EJB specification is available at
_http://jcp.org/en/jsr/summary?id=345_ .

[#50581515_pgfId-1004193]##This specification does not impose any
additional requirements at this time. Note that the EJB specification
includes the specification of the EJB interoperability protocol based on
RMI-IIOP. Support for the EJB interoperability protocol is Proposed
Optional in Java EE 8. All containers that support EJB clients must be
capable of using the EJB interoperability protocol to invoke enterprise
beans. All EJB containers must support the invocation of enterprise
beans using the EJB interoperability protocol. A Java EE product may
also support other protocols for the invocation of enterprise beans.

[#50581515_pgfId-1004929]##A Java EE product may support multiple object
systems (for example, RMI-IIOP and RMI-JRMP). It may not always be
possible to pass object references from one object system to objects in
another object system. However, when an enterprise bean is using the
RMI-IIOP protocol, it must be possible to pass object references for
RMI-IIOP or Java IDL objects as arguments to methods on such an
enterprise bean, and to return such object references as return values
of a method on such an enterprise bean. In addition, it must be possible
to pass a reference to an RMI-IIOP-based enterprise bean’s Home or
Remote interface to a method on an RMI-IIOP or Java IDL object, or to
return such an enterprise bean object reference as a return value from
such an RMI-IIOP or Java IDL object.

[#50581515_pgfId-1006663]##In a Java EE product that includes both an
EJB container and a web container, both containers are required to
support access to local enterprise beans. No support is provided for
access to local enterprise beans from the application client container
or the applet container.

==== [#50581515_pgfId-1004198]##[#50581515_76686]##Servlet 4.0 Requirements

[#50581515_pgfId-1002313]##The Servlet specification defines the
packaging and deployment of web applications, whether standalone or as
part of a Java EE application. The Servlet specification also addresses
security, both standalone and within the Java EE platform. These
optional components of the Servlet specification are requirements of the
Java EE platform.

[#50581515_pgfId-1006319]##The Servlet specification includes additional
requirements for web containers that are part of a Java EE product and a
Java EE product must meet these requirements as well.

[#50581515_pgfId-1004609]##The Servlet specification defines
distributable web applications. To support Java EE applications that are
distributable, this specification adds the following requirements.

[#50581515_pgfId-1017148]##Web containers must support Java EE
distributable web applications placing objects of any of the following
types (when supported by the Java EE product) into a
_javax.servlet.http.HttpSession_ object using the _setAttribute_ or
_putValue_ methods:

======= [#50581515_pgfId-1017149]##j _ava.io.Serializable_

* [#50581515_pgfId-1004615]## _javax.ejb.EJBObject_
* [#50581515_pgfId-1004616]## _javax.ejb.EJBHome_
* [#50581515_pgfId-1017331]## _javax.ejb.EJBLocalObject_
* [#50581515_pgfId-1017332]## _javax.ejb.EJBLocalHome_
* [#50581515_pgfId-1004617]## _javax.transaction.UserTransaction_
* [#50581515_pgfId-1004618]##a _javax.naming.Context_ object for the
_java:comp/env_ context

======= [#50581515_pgfId-1019057]##a reference to an EJB local or remote business interface or no-interface view

[#50581515_pgfId-1004619]##Web containers may support objects of other
types as well. Web containers must throw a
_java.lang.IllegalArgumentException_ if an object that is not one of the
above types, or another type supported by the container, is passed to
the _setAttribute_ or _putValue_ methods of an _HttpSession_ object
corresponding to a Java EE distributable session. This exception
indicates to the programmer that the web container does not support
moving the object between VMs. A web container that supports multi-VM
operation must ensure that, when a session is moved from one VM to
another, all objects of supported types are accurately recreated on the
target VM.

[#50581515_pgfId-1006653]##The Servlet specification defines access to
local enterprise beans as an optional feature. This specification
requires that all Java EE products that include both a web container and
an EJB container provide support for access to local enterprise beans
from the web container.

[#50581515_pgfId-1002371]##The Servlet specification is available at
_http://jcp.org/en/jsr/detail?id=369_ .

==== [#50581515_pgfId-7546]##[#50581515_59650]##JavaServer Pages™ (JSP) 2.3 Requirements

[#50581515_pgfId-1002335]##The JSP specification depends on and builds
on the servlet framework. A Java EE product must support the entire JSP
specification.

[#50581515_pgfId-1003982]##The JSP specification is available at
_http://jcp.org/en/jsr/summary?id=245_ .

==== [#50581515_pgfId-1020057]##Expression Language (EL) 3.0 Requirements

[#50581515_pgfId-1020058]##The Expression Language specification was
formerly a part of the JavaServer Pages specification. It was split off
into its own specification so that it could be used independently of
JavaServer Pages. A Java EE product must support the Expression
Language.

[#50581515_pgfId-1020072]##The Expression Language specification is
available at _http://jcp.org/en/jsr/detail?id=341_ .

==== [#50581515_pgfId-1002556]##[#50581515_49152]##Java™ Message Service (JMS) 2.0 Requirements

[#50581515_pgfId-1002559]##A Java Message Service provider must be
included in a Java EE product that requires support for JMS. The JMS
implementation must provide support for both JMS point-to-point and
publish/subscribe messaging, and thus must make those facilities
available using the _ConnectionFactory_ and _Destination_ APIs.

[#50581515_pgfId-1004512]##The JMS specification defines several
interfaces intended for integration with an application server. A Java
EE product need not provide objects that implement these interfaces, and
portable Java EE applications must not use the following interfaces:

* [#50581515_pgfId-1004516]##j _avax.jms.ServerSession_
* [#50581515_pgfId-1004517]## _javax.jms.ServerSessionPool_
* [#50581515_pgfId-1004518]## _javax.jms.ConnectionConsumer_

======= [#50581515_pgfId-1004519]##all _javax.jms_ XA interfaces

[#50581515_pgfId-1004213]##The following methods may only be used by
application components executing in the application client container:

* [#50581515_pgfId-1006587]## _javax.jms.MessageConsumer_ method
_getMessageListener_
* [#50581515_pgfId-1006592]## _javax.jms.MessageConsumer_ method
_setMessageListener_
* [#50581515_pgfId-1026223]## _javax.jms.JMSConsumer_ method
_getMessageListener_
* [#50581515_pgfId-1026224]## _javax.jms.JMSConsumer_ method
_setMessageListener_
* [#50581515_pgfId-1006337]## _javax.jms.Connection_ method
_setExceptionListener_
* [#50581515_pgfId-1004504]## _javax.jms.Connection_ method _stop_
* [#50581515_pgfId-1004505]## _javax.jms.Connection_ method
_setClientID_
* [#50581515_pgfId-1022894]## _javax.jms.JMSContext_ method _stop_
* [#50581515_pgfId-1022901]## _javax.jms.JMSContext_ method
_setClientID_
* [#50581515_pgfId-1026398]## _javax.jms.JMSContext_ method
_setExceptionListener_
* [#50581515_pgfId-1026399]## _javax.jms.JMSContext_ method
_createContext_
* [#50581515_pgfId-1026409]## _javax.jms.Producer_ method _setAsync_
* [#50581515_pgfId-1026429]## _javax.jms.MessageProducer_ method
_send(Message_ _message, CompletionListener_ _completionListener)_
* [#50581515_pgfId-1026437]## _javax.jms.MessageProducer_ method
_send(Message_ _message,_ _int_ _deliveryMode,_ _int_ _priority,_ _long_
_timeToLive,_ _CompletionListener completionListener)_
* [#50581515_pgfId-1026444]## _javax.jms.MessageProducer_ method
_send(Destination_ _destination, Message_ _message,_
_CompletionListener_ _completionListener)_
* [#50581515_pgfId-1026449]## _javax.jms.MessageProducer_ method
_send(Destination_ _destination, Message_ _message,_ _int_
_deliveryMode,_ _int_ _priority,_ _long_ _timeToLive,
CompletionListener_ _completionListener)_

[#50581515_pgfId-1026400]##The following methods may only be used by
application components executing in the application client container.
Note, however, that these methods provide an expert facility not used by
ordinary applications. See the JMS specification for further detail.

======= [#50581515_pgfId-1022953]## _javax.jms.Session_ method _setMessageListener_

* [#50581515_pgfId-1022954]## _javax.jms.Session_ method
_getMessageListener_
* [#50581515_pgfId-1024369]## _javax.jms.Session_ method _run_
* [#50581515_pgfId-1022960]## _javax.jms.Connection_ method
_createConnectionConsumer_
* [#50581515_pgfId-1026257]## _javax.jms.Connection_ method
_createSharedConnectionConsumer_
* [#50581515_pgfId-1022961]## _javax.jms.Connection_ method
_createDurableConnectionConsumer_

======= [#50581515_pgfId-1026264]## _javax.jms.Connection_ method _createSharedDurableConnectionConsumer_

[#50581515_pgfId-1022949]##A Java EE container may throw a
_JMSException_ (if allowed by the method) or a _JMSRuntimeException_ (if
throwing a _JMSException_ is not allowed by the method) if the
application component violates any of the above restrictions.

[#50581515_pgfId-1017213]##Application components in the web and EJB
containers must not attempt to create more than one active (not closed)
_Session_ object per connection. An attempt to use the _Connection_
object’s _createSession_ method when an active _Session_ object exists
for that connection should be prohibited by the container. The container
should throw a _JMSException_ if the application component violates this
restriction. An attempt to use the _JMSContext_ object’s _createContext_
method should be prohibited by the container. The container should throw
a _JMSRuntimeException_ , since the first _JMSContext_ already contains
a connection and session and this method would create a second session
on the same connection. Application client containers must support the
creation of multiple sessions for each connection.

[#50581515_pgfId-1018111]##The JMS specification defines further
restrictions on the use of JMS in the EJB and web containers. In
general, the behavior of a JMS provider should be the same in both the
EJB container and the web container.

[#50581515_pgfId-1017187]##The JMS specification is available at
_http://jcp.org/en/jsr/detail?id=343._

==== [#50581515_pgfId-7559]##Java™ Transaction API (JTA) 1.2 Requirements

[#50581515_pgfId-998328]##JTA defines the _UserTransaction_ interface
that is used by applications to start, and commit or abort transactions.
Application components get a _UserTransaction_ object through a JNDI
lookup using the name _java:comp/UserTransaction_ or by requesting
injection of a _UserTransaction_ object.

[#50581515_pgfId-1019267]##JTA also defines the
_TransactionSynchronizationRegistry_ interface that can be used by
system level components such as persistence managers to interact with
the transaction manager. These components get a
_TransactionSynchronizationRegistry_ object through a JNDI lookup using
the name _java:comp/TransactionSynchronizationRegistry_ or by requesting
injection of a _TransactionSynchronizationRegistry_ object.

[#50581515_pgfId-999945]##A number of interfaces defined by JTA are used
by an application server to communicate with a transaction manager, and
for a transaction manager to interact with a resource manager. These
interfaces must be supported as described in the Connector
specification. In addition, support for other transaction facilities may
be provided transparently to the application by a Java EE product.

[#50581515_pgfId-1002383]##The JTA specification is available at
_http://jcp.org/en/jsr/detail?id=907_ .

==== [#50581515_pgfId-7560]##[#50581515_14620]##JavaMail™ 1.6 Requirements

[#50581515_pgfId-7561]##The JavaMail API allows for access to email
messages contained in message stores, and for the creation and sending
of email messages using a message transport. Specific support is
included for Internet standard MIME messages. Access to message stores
and transports is through protocol providers supporting specific store
and transport protocols. The JavaMail API specification does not require
any specific protocol providers, but the JavaMail reference
implementation includes an IMAP message store provider, a POP3 message
store provider, and an SMTP message transport provider.

[#50581515_pgfId-1003346]##Configuration of the JavaMail API is
typically done by setting properties in a _Properties_ object that is
used to create a _javax.mail.Session_ object using a static factory
method. To allow the Java EE platform to configure and manage JavaMail
API sessions, an application component that uses the JavaMail API should
request a _Session_ object using JNDI, and should list its need for a
_Session_ object in its deployment descriptor using a _resource-ref_
element, or by using a _Resource_ annotation. A JavaMail API _Session_
object should be considered a resource factory, as described in
link:JavaEE_Platform_Spec.htm#50581511_11574[See Resource Manager
Connection Factory References].” This specification requires that the
Java EE platform support _javax.mail.Session_ objects as resource
factories, as described in that section.

[#50581515_pgfId-1003359]##The Java EE platform requires that a message
transport be provided that is capable of handling addresses of type
_javax.mail.internet.InternetAddress_ and messages of type
_javax.mail.internet.MimeMessage_ . The default message transport must
be properly configured to send such messages using the _send_ method of
the _javax.mail.Transport_ class. Any authentication needed by the
default transport must be handled without need for the application to
provide a _javax.mail.Authenticator_ or to explicitly connect to the
transport and supply authentication information.

[#50581515_pgfId-7563]##This specification does not require that a Java
EE product support any message store protocols.

[#50581515_pgfId-1003267]##Note that the JavaMail API creates threads to
deliver notifications of _Store_ , _Folder_ , and _Transport_ events.
The use of these notification facilities may be limited by the
restrictions on the use of threads in various containers. In EJB
containers, for instance, it is typically not possible to create
threads.

[#50581515_pgfId-7564]##The JavaMail API uses the JavaBeans Activation
Framework API to support various MIME data types. The JavaMail API must
include _javax.activation.DataContentHandlers_ for the following MIME
data types, corresponding to the Java programming language type
indicated in _link:JavaEE_Platform_Spec.htm#50581515_39752[See JavaMail
API MIME Data Type to Java Type Mappings]_ .

======= [#50581515_pgfId-8009]##[#50581515_39752]##JavaMail API MIME Data Type to Java Type Mappings

[#50581515_pgfId-8013]##Mime Type

[#50581515_pgfId-8015]##Java Type

[#50581515_pgfId-8017]## _text/plain_

[#50581515_pgfId-8019]## _java.lang.String_

[#50581515_pgfId-1018052]## _text/html_

[#50581515_pgfId-1018044]## _java.lang.String_

[#50581515_pgfId-1018056]## _text/xml_

[#50581515_pgfId-1018048]## _java.lang.String_

[#50581515_pgfId-8021]## _multipart/*_

[#50581515_pgfId-8023]## _javax.mail.internet.MimeMultipart_

[#50581515_pgfId-8025]## _message/rfc822_

[#50581515_pgfId-8027]## _javax.mail.internet.MimeMessage_

[#50581515_pgfId-1002396]##The JavaMail API specification is available
at _http://jcp.org/en/jsr/detail?id=919_ .

==== [#50581515_pgfId-1004369]##[#50581515_13696]##Java EE™ Connector Architecture 1.7 Requirements

[#50581515_pgfId-1004359]##In full Java EE products, all EJB containers
and all web containers must support the full set of Connector APIs. All
such containers must support Resource Adapters that use any of the
specified transaction capabilities. The Java EE deployment tools must
support deployment of Resource Adapters, as defined in the Connector
specification, and must support the deployment of applications that use
Resource Adapters.

[#50581515_pgfId-1004556]##The Connector specification is available at
_http://jcp.org/en/jsr/detail?id=322_ .

==== [#50581515_pgfId-1016883]##[#50581515_91013]##Web Services for Java EE 1.4 Requirements

[#50581515_pgfId-1016908]##The Web Services for Java EE specification
defines the capabilities a Java EE application server must support for
deployment of web service endpoints. A complete deployment model is
defined, including several new deployment descriptors. All Java EE
products must support the deployment and execution of web services as
specified by the Web Services for Java EE specification (JSR-109).

[#50581515_pgfId-1016909]##The Web Services for Java EE specification is
available at _http://jcp.org/en/jsr/detail?id=109_ .

==== [#50581515_pgfId-1016885]##[#50581515_55384]##Java™ API for XML-based RPC (JAX-RPC) 1.1 Requirements (Optional)

[#50581515_pgfId-1016890]##The JAX-RPC specification defines client APIs
for accessing web services as well as techniques for implementing web
service endpoints. The Web Services for Java EE specification describes
the deployment of JAX-RPC-based services and clients. The EJB and
Servlet specifications also describe aspects of such deployment. In Java
EE products that support JAX-RPC, it must be possible to deploy
JAX-RPC-based applications using any of these deployment models.

[#50581515_pgfId-1017271]##The JAX-RPC specification describes the
support for message handlers that can process message requests and
responses. In general, these message handlers execute in the same
container and with the same privileges and execution context as the
JAX-RPC client or endpoint component with which they are associated.
These message handlers have access to the same JNDI _java:comp/env_
namespace as their associated component. Custom serializers and
deserializers, if supported, are treated in the same way as message
handlers.

[#50581515_pgfId-1019343]##Note that neither web service annotations nor
injection is supported for JAX-RPC service endpoints and handlers. New
applications are encouraged to use JAX-WS to take advantage of these new
facilities that make it easier to write web services.

[#50581515_pgfId-1016930]##The JAX-RPC specification is available at
_http://jcp.org/en/jsr/detail?id=101_ .

==== [#50581515_pgfId-1027333]##[#50581515_80101]##Java™ API for RESTful Web Services (JAX-RS) 2.1 Requirements

[#50581515_pgfId-1020107]##JAX-RS defines APIs for the development of
Web services built according to the Representational State Transfer
(REST) architectural style.

[#50581515_pgfId-1021353]##In a full Java EE product, all Java EE web
containers are required to support applications that use JAX-RS
technology.

[#50581515_pgfId-1020109]##The specification describes the deployment of
services as a servlet. It must be possible to deploy JAX-RS-based
applications using this deployment model with the _servlet-class_
element of the web.xml descriptor naming the application-supplied
extension of the JAX-RS _Application_ abstract class.

[#50581515_pgfId-1020102]##The specification defines a set of optional
container-managed facilities and resources that are intended to be
available in a Java EE container — all such features and resources must
be made available.

[#50581515_pgfId-1021337]##The JAX-RS specification is available at
_http://jcp.org/en/jsr/summary?id=370_ .

==== [#50581515_pgfId-1020103]##[#50581515_16692]##Java API for WebSocket 1.1 (WebSocket) Requirements

[#50581515_pgfId-1025636]##The Java API for WebSocket (WebSocket) is a
standard API for creating WebSocket applications. In a full Java EE
product, all Java EE web containers are required to support the
WebSocket API.

[#50581515_pgfId-1025638]##The Java API for WebSocket specification can
be found at _http://jcp.org/en/jsr/detail?id=356_ .

==== [#50581515_pgfId-1025650]##[#50581515_11046]##Java API for JSON Processing 1.1 (JSON-P) Requirements

[#50581515_pgfId-1025657]##JSON (JavaScript Object Notation) is a
lightweight data-interchange format used by many web services. The Java
API for JSON Processing (JSON-P) provides a convenient way to process
(parse, generate, transform, and query) JSON text.

[#50581515_pgfId-1026168]##In a full Java EE product, all Java EE
application client containers, web containers, and EJB containers are
required to support the JSON-P API.

[#50581515_pgfId-1025658]##The Java API for JSON Processing
specification can be found at _http://jcp.org/en/jsr/detail?id=374_ .

==== [#50581515_pgfId-1026970]##[#50581515_58030]##Java API for JSON Binding 1.0 (JSON-B) Requirements

[#50581515_pgfId-1026971]##The Java API for JSON Binding (JSON-B)
provides a convenient way to map between JSON text and Java objects.

[#50581515_pgfId-1026972]##In a full Java EE product, all Java EE
application client containers, web containers, and EJB containers are
required to support the JSON-B API.

[#50581515_pgfId-1026973]##The Java API for JSON Binding specification
can be found at _http://jcp.org/en/jsr/detail?id=367_ .

==== [#50581515_pgfId-1025665]##[#50581515_19783]##Concurrency Utilities for Java EE 1.0 (Concurrency Utilities) Requirements

[#50581515_pgfId-1026002]##Concurrency Utilities for Java EE is a
standard API for providing asynchronous capabilities to Java EE
application components through the following types of objects: managed
executor service, managed scheduled executor service, managed thread
factory, and context service. In a full Java EE product, all Java EE web
containers and EJB containers are required to support the Concurrency
Utilities API. The Java EE Product Provider must provide preconfigured
default managed executor service, managed scheduled executor service,
managed thread factory, and context service objects for use by the
application in the containers in which the Concurrency Utilities API is
required to be supported.

[#50581515_pgfId-1026003]##The Concurrency Utilities for Java EE
specification can be found at _http://jcp.org/en/jsr/detail?id=236_ .

==== [#50581515_pgfId-1026001]##[#50581515_46895]##Batch Applications for the Java Platform 1.0 (Batch) Requirements

[#50581515_pgfId-1025669]##The Batch Applications for the Java Platform
API (Batch) provides a programming model for batch applications and a
runtime for scheduling and executing jobs.

[#50581515_pgfId-1026165]##In a full Java EE product, all Java EE web
containers and EJB containers are required to support the Batch API.

[#50581515_pgfId-1025670]##The Batch Application for the Java Platform
specification can be found at _http://jcp.org/en/jsr/detail?id=352_ .

==== [#50581515_pgfId-1016891]##[#50581515_24471]##Java™ API for XML Registries (JAXR) 1.0 Requirements (Optional)

[#50581515_pgfId-1016892]##The JAXR specification defines APIs for
client access to XML-based registries such as ebXML registries and UDDI
registries. Java EE products that support JAXR must include a JAXR
registry provider that meets at least the JAXR level 0 requirements.

[#50581515_pgfId-1016933]##The JAXR specification is available at
_http://jcp.org/en/jsr/detail?id=93_ .

==== [#50581515_pgfId-1016893]##Java™ Platform, Enterprise Edition Management API 1.1 Requirements

[#50581515_pgfId-1016894]##The Java EE Management API provides APIs for
management tools to query a Java EE application server to determine its
current status, applications deployed, and so on. All Java EE products
must support this API as described in its specification.

[#50581515_pgfId-1016927]##The Java EE Management API specification is
available at _http://jcp.org/en/jsr/detail?id=77_ .

==== [#50581515_pgfId-1016895]##[#50581515_35657]##Java™ Platform, Enterprise Edition Deployment API 1.2 Requirements (Optional)

[#50581515_pgfId-1016896]##The Java EE Deployment API defines the
interfaces between the runtime environment of a deployment tool and
plug-in components provided by a Java EE application server. These
plug-in components execute in the deployment tool and implement the Java
EE product-specific deployment mechanisms. Java EE products that support
the Java EE Deployment API are required to supply these plug-in
components for use in tools from other vendors.

[#50581515_pgfId-1016966]##Note that the Java EE Deployment
specification does not define new APIs for direct use by Java EE
applications. However, it would be possible to create a Java EE
application that acts as a deployment tool and provides the runtime
environment required by the Java EE Deployment specification.

[#50581515_pgfId-1016936]##The Java EE Deployment API specification is
available at _http://jcp.org/en/jsr/detail?id=88_ .

==== [#50581515_pgfId-1016897]##Java™ Authorization Contract for Containers (JACC) 1.5 Requirements

[#50581515_pgfId-1016898]##The JACC specification defines a contract
between a Java EE application server and an authorization policy
provider. In a full Java EE product, all Java EE web containers and
enterprise bean containers are required to support this contract.

[#50581515_pgfId-1016976]##The JACC specification can be found at
_http://jcp.org/en/jsr/detail?id=115[]http://jcp.org/en/jsr/detail?id=115._

==== [#50581515_pgfId-1020051]##[#50581515_45801]##Java™ Authentication Service Provider Interface for Containers (JASPIC) 1.1 Requirements

[#50581515_pgfId-1020642]##The JASPIC specification defines a service
provider interface (SPI) by which authentication providers implementing
message authentication mechanisms may be integrated in client or server
message processing containers or runtimes. Authentication providers
integrated through this interface operate on network messages provided
to them by their calling container. They transform outgoing messages
such that the source of the message may be authenticated by the
receiving container, and the recipient of the message may be
authenticated by the message sender. They authenticate incoming messages
and return to their calling container the identity established as a
result of the message authentication.

[#50581515_pgfId-1021372]##In a full Java EE product, all Java EE web
containers and enterprise bean containers are required to support the
baseline compatibility requirements as defined by the JASPIC
specification. In a full Java EE product, all web containers must also
support the Servlet Container Profile as defined in the JASPIC
specification. In a Java EE profile product that includes Servlet and
JASPIC, all web containers must also support the Servlet Container
Profile as defined in the JASPIC specification. Support for the JASPIC
SOAP Profile is not required.

[#50581515_pgfId-1027366]##The JASPIC specification can be found at
_http://jcp.org/en/jsr/detail?id=196_ .

==== [#50581515_pgfId-1027367]##[#50581515_39392]##Java EE Security API 1.0 Requirements

[#50581515_pgfId-1027387]##The Java EE Security API leverages JASPIC,
but provides an easier to use SPI for authentication of users of web
applications and defines identity store APIs for authentication and
authorization.

[#50581515_pgfId-1027484]##In a full Java EE product, all Java EE web
containers and enterprise bean containers are required to support the
requirements defined by the Java EE Security API specification.

[#50581515_pgfId-1027388]##The Java EE Security API specification can be
found at _http://jcp.org/en/jsr/detail?id=375._

==== [#50581515_pgfId-1027389]##Debugging Support for Other Languages (JSR-45) Requirements

[#50581515_pgfId-1027368]##JSP pages are usually translated into Java
language pages and then compiled to create class files. The Debugging
Support for Other Languages specification describes information that can
be included in a class file to relate class file data to data in the
original source file. All Java EE products are required to be able to
include such information in class files that are generated from JSP
pages.

[#50581515_pgfId-1017872]##The Debugging Support for Other Languages
specification can be found at _http://jcp.org/en/jsr/detail?id=45_ .

==== [#50581515_pgfId-1017738]##Standard Tag Library for JavaServer Pages™ (JSTL) 1.2 Requirements

[#50581515_pgfId-1017887]##JSTL defines a standard tag library that
makes it easier to develop JSP pages. All Java EE products are required
to provide JSTL for use by all JSP pages.

[#50581515_pgfId-1017882]##The Standard Tag Library for JavaServer Pages
specification can be found at _http://jcp.org/en/jsr/detail?id=52_ .

==== [#50581515_pgfId-1017744]##Web Services Metadata for the Java™ Platform 2.1 Requirements

[#50581515_pgfId-1017905]##The Web Services Metadata for the Java
Platform specification defines Java language annotations that can be
used to simplify the development of web services. These annotations can
be used with JAX-WS web service components.

[#50581515_pgfId-1017902]##The Web Services Metadata for the Java
Platform specification can be found at
_http://jcp.org/en/jsr/detail?id=181_ .

==== [#50581515_pgfId-1017750]##JavaServer Faces™ 2.3 Requirements

[#50581515_pgfId-1017927]##JavaServer Faces technology simplifies
building user interfaces for JavaServer applications. Developers of
various skill levels can quickly build web applications by: assembling
reusable UI components in a page; connecting these components to an
application data source; and wiring client-generated events to
server-side event handlers. In a full Java EE product, all Java EE web
containers are required to support applications that use the JavaServer
Faces technology.

[#50581515_pgfId-1017920]##The JavaServer Faces specification can be
found at _http://jcp.org/en/jsr/detail?id=372_ .

==== [#50581515_pgfId-1017756]##[#50581515_59276]##Common Annotations for the Java™ Platform 1.3 Requirements

[#50581515_pgfId-1018770]##The Common Annotations specification defines
Java language annotations that are used by several other specifications,
including this specification. The specifications that use these
annotations fully define the requirements for these annotations. The
applet container need not support any of these annotations. All other
containers must provide definitions for all of these annotations, and
must support the semantics of these annotations as described in the
corresponding specifications and summarized in the following table.

======= [#50581515_pgfId-1018818]##[#50581515_50469]##Common Annotations Support by Container

[#50581515_pgfId-1018826]##Annotation

[#50581515_pgfId-1018828]##App Client

[#50581515_pgfId-1018830]##Web

[#50581515_pgfId-1018832]##EJB

[#50581515_pgfId-1018842]## _Resource_

[#50581515_pgfId-1018844]##Y

[#50581515_pgfId-1018846]##Y

[#50581515_pgfId-1018848]##Y

[#50581515_pgfId-1018850]## _Resources_

[#50581515_pgfId-1018852]##Y

[#50581515_pgfId-1018854]##Y

[#50581515_pgfId-1018856]##Y

[#50581515_pgfId-1018858]## _PostConstruct_

[#50581515_pgfId-1018860]##Y

[#50581515_pgfId-1018862]##Y

[#50581515_pgfId-1018864]##Y

[#50581515_pgfId-1019200]## _PreDestroy_

[#50581515_pgfId-1019202]##Y

[#50581515_pgfId-1019204]##Y

[#50581515_pgfId-1019206]##Y

[#50581515_pgfId-1018866]## _Generated_

[#50581515_pgfId-1018868]##N

[#50581515_pgfId-1018870]##N

[#50581515_pgfId-1018872]##N

[#50581515_pgfId-1018874]## _RunAs_

[#50581515_pgfId-1018876]##N

[#50581515_pgfId-1018878]##Y

[#50581515_pgfId-1018880]##Y

[#50581515_pgfId-1018882]## _DeclareRoles_

[#50581515_pgfId-1018884]##N

[#50581515_pgfId-1018886]##Y

[#50581515_pgfId-1018888]##Y

[#50581515_pgfId-1018890]## _RolesAllowed_

[#50581515_pgfId-1018892]##N

[#50581515_pgfId-1018894]##Y

[#50581515_pgfId-1018896]##Y

[#50581515_pgfId-1018898]## _PermitAll_

[#50581515_pgfId-1018900]##N

[#50581515_pgfId-1018902]##Y

[#50581515_pgfId-1018904]##Y

[#50581515_pgfId-1018906]## _DenyAll_

[#50581515_pgfId-1018908]##N

[#50581515_pgfId-1018910]##Y

[#50581515_pgfId-1018912]##Y

[#50581515_pgfId-1022347]## _ManagedBean_

[#50581515_pgfId-1022349]##Y

[#50581515_pgfId-1022351]##Y

[#50581515_pgfId-1022353]##Y

[#50581515_pgfId-1022355]## _DataSourceDefinition_

[#50581515_pgfId-1022357]##Y

[#50581515_pgfId-1022359]##Y

[#50581515_pgfId-1022361]##Y

[#50581515_pgfId-1022331]## _DataSourceDefinitions_

[#50581515_pgfId-1022333]##Y

[#50581515_pgfId-1022335]##Y

[#50581515_pgfId-1022337]##Y

[#50581515_pgfId-1025891]##Priority

[#50581515_pgfId-1025893]##Y

[#50581515_pgfId-1025895]##Y

[#50581515_pgfId-1025897]##Y

[#50581515_pgfId-1018476]##The Common Annotations for the Java Platform
specification can be found at _http://jcp.org/en/jsr/detail?id=250_ .

==== [#50581515_pgfId-1018477]##[#50581515_62915]##Java™ Persistence API 2.2 Requirements

[#50581515_pgfId-1017845]##Java Persistence is the standard API for the
management of persistence and object/relational mapping. The Java
Persistence specification provides an object/relational mapping facility
for application developers using a Java domain model to manage a
relational database.

[#50581515_pgfId-1021878]##As mandated by the Java Persistence
specification, in a Java EE environment the classes of the persistence
unit should not be loaded by the application class loader or any of its
parent class loaders until after the entity manager factory for the
persistence unit has been created.

[#50581515_pgfId-1022285]##The Java Persistence specification can be
found at _http://jcp.org/en/jsr/detail?id=338_ .

==== [#50581515_pgfId-1022287]##[#50581515_32670]##Bean Validation 2.0 Requirements

[#50581515_pgfId-1022288]##The Bean Validation specification defines a
metadata model and API for JavaBean validation. The default metadata
source is annotations, with the ability to override and extend the
metadata through the use of XML validation descriptors.

[#50581515_pgfId-1021451]##The Java EE platform requires that web
containers make an instance of _ValidatorFactory_ available to JSF
implementations by storing it in a servlet context attribute named
_javax.faces.validator.beanValidator.ValidatorFactory._

[#50581515_pgfId-1021515]##The Java EE platform also requires that an
instance of _ValidatorFactory_ be made available to JPA providers as a
property in the map that is passed as the second argument to the
_createContainerEntityManagerFactory(PersistenceUnitInfo, Map)_ method
of the _PersistenceProvider_ interface, under the name
_javax.persistence.validation.factory_ .

[#50581515_pgfId-1021511]##Additional requirements on Java EE platform
containers are specified in the Bean Validation specification, which can
be found at _http://jcp.org/en/jsr/detail?id=380_ .

==== [#50581515_pgfId-1021600]##[#50581515_34123]##Managed Beans 1.0 Requirements

[#50581515_pgfId-1021631]##The Managed Beans specification defines a
lightweight component model that supports the basic lifecycle model,
resource injection facility and interceptor service present in the Java
EE platform.

[#50581515_pgfId-1021643]##The Managed Beans specification can be found
at _http://jcp.org/en/jsr/detail?id=316_ .

==== [#50581515_pgfId-1021809]##[#50581515_12250]##Interceptors 1.2 Requirements

[#50581515_pgfId-1021816]##The Interceptors specification makes more
generally available the interceptor facility originally defined as part
of the EJB 3.0 specification.

[#50581515_pgfId-1021819]##The Interceptors specification can be found
at _http://jcp.org/en/jsr/detail?id=318_ .

==== [#50581515_pgfId-1020020]##[#50581515_51019]##Contexts and Dependency Injection for the Java EE Platform 2.0 Requirements

[#50581515_pgfId-1020562]##The Contexts and Dependency Injection (CDI)
specification defines a set of contextual services, provided by Java EE
containers, aimed at simplifying the creation of applications that use
both web tier and business tier technologies.

[#50581515_pgfId-1020617]##The CDI specification can be found at
_http://jcp.org/en/jsr/detail?id=365_ .

==== [#50581515_pgfId-1021755]##Dependency Injection for Java 1.0 Requirements

[#50581515_pgfId-1021752]##The Dependency Injection for Java (DI)
specification defines a standard set of annotations (and one interface)
for use on injectable classes.

[#50581515_pgfId-1022293]##In the Java EE platform, support for
Dependency Injection is mediated by CDI. See
link:JavaEE_Platform_Spec.htm#50581511_62440[See Support for Dependency
Injection]” for more detail.

[#50581515_pgfId-1021766]##The DI specification can be found at
_http://jcp.org/en/jsr/detail?id=330_ .

[#50581515_pgfId-1022470]## 

======= [#50581517_pgfId-7064]##[#50581517_32725]##CHAPTER

[#50581517_pgfId-7065]##[#50581517_85284]##Interoperability

[#50581517_pgfId-7561]## _T_ his chapter describes the interoperability
requirements for the Java™ Platform, Enterprise Edition (Java EE).

==== [#50581517_pgfId-7563]##Introduction to Interoperability

[#50581517_pgfId-7564]##The Java EE platform will be used by enterprise
environments that support clients of many different types. The
enterprise environments will add new services to existing Enterprise
Information Systems (EISs). They will be using various hardware
platforms and applications written in various languages.

[#50581517_pgfId-10165]##In particular, the Java EE platform may be used
in enterprise environments to bring together any of the following kinds
of applications:

* [#50581517_pgfId-7565]##applications written in such languages as C++
and Visual Basic.
* [#50581517_pgfId-10131]##applications running on a personal computer
platform, or Unix® workstation.
* [#50581517_pgfId-10137]##standalone Java technology-based applications
that are not directly supported by the Java EE platform.

[#50581517_pgfId-7566]##It is the interoperability requirements of the
Java EE platform, set out in this chapter, that make it possible for it
to provide indirect support for various types of clients, different
hardware platforms, and a multitude of software applications. The
interoperability features of the Java EE platform permit the underlying
disparate systems to work together seamlessly, while hiding much of the
complexity required to join these pieces together.

[#50581517_pgfId-10168]##The interoperability requirements for the
current Java EE platform release allow:

* [#50581517_pgfId-10169]##Java EE applications to connect to legacy
systems using CORBA or low-level socket interfaces.
* [#50581517_pgfId-7569]##Java EE applications to connect to other Java
EE applications across multiple Java EE products, whether from different
Product Providers or from the same Provider, and multiple Java EE
platforms.

[#50581517_pgfId-7571]##In this version of the specification,
interoperability between Java EE applications running in different
platforms is accomplished through the HTTP protocol, possibly using SSL,
or the EJB interoperability protocol based on IIOP.

==== [#50581517_pgfId-7572]##Interoperability Protocols

[#50581517_pgfId-7573]##This specification requires that a Java EE
product support a standard set of protocols and formats to ensure
interoperability between Java EE applications and with other
applications that also implement these protocols and formats. The
specification requires support for the following groups of protocols and
formats:

======= [#50581517_pgfId-7574]##Internet and web protocols

* [#50581517_pgfId-7575]##OMG protocols
* [#50581517_pgfId-7576]##Java technology protocols

======= [#50581517_pgfId-7577]##Data formats

[#50581517_pgfId-7710]##Most of these protocols and formats are
supported by Java SE and by the underlying operating system.

======= [#50581517_pgfId-7578]##[#50581517_63291]##Internet and Web Protocols

[#50581517_pgfId-7579]##Standards based Internet protocols are the means
by which different pieces of the platform communicate. The Java EE
platform typically supports the following Internet protocols, as
described in the corresponding technology specifications:

* [#50581517_pgfId-7580]##TCP/IP protocol family—This is the core
component of Internet communication. TCP/IP and UDP/IP are the standard
transport protocols for the Internet. TCP/IP is supported by Java SE and
the underlying operating system.
* [#50581517_pgfId-7581]##HTTP 1.1—This is the core protocol of web
communication. As with TCP/IP, HTTP 1.1 is supported by Java SE and the
underlying operating system. A Java EE web container must be capable of
advertising its HTTP services on the standard HTTP port, port 80.
* [#50581517_pgfId-18739]##HTTP/2—Server-side support for the HTTP/2
protocol is required by the Servlet specification.
* [#50581517_pgfId-7582]##SSL 3.0, TLS 1.2—SSL 3.0 (Secure Socket Layer)
represents the security layer for Web communication. It is available
indirectly when using the _https_ URL as opposed to the _http_ URL. A
Java EE web container must be capable of advertising its HTTPS service
on the standard HTTPS port, port 443. Note that SSL 3.0 and only TLS 1.0
are required as part of the EJB interoperability protocol in the EJB
specification.
* [#50581517_pgfId-16967]##SOAP 1.1—SOAP is a presentation layer
protocol for the exchange of XML messages. Support for SOAP layered on
HTTP is required, as described in the JAX-RPC and JAX-WS specifications.
* [#50581517_pgfId-17498]##SOAP 1.2—SOAP 1.2 is the version of the SOAP
protocol standardized through W3C and supported by JAX-WS.
* [#50581517_pgfId-17081]##WS-I Basic Profile 1.1—The WS-I Basic
Profile, in combination with the Simple SOAP Binding Profile and
Attachment Profile, describes interoperability requirements for the use
of SOAP 1.1, WSDL 1.1, and MIME-based SOAP with Attachments. It is
required by the JAX-RPC and JAX-WS specifications.
* [#50581517_pgfId-18666]##WebSocket protocol—The WebSocket protocol
enables two-way communication layered over TCP. It enables
bi-directional communication over a single connection established by an
initial HTTP handshake and upgrade request. The WebSocket protocol has
been standardized by IETF under RFC 6455.

======= [#50581517_pgfId-7585]##[#50581517_71955]##OMG Protocols (Proposed Optional)

[#50581517_pgfId-7586]##This specification requires the a full Java EE
product to support the following Object Management Group (OMG) based
protocols:

* [#50581517_pgfId-7587]##IIOP (Internet Inter-ORB Protocol)—Supported
by Java IDL and RMI-IIOP in Java SE. Java IDL provides standards-based
interoperability and connectivity through the Common Object Request
Broker Architecture (CORBA). CORBA specifies the Object Request Broker
(ORB) which allows applications to communicate with each other
regardless of location. This interoperability is delivered through IIOP,
and is typically found in an intranet setting. IIOP can be used as an
RMI protocol using the RMI-IIOP technology. IIOP is defined in Chapters
13 and 15 of the CORBA 2.3.1 specification, available at
_http://omg.org/cgi-bin/doc?formal/99-10-07_ .
* [#50581517_pgfId-7811]##EJB interoperability protocol—The EJB
interoperability protocol is based on IIOP (GIOP 1.2) and the CSIv2
CORBA Secure Interoperability specification. The EJB interoperability
protocol is defined in the EJB specification.
* [#50581517_pgfId-7837]##CORBA Interoperable Naming Service
protocol—The COSNaming-based INS protocol is an IIOP-based protocol for
accessing a name service. The EJB interoperability protocol requires the
use of the INS protocol for lookup of EJB objects using the JNDI API. In
addition, it must be possible to use the Java IDL COSNaming API to
access the INS name service. All Java EE products must provide a name
service that meets the requirements of the Interoperable Naming Service
specification, available at
_http://omg.org/cgi-bin/doc?formal/2000-06-19_ . This name service may
be provided as a separate name server or as a protocol bridge or gateway
to another name service. Either approach is consistent with this
specification.

======= [#50581517_pgfId-10195]##Java Technology Protocols

[#50581517_pgfId-7591]##This specification requires the Java EE platform
to support the JRMP protocol, which is the Java technology-specific
Remote Method Invocation (RMI) protocol. JRMP is a required component of
Java SE and is one of two required RMI protocols. (IIOP is the other
required RMI protocol, see above.)

[#50581517_pgfId-7818]##JRMP is a distributed object model for the Java
programming language. Distributed systems, running in different address
spaces and often on different hosts, must be able to communicate with
each other. JRMP permits program-level objects in different address
spaces to invoke remote objects using the semantics of the Java
programming language object model.

[#50581517_pgfId-7592]##Complete information on the JRMP specification
can be found at
_http://docs.oracle.com/javase/8/docs/technotes/guides/rmi_ .

======= [#50581517_pgfId-7593]##[#50581517_24910]##Data Formats

[#50581517_pgfId-7594]##In addition to the protocols that allow
communication between components, this specification requires Java EE
platform support for a number of data formats. These formats provide the
definition for data exchanged between components.

[#50581517_pgfId-7595]##The following data formats must be supported:

* [#50581517_pgfId-16978]##XML 1.0—The XML format can be used to
construct documents, RPC messages, etc. The JAXP API provides support
for processing XML format data. The JAX-RPC API provides support for XML
RPC messages, as well as a mapping between Java classes and XML.
* [#50581517_pgfId-18624]##JSON—JSON is a language-neutral plain text
format commonly used to transfer structured data between a server and
web application. The JSON-P API provides support for the parsing,
generation, transformation, and querying of JSON text. The JSON-B API
provides support for mapping between JSON text and Java objects.
* [#50581517_pgfId-7596]##HTML 4.01—This represents the minimum web
browser standard document format. While all Java EE APIs with the
exception of JSF are agnostic to the version of the browser document
format, Java EE web clients must be able to display HTML 4.01 documents.
* [#50581517_pgfId-7597]##Image file formats—The Java EE platform must
support GIF, JPEG, and PNG images. Support for these formats is provided
by the _java.awt.image_ APIs (see the URL:
_http://docs.oracle.com/javase/8/docs/api/java/awt/image/package-summary.html_
) and by Java EE web clients.
* [#50581517_pgfId-7598]##JAR files—JAR (Java Archive) files are the
standard packaging format for Java technology-based application
components, including the ejb-jar specialized format, the Web
application archive (WAR) format, the Resource Adapter archive (RAR),
and the Java EE enterprise application archive (EAR) format. JAR is a
platform-independent file format that permits many files to be
aggregated into one file. This allows multiple Java components to be
bundled into one JAR file and downloaded to a browser in a single HTTP
transaction. JAR file formats are supported by the _java.util.jar_ and
_java.util.zip_ packages. For complete information on the JAR
specification, see
_http://docs.oracle.com/javase/8/docs/technotes/guides/jar_ .
* [#50581517_pgfId-7599]##Class file format—The class file format is
specified in the Java Virtual Machine specification. Each class file
contains one Java programming language type—either a class or an
interface—and consists of a stream of 8-bit bytes. For complete
information on the class file format, see
_http://docs.oracle.com/javase/specs/_ .

======= [#50581519_pgfId-18728]##[#50581519_32725]##CHAPTER

[#50581519_pgfId-18730]##[#50581519_19278]##Application Assembly and
Deployment

[#50581519_pgfId-1003914]## _T_ his chapter specifies Java™ Platform,
Enterprise Edition (Java EE) requirements for assembling, packaging, and
deploying a Java EE application. The main goal of these requirements is
to provide scalable and modular application assembly, and portable
deployment of Java EE applications into any Java EE product.

[#50581519_pgfId-1003927]##Java EE applications are composed of one or
more Java EE components and an optional Java EE application deployment
descriptor. The deployment descriptor, if present, lists the
application’s components as _module_ s. If the deployment descriptor is
not present, the application’s modules are discovered using default
naming rules. A Java EE module represents the basic unit of composition
of a Java EE application. Java EE modules consist of one or more Java EE
components and an optional module level deployment descriptor. The
flexibility and extensibility of the Java EE component model facilitates
the packaging and deployment of Java EE components as individual
components, component libraries, or Java EE applications.

[#50581519_pgfId-1076028]##A full Java EE product must support all the
facilities described in this chapter. A Java EE profile may support only
a subset of the Java EE module types. Any requirements related to a
module type not supported by a product based on a particular Java EE
profile should be understood to not apply to such a product.

[#50581519_pgfId-1000591]##
_link:JavaEE_Platform_Spec.htm#50581519_34830[See Java EE Deployment]_
shows the composition model for Java EE deployment units and includes
the optional use of alternate deployment descriptors by the application
package to preserve any digital signatures of the original Java EE
modules. An alternate deployment descriptor may also be provided
external to the application package as described in
link:JavaEE_Platform_Spec.htm#50581519_25462[See Assembling a Java EE
Application].”

======= [#50581519_pgfId-14188]##[#50581519_34830]##Java EE Deployment

image:JavaEE_Platform_Spec-9.gif[image]

==== [#50581519_pgfId-14189]##Application Development Life Cycle

[#50581519_pgfId-14196]##The development life cycle of a Java EE
application begins with the creation of discrete Java EE components.
These components may then be packaged with a module level deployment
descriptor to create a Java EE module. Java EE modules can be deployed
as stand-alone units or can be assembled with a Java EE application
deployment descriptor and deployed as a Java EE application.

[#50581519_pgfId-14264]##
_link:JavaEE_Platform_Spec.htm#50581519_42220[See Java EE Application
Life Cycle]_ shows the life cycle of a Java EE application.

======= [#50581519_pgfId-14269]##[#50581519_42220]##Java EE Application Life Cycle

image:JavaEE_Platform_Spec-10.gif[image]

======= [#50581519_pgfId-14270]##[#50581519_46804]##Component Creation

[#50581519_pgfId-14271]##The EJB, servlet, application client, and
Connector specifications include the XML Schema definition of the
associated module level deployment descriptors and component packaging
architecture required to produce Java EE modules. (The application
client specification is found in
link:JavaEE_Platform_Spec.htm#50581520_32725[See CHApter] of this
document.)

[#50581519_pgfId-14285]##A Java EE module is a collection of one or more
Java EE components (web, EJB, application client, or Connector) with an
optional module deployment descriptor of that type. Any number of
components of the same container type can be packaged together with a
single Java EE deployment descriptor appropriate to that container type
to produce a Java EE module. Components of different container types may
not be mixed in a single Java EE module, except for the packaging of EJB
components within a web module.

* [#50581519_pgfId-14301]##A Java EE module represents the basic unit of
composition of a Java EE application. In some cases a single Java EE
module (not necessarily packaged into a Java EE application package)
will contain an entire application. In other cases an application will
be composed of multiple Java EE modules.
* [#50581519_pgfId-14305]##The deployment descriptor for a Java EE
module contains declarative data required to deploy the components in
the module. The deployment descriptor for a Java EE module also contains
assembly instructions that describe how the components are composed into
an application.
* [#50581519_pgfId-1065116]##Starting with version 5 of the Java EE
platform, a web application module, an enterprise bean module, or an
application client module need not contain a deployment descriptor.
Instead, the deployment information may be specified by annotations
present in the class files of the module.
* [#50581519_pgfId-1065119]##Starting with version 5 of the Java EE
platform, a Java EE enterprise application archive need not contain a
deployment descriptor. Instead, the deployment information may be
determined using default naming rules for embedded modules.
* [#50581519_pgfId-1003804]##An individual Java EE module can be
deployed as a stand-alone Java EE module without an application level
deployment descriptor and represents a valid Java EE application.
* [#50581519_pgfId-1003805]##Java EE modules may express dependencies on
libraries as described below in
link:JavaEE_Platform_Spec.htm#50581519_27048[See Library Support].”

[#50581519_pgfId-1066346]##All Java EE modules have a name. The name can
be explicitly set in the deployment descriptor for the module. If not
set, the name of the module is the pathname of the module in the ear
file with any filename extension (.jar, .war, .rar) removed, but with
any directory names included. The name of a module must be unique within
an application. If and only if the name is not unique (e.g., because two
names are identical after removing different filename extensions) the
deployment tool may choose new unique names for any of the conflicting
modules; module names that do not conflict must not be changed. The
algorithm for choosing unique names in such a case is product specific.
Applications that depend on the names of their modules must ensure that
their module names are unique.

[#50581519_pgfId-1066359]##For example, an application with this
structure:

[#50581519_pgfId-1066386]## 

[#50581519_pgfId-1066387]##myapp.ear

[#50581519_pgfId-1066388]## inventory.jar

[#50581519_pgfId-1066389]## ui.war

[#50581519_pgfId-1066425]## 

[#50581519_pgfId-1066392]##has a default application name of "myapp",
and defines two modules with default names "inventory" and "ui".

[#50581519_pgfId-1066398]##An application with this structure:

[#50581519_pgfId-1066399]## 

[#50581519_pgfId-1066400]##bigapp.ear

[#50581519_pgfId-1066401]## ejbs

[#50581519_pgfId-1066402]## inventory.jar

[#50581519_pgfId-1066403]## accounts.jar

[#50581519_pgfId-1066404]## ui

[#50581519_pgfId-1066405]## store.war

[#50581519_pgfId-1066406]## admin.war

[#50581519_pgfId-1066424]## 

[#50581519_pgfId-1066411]##has a default application name of "bigapp",
and defines four modules with default names "ejbs/inventory",
"ejbs/accounts", "ui/store", and "ui/admin".

======= [#50581519_pgfId-1010849]##[#50581519_14606]##Application Assembly

[#50581519_pgfId-18753]##A Java EE application may consist of one or
more Java EE modules and one Java EE application deployment descriptor.
A Java EE application is packaged using the Java Archive (JAR) file
format into a file with a _.ear_ (Enterprise ARchive) filename
extension. A minimal Java EE application package will only contain Java
EE modules and, optionally, the application deployment descriptor. A
Java EE application package may also include libraries referenced by
Java EE modules (using the _Class-Path_ mechanism described below in
link:JavaEE_Platform_Spec.htm#50581519_27048[See Library Support]”),
help files, and documentation to aid the deployer.

[#50581519_pgfId-18763]##The deployment of a portable Java EE
application should not depend on any entities that may be contained in
the package other than those defined by this specification. Deployment
of a portable Java EE application must be possible using only the
application deployment descriptor, if any, and the Java EE modules (and
their dependent libraries) and descriptors listed in it.

[#50581519_pgfId-17922]##The Java EE application deployment descriptor
represents the top level view of a Java EE application’s contents. The
Java EE application deployment descriptor is specified by an XML schema
or document type definition (see
link:JavaEE_Platform_Spec.htm#50581519_14579[See Java EE Application XML
Schema]”).

[#50581519_pgfId-14347]##In certain cases, a Java EE application will
need customization before it can be deployed into the enterprise. New
Java EE modules may be added to the application. Existing modules may be
removed from the application. Some Java EE modules may need custom
content created, changed, or replaced. For example, an application
consumer may need to use an HTML editor to add company graphics to a
template login page that was provided with a Java EE web application.

[#50581519_pgfId-1066428]##All Java EE applications have a name. The
name can be explicitly set in the application deployment descriptor. If
not set, the name of the application is the base name of the ear file
with any _.ear_ extension removed and with any directory names removed.
The name of an application must be unique in an application server
instance. If an attempt is made to deploy an application with a name
that conflicts with an already deployed application, the deployment tool
may choose a new unique name for the application. The deployment tool
may also allow a different name to be specified at deployment time. A
deployment tool may use product-specific means to decide whether a
deployment operation is a deployment of a new application, in which case
the name must be unique, or a redeployment of an existing application,
in which case the name may match the existing application.

[#50581519_pgfId-1066442]##Similarly, when a stand-alone module is
deployed, the module name is used as the application name, and obeys the
same rules as described above for application names. The module name can
be explicitly set in the module deployment descriptor. If not set, the
name of the module is the base name of the module file with any
extension ( _.war_ , _.jar_ , _.rar_ ) removed and with any directory
names removed.

======= [#50581519_pgfId-14354]##[#50581519_30227]##Deployment

[#50581519_pgfId-1080300]##During the deployment phase of an
application’s life cycle, the application is installed on the Java EE
platform and then is configured and integrated into the existing
infrastructure. Each Java EE module listed in the application deployment
descriptor (or discovered using the default rules described below) must
be deployed according to the requirements of the specification for the
respective Java EE module type. Each module listed must be installed in
the appropriate container type and the environment properties of each
module must be set appropriately in the target container to reflect the
values declared by the deployment descriptor element for each component.

[#50581519_pgfId-1080318]##Every resource reference should be bound to a
resource of the required type.

[#50581519_pgfId-1080320]##Some resources have default mapping rules
specified; see sections link:JavaEE_Platform_Spec.htm#50581511_90595[See
Default Data Source], link:JavaEE_Platform_Spec.htm#50581511_52679[See
Default JMS Connection Factory], and
link:JavaEE_Platform_Spec.htm#50581511_67316[See Default Concurrency
Utilities Objects]. By default, a product must map otherwise unmapped
resources using these default rules. A product may include an option to
disable or override these default mapping rules.

[#50581519_pgfId-1080322]##Once a resource reference is bound to a
resource in the target operational environment, and deployment succeeds,
that binding is not expected to change. A product may provide
administrative operations that change the resource bindings that are
used by applications. A product may notify applications of changes to
their resource bindings using JNDI events, but this is not required.

[#50581519_pgfId-1080324]##If deployment succeeds, in addition to
binding resource references as specified above, every resource
definition (see section link:JavaEE_Platform_Spec.htm#50581511_72240[See
Resource Definition and Configuration]) specified by the application or
specified or overridden by the Deployer must be present in the target
operational environment.

==== [#50581519_pgfId-1080312]##[#50581519_27048]##Library Support

[#50581519_pgfId-1053037]##The Java EE platform provides several
mechanisms for applications to use optional packages and shared
libraries (hereafter referred to as _libraries_ ). Libraries may be
bundled with an application or may be installed separately for use by
any application.

[#50581519_pgfId-1053046]##Java EE products are required to support the
use of bundled and installed libraries as specified in the _Extension
Mechanism Architecture_ and _Optional Package Versioning_ specifications
(available at
_http://docs.oracle.com/javase/8/docs/technotes/guides/extensions/_ )
and the JAR File Specification (available at
_http://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html_ ).
Using this mechanism a Java EE JAR file can reference utility classes or
other shared classes or resources packaged in a separate _.jar_ file or
directory that is included in the same Java EE application package, or
that has been previously installed in the Java EE containers.

======= [#50581519_pgfId-1053033]##[#50581519_31584]##Bundled Libraries

[#50581519_pgfId-1053080]##Libraries bundled with an application may be
referenced in the following ways:

. [#50581519_pgfId-1012325]##A JAR format file (such as a _.jar_ file,
_.war_ file, or _.rar_ file) may reference a _.jar_ file or directory by
naming the referenced _.jar_ file or directory in a _Class-Path_ header
in the referencing JAR file’s Manifest file. The referenced _.jar_ file
or directory is named using a URL relative to the URL of the referencing
JAR file. The Manifest file is named _META-INF/MANIFEST.MF_ in the JAR
file. The _Class-Path_ entry in the Manifest file is of the form

[#50581519_pgfId-1012326]##Class-Path:
list-of-jar-files-or-directories-separated-by-spaces

[#50581519_pgfId-1012330]##(See the JAR File Specification for important
details and limitations of the syntax of _Class-Path_ headers.) The Java
EE deployment tools must process all such referenced files and
directories when processing a Java EE module. Any deployment descriptors
in referenced _.jar_ files must be ignored when processing the
referencing _.jar_ file. The deployment tool must install the _.jar_
files and directories in a way that preserves the relative references
between the files. Typically this is done by installing the _.jar_ files
into a directory hierarchy that matches the original application
directory hierarchy. All referenced _.jar_ files or directories must
appear in the logical class path of the referencing JAR files at
runtime.

[#50581519_pgfId-1053065]##Only JAR format files or directories
containing class files or resources to be loaded directly by a standard
class loader should be the target of a _Class-Path_ reference; such
files are always named with a _.jar_ extension. Top level JAR files that
are processed by a deployment tool should not contain _Class-Path_
entries; such entries would, by definition, reference other files
external to the deployment unit. A deployment tool is not required to
process such external references.

. [#50581519_pgfId-1053071]##A _.ear_ file may contain a directory that
contains libraries packaged in JAR files. The _library-directory_
element of the _.ear_ file’s deployment descriptor contains the name of
this directory. If a _library-directory_ element isn’t specified, or if
the _.ear_ file does not contain a deployment descriptor, the directory
named _lib_ is used. An empty _library-directory_ element may be used to
specify that there is no library directory.

[#50581519_pgfId-1053066]##All files in this directory (but not
subdirectories) with a _.jar_ extension must be made available to all
components packaged in the EAR file, including application clients.
These libraries may reference other libraries, either bundled with the
application or installed separately, using any of the techniques
described herein.

. [#50581519_pgfId-1053112]##A web application may include libraries in
the _WEB-INF/lib_ directory. See the Servlet specification for details.
These libraries may reference other libraries, either bundled with the
application or installed separately, using any of the techniques
described herein.

======= [#50581519_pgfId-1053113]##Installed Libraries

[#50581519_pgfId-1053096]##Libraries that have been installed separately
may be referenced in the following way:

. [#50581519_pgfId-1012335]##JAR format files of all types may contain
an _Extension-List_ attribute in their Manifest file, indicating a
dependency on an installed library. The JAR File Specification defines
the semantics of such attributes for use by applets; this specification
requires support for such attributes for all component types and
corresponding JAR format files. The deployment tool is required to check
such dependency information and reject the deployment of any component
for which the dependency can not be met. Portable applications should
not assume that any installed libraries will be available to a component
unless the component’s JAR format file, or one of the containing JAR
format files, expresses a dependency on the library using the
_Extension-List_ and related attributes.

[#50581519_pgfId-1053131]##The referenced libraries must be made
available to all components contained within the referencing file,
including any components contained within other JAR format files within
the referencing file. For example, if a _.ear_ file references an
installed library, the library must be made available to all components
in all _.war_ files, EJB _.jar_ files, application _.jar_ files, and
resource adapter _.rar_ files within the _.ear_ file.

[#50581519_pgfId-1053086]##A Java EE product is not required to support
downloading of libraries (using the _<extension>-Implementation-URL_
header) at deployment time or runtime. A Java EE product is also not
required to support more than a single version of an installed library
at once. A Java EE product is not required to limit access to installed
libraries to only those for which the application has expressed a
dependency; the application may be given access to more installed
libraries than it has requested. In all of these cases, such support is
highly recommended and may be required in a future version of this
specification. In particular, we recommend that a Java EE product
support multiple versions of an installed library, and by default only
allow applications to access the installed libraries for which they have
expressed a dependency.

======= [#50581519_pgfId-1053089]##Library Conflicts

[#50581519_pgfId-1015901]##If an application includes a bundled version
of a library, and the same library exists as an installed library, the
instance of the library bundled with the application should be used in
preference to any installed version of the library. This allows an
application to bundle exactly the version of a library it requires
without being influenced by any installed libraries. Note that if the
library is also a required component of the Java EE platform version on
which the application is being deployed, the platform version may (and
typically will) take precedence.

======= [#50581519_pgfId-1053090]##Library Resources

[#50581519_pgfId-1015898]##In addition to allowing access to referenced
classes, as described above, any resources contained in the referenced
JAR files must also be accessible using the _Class_ and _ClassLoader_
_getResource_ methods, as allowed by the security permissions of the
application. An application will typically have the security permissions
required to access resources in any of the JAR files packaged with the
application.

======= [#50581519_pgfId-1059341]##[#50581519_59174]##Dynamic Class Loading

[#50581519_pgfId-1059342]##Libraries that dynamically load classes must
consider the class loading environment of a Java EE application.
Libraries will often be loaded by a class loader that is a parent class
loader of the class loader that is used to load application classes and
thus will not have direct visibility to classes of the application
modules. A library that only needs to dynamically load classes provided
by the library itself can safely use the _Class_ method _forName_ .
However, libraries that need to dynamically load classes that have been
provided as a part of the application need to use the context class
loader to load the classes. Note that the context class loader may be
different in each module of an application. Access to the context class
loader requires _RuntimePermission_ (“ _getClassLoader”)_ , which is not
normally granted to applications, but should be granted to libraries
that need to dynamically load classes. Libraries can use a method such
as the following to assert their privilege when accessing the context
class loader. This technique will work in both Java SE and Java EE.

[#50581519_pgfId-1059422]## 

[#50581519_pgfId-1059359]##public ClassLoader getContextClassLoader() \{

[#50581519_pgfId-1059360]## return AccessController.doPrivileged(

[#50581519_pgfId-1059534]## new PrivilegedAction<ClassLoader>() \{

[#50581519_pgfId-1059362]## public ClassLoader run() \{

[#50581519_pgfId-1059363]## ClassLoader cl = null;

[#50581519_pgfId-1059364]## try \{

[#50581519_pgfId-1059365]## cl = Thread.currentThread().

[#50581519_pgfId-1059421]## getContextClassLoader();

[#50581519_pgfId-1059366]## } catch (SecurityException ex) \{ }

[#50581519_pgfId-1059367]## return cl;

[#50581519_pgfId-1059368]## }

[#50581519_pgfId-1059369]## });

[#50581519_pgfId-1059370]##}

[#50581519_pgfId-1059428]## 

[#50581519_pgfId-1059429]##Libraries should then use the following
technique to load classes.

[#50581519_pgfId-1059435]## 

[#50581519_pgfId-1059436]## ClassLoader cl = getContextClassLoader();

[#50581519_pgfId-1059437]## if (cl != null) \{

[#50581519_pgfId-1066261]## try \{

[#50581519_pgfId-1059438]## clazz = Class.forName(name, false, cl);

[#50581519_pgfId-1066262]## } catch (ClassNotFoundException ex) \{

[#50581519_pgfId-1066263]## clazz = Class.forName(name);

[#50581519_pgfId-1066264]## }

[#50581519_pgfId-1059439]## } else

[#50581519_pgfId-1059440]## clazz = Class.forName(name);

======= [#50581519_pgfId-1059430]##[#50581519_85048]##Examples

[#50581519_pgfId-1012336]##The following example illustrates a simple
use of the bundled library mechanism to reference a library of utility
classes that are shared between enterprise beans in two separate ejb-jar
files.

[#50581519_pgfId-1012337]## 

[#50581519_pgfId-1012338]##app1.ear:

[#50581519_pgfId-1012339]## META-INF/application.xml

[#50581519_pgfId-1012340]## ejb1.jar Class-Path: util.jar

[#50581519_pgfId-1012341]## ejb2.jar Class-Path: util.jar

[#50581519_pgfId-1012342]## util.jar

[#50581519_pgfId-1012344]## 

[#50581519_pgfId-1012345]##The next example illustrates a more complex
use of the _Class-Path_ mechanism. In this example the Developer has
chosen to package the enterprise bean client view classes in a separate
JAR file and reference that JAR file from the other JAR files that need
those classes. Those classes are needed both by _ejb2.jar_ , packaged in
the same application as _ejb1.jar_ , and by _ejb3.jar_ and
_servlet1.jar_ , packaged in a different application. Those classes are
also needed by _ejb1.jar_ itself because they define the remote
interface of the enterprise beans in _ejb1.jar_ , and the developer has
chosen the by reference model of making these classes available, as
described in the EJB spec. The deployment descriptor for _ejb1.jar_
names the client view JAR file in the _ejb-client-jar_ element.

[#50581519_pgfId-1012346]##The _Class-Path_ mechanism must be used by
components in _app3.ear_ to reference the client view JAR file that
corresponds to the enterprise beans packaged in _ejb1.jar_ of _app2.ear_
. These enterprise beans are referenced by enterprise beans in
_ejb3.jar_ and by the servlets packaged in _webapp.war_ .

[#50581519_pgfId-1012347]## 

[#50581519_pgfId-1012348]##app2.ear:

[#50581519_pgfId-1012349]## META-INF/application.xml

[#50581519_pgfId-1012350]## ejb1.jar Class-Path: ejb1_client.jar

[#50581519_pgfId-1012351]## deployment descriptor contains:

[#50581519_pgfId-1012352]##
<ejb-client-jar>ejb1_client.jar</ejb-client-jar>

[#50581519_pgfId-1012353]## ejb1_client.jar

[#50581519_pgfId-1012354]## ejb2.jar Class-Path: ejb1_client.jar

[#50581519_pgfId-1012355]## 

[#50581519_pgfId-1012356]##app3.ear:

[#50581519_pgfId-1012357]## META-INF/application.xml

[#50581519_pgfId-1012358]## ejb1_client.jar

[#50581519_pgfId-1012359]## ejb3.jar Class-Path: ejb1_client.jar

[#50581519_pgfId-1012362]## webapp.war Class-Path: ejb1_client.jar

[#50581519_pgfId-1012363]## WEB-INF/web.xml

[#50581519_pgfId-1012364]## WEB-INF/lib/servlet1.jar

[#50581519_pgfId-1012366]## 

[#50581519_pgfId-1012367]##The following example illustrates a simple
use of the installed library mechanism to reference a library of utility
classes that is installed separately.

[#50581519_pgfId-1012368]## 

[#50581519_pgfId-1012369]##app1.ear:

[#50581519_pgfId-1012370]## META-INF/application.xml

[#50581519_pgfId-1012371]## ejb1.jar :

[#50581519_pgfId-1012372]## META-INF/MANIFEST.MF:

[#50581519_pgfId-1012373]## Extension-List: util

[#50581519_pgfId-1012374]## util-Extension-Name: com/example/util

[#50581519_pgfId-1012375]## util-Specification-Version: 1.4

[#50581519_pgfId-1012376]## META-INF/ejb-jar.xml

[#50581519_pgfId-1012377]## 

[#50581519_pgfId-1012378]##util.jar:

[#50581519_pgfId-1012379]## META-INF/MANIFEST.MF:

[#50581519_pgfId-1012380]## Extension-Name: com/example/util

[#50581519_pgfId-1012381]## Specification-Title: example.com’s util
package

[#50581519_pgfId-1012382]## Specification-Version: 1.4

[#50581519_pgfId-1012383]## Specification-Vendor: example.com

[#50581519_pgfId-1012384]## Implementation-Version: build96

==== [#50581519_pgfId-14365]##[#50581519_78785]##Class Loading Requirements

[#50581519_pgfId-1065480]##[#50581519_14581]##The Java EE specification
purposely does not define the exact types and arrangements of class
loaders that must be used by a Java EE product. Instead, the
specification defines requirements in terms of what classes must or must
not be visible to components. A Java EE product is free to use whatever
class loaders it chooses to meet these requirements. Portable
applications must not depend on the

[#50581519_pgfId-1065486]##types of class loaders used or the
hierarchical arrangement of class loaders, if any. Portable applications
must not depend on the order in which classes and resources are loaded.
Applications should use the techniques described in
link:JavaEE_Platform_Spec.htm#50581519_59174[See Dynamic Class Loading]”
if they need to load classes dynamically.

[#50581519_pgfId-1066189]##In addition to the required classes specified
below, a Java EE product must provide a way to allow an application to
access a class library installed in the application server, even if it
has not expressed a dependency on that library. This supports the use of
old applications and extension libraries that do not use the defined
extension dependency mechanism.

[#50581519_pgfId-1065490]##The following sections describe the
requirements for each container type. In all cases, access to classes is
governed by the rules of the Java language and the Java virtual machine.
In all cases, access to classes and resources is governed by the rules
of the Java security model.

[#50581519_pgfId-1080251]##Note that while libraries must be accessible
to application classes as described below, it may be necessary to use
the techniques described in
link:JavaEE_Platform_Spec.htm#50581519_59174[See Dynamic Class Loading]”
if libraries need to access classes packaged in the application modules.

======= [#50581519_pgfId-1065499]##[#50581519_73728]##Web Container Class Loading Requirements

[#50581519_pgfId-1065501]##Components in the web container must have
access to the following classes

[#50581519_pgfId-1065502]##and resources. Note that as of Java EE 6, EJB
components may be packaged in a web component module. Such EJB
components have the same access as other components in the web
container. See the EJB specification for further detail.

* [#50581519_pgfId-1065504]##The content of the _WEB-INF/classes_
directory of the containing war file.
* [#50581519_pgfId-1065506]##The content of all jar files in the
_WEB-INF/lib_ directory of the containing war file, but not any
subdirectories.
* [#50581519_pgfId-1065509]##The transitive closure of any libraries
referenced by the above jar files (as specified in
link:JavaEE_Platform_Spec.htm#50581519_27048[See Library Support]”).
* [#50581519_pgfId-1065512]##The transitive closure of any libraries
referenced by the war file itself (as specified in
link:JavaEE_Platform_Spec.htm#50581519_27048[See Library Support]”).
* [#50581519_pgfId-1065515]##The transitive closure of any libraries
specified by or referenced by the containing ear file (as specified in
link:JavaEE_Platform_Spec.htm#50581519_27048[See Library Support]”).
* [#50581519_pgfId-1065518]##The contents of all jar files included in
any resource adapter archives (rar files) included in the same ear file.
* [#50581519_pgfId-1065521]##The contents of all jar files included in
each resource adapter archive (rar file) deployed separately to the
application server, if that resource adapter is used to satisfy any
resource references in the module.
* [#50581519_pgfId-1066241]##The contents of all jar files included in
each resource adapter archive (rar file) deployed separately to the
application server, if any jar file in that rar file is used to satisfy
any reference from the module using the Extension Mechanism Architecture
(as specified in link:JavaEE_Platform_Spec.htm#50581519_27048[See
Library Support]”).
* [#50581519_pgfId-1065524]##The transitive closure of any libraries
referenced by the jar files in the rar files above (as specified in
link:JavaEE_Platform_Spec.htm#50581519_27048[See Library Support]”).
* [#50581519_pgfId-1065527]##The transitive closure of any libraries
referenced by the rar files themselves (as specified in
link:JavaEE_Platform_Spec.htm#50581519_27048[See Library Support]”).
* [#50581519_pgfId-1065530]##The Java EE API classes specified in
link:JavaEE_Platform_Spec.htm#50581515_TABLE%206-1[See Java EE
Technologies] for the web container.
* [#50581519_pgfId-1065532]##All Java SE 8 API classes.

[#50581519_pgfId-1065534]## 

[#50581519_pgfId-1065786]##Components in the web container may have
access to the following classes and resources. Portable applications
must not depend on having or not having access to these classes or
resources.

* [#50581519_pgfId-1065538]##The classes and resources accessible to any
other web modules included in the same ear file, as described above.
* [#50581519_pgfId-1065541]##The content of any EJB jar files included
in the same ear file.
* [#50581519_pgfId-1065543]##The content of any client jar files
specified by the above EJB jar files.
* [#50581519_pgfId-1065545]##The transitive closure of any libraries
referenced by the above EJB jar files and client jar files (as specified
in link:JavaEE_Platform_Spec.htm#50581519_27048[See Library Support]”).
* [#50581519_pgfId-1066192]##The contents of any jar files included in
any resource adapter archives (rar files) deployed separately to the
application server.
* [#50581519_pgfId-1066193]##The transitive closure of any libraries
referenced by the jar files in the rar files above (as specified in
link:JavaEE_Platform_Spec.htm#50581519_27048[See Library Support]”).
* [#50581519_pgfId-1066197]##The transitive closure of any libraries
referenced by the rar files above themselves (as specified in
link:JavaEE_Platform_Spec.htm#50581519_27048[See Library Support]”).
* [#50581519_pgfId-1065548]##The Java EE API classes specified in
link:JavaEE_Platform_Spec.htm#50581515_TABLE%206-1[See Java EE
Technologies] for the containers other than the web container.
* [#50581519_pgfId-1065551]##Any installed libraries available in the
application server.
* [#50581519_pgfId-1065553]##Other classes or resources contained in the
application package, and specified by an explicit use of an extension
not defined by this specification.
* [#50581519_pgfId-1065557]##Other classes and resources that are part
of the implementation of the application server.

[#50581519_pgfId-1065833]## 

[#50581519_pgfId-1065834]##Components in the web container must not have
access to the following classes and resources, unless such classes or
resources are covered by one of the rules above.

* [#50581519_pgfId-1065564]##Other classes or resources in the
application package. For example, the application should not have access
to the classes in application client jar files.

======= [#50581519_pgfId-1065569]##EJB Container Class Loading Requirements

[#50581519_pgfId-1065571]##Components in the EJB container must have
access to the following classes and resources.

* [#50581519_pgfId-1065574]##The content of the EJB jar file.
* [#50581519_pgfId-1065576]##The transitive closure of any libraries
referenced by the EJB jar file (as specified in
link:JavaEE_Platform_Spec.htm#50581519_27048[See Library Support]”).
* [#50581519_pgfId-1065579]##The transitive closure of any libraries
specified by or referenced by the containing ear file (as specified in
link:JavaEE_Platform_Spec.htm#50581519_27048[See Library Support]”).
* [#50581519_pgfId-1065582]##The contents of all jar files included in
any resource adapter archives (rar files) included in the same ear file.
* [#50581519_pgfId-1065585]##The contents of all jar files included in
each resource adapter archive (rar file) deployed separately to the
application server, if that resource adapter is used to satisfy any
resource references in the module.
* [#50581519_pgfId-1066252]##The contents of all jar files included in
each resource adapter archive (rar file) deployed separately to the
application server, if any jar file in that rar file is used to satisfy
any reference from the module using the Extension Mechanism Architecture
(as specified in link:JavaEE_Platform_Spec.htm#50581519_27048[See
Library Support]”).
* [#50581519_pgfId-1065588]##The transitive closure of any libraries
referenced by the jar files in the rar files above (as specified in
link:JavaEE_Platform_Spec.htm#50581519_27048[See Library Support]”.
* [#50581519_pgfId-1065591]##The transitive closure of any libraries
referenced by the rar files themselves (as specified in
link:JavaEE_Platform_Spec.htm#50581519_27048[See Library Support]”).
* [#50581519_pgfId-1065594]##The Java EE API classes specified in
link:JavaEE_Platform_Spec.htm#50581515_TABLE%206-1[See Java EE
Technologies] for the EJB container.
* [#50581519_pgfId-1065596]##All Java SE 8 API classes.

[#50581519_pgfId-1065598]## 

[#50581519_pgfId-1065892]##Components in the EJB container may have
access to the following classes and resources. Portable applications
must not depend on having or not having access to these classes or
resources.

* [#50581519_pgfId-1065602]##The classes and resources accessible to any
web modules included in the same ear file, as described in
link:JavaEE_Platform_Spec.htm#50581519_73728[See Web Container Class
Loading Requirements]” above.
* [#50581519_pgfId-1065605]##The content of any EJB jar files included
in the same ear file.
* [#50581519_pgfId-1065607]##The content of any client jar files
specified by the above EJB jar files.
* [#50581519_pgfId-1065609]##The transitive closure of any libraries
referenced by the above EJB jar files and client jar files (as specified
in link:JavaEE_Platform_Spec.htm#50581519_27048[See Library Support]”).
* [#50581519_pgfId-1066208]##The contents of any jar files included in
any resource adapter archives (rar files) deployed separately to the
application server.
* [#50581519_pgfId-1066209]##The transitive closure of any libraries
referenced by the jar files in the rar files above (as specified in
link:JavaEE_Platform_Spec.htm#50581519_27048[See Library Support]”).
* [#50581519_pgfId-1066213]##The transitive closure of any libraries
referenced by the rar files above themselves (as specified in
link:JavaEE_Platform_Spec.htm#50581519_27048[See Library Support]”).
* [#50581519_pgfId-1065612]##The Java EE API classes specified in
link:JavaEE_Platform_Spec.htm#50581515_TABLE%206-1[See Java EE
Technologies] for the containers other than the EJB container.
* [#50581519_pgfId-1065615]##Any installed libraries available in the
application server.
* [#50581519_pgfId-1065617]##Other classes or resources contained in the
application package, and specified by an explicit use of an extension
not defined by this specification.
* [#50581519_pgfId-1065621]##Other classes and resources that are part
of the implementation of the application server.

[#50581519_pgfId-1065624]##Components in the EJB container must not have
access to the following classes and resources, unless such classes or
resources are covered by one of the

[#50581519_pgfId-1065626]##rules above.

* [#50581519_pgfId-1065628]##Other classes or resources in the
application package. For example, the application should not have access
to the classes in application client jar files.

======= [#50581519_pgfId-1065633]##Application Client Container Class Loading Requirements

[#50581519_pgfId-1065635]##Components in the application client
container must have access to the following classes and resources.

* [#50581519_pgfId-1065638]##The content of the application client jar
file.
* [#50581519_pgfId-1065640]##The transitive closure of any libraries
referenced by the above jar file (as specified in
link:JavaEE_Platform_Spec.htm#50581519_27048[See Library Support]”).
* [#50581519_pgfId-1065643]##The transitive closure of any libraries
specified by or referenced by the containing ear file (as specified in
link:JavaEE_Platform_Spec.htm#50581519_27048[See Library Support]”).
* [#50581519_pgfId-1065646]##The Java EE API classes specified in
link:JavaEE_Platform_Spec.htm#50581515_TABLE%206-1[See Java EE
Technologies] for the application client container.
* [#50581519_pgfId-1065649]##All Java SE 8 API classes.

[#50581519_pgfId-1065651]## 

[#50581519_pgfId-1065977]##Components in the application client
container may have access to the following classes and resources.
Portable applications must not depend on having or not having access to
these classes or resources.

* [#50581519_pgfId-1065655]##The Java EE API classes specified in
link:JavaEE_Platform_Spec.htm#50581515_TABLE%206-1[See Java EE
Technologies] for the containers other than the application client
container.
* [#50581519_pgfId-1065658]##Any installed libraries available in the
application server.
* [#50581519_pgfId-1065660]##Other classes or resources contained in the
application package, and specified by an explicit use of an extension
not defined by this specification.
* [#50581519_pgfId-1065664]##Other classes and resources that are part
of the implementation of the application server.

[#50581519_pgfId-1065667]## 

[#50581519_pgfId-1066004]##Components in the application client
container must not have access to the following classes and resources,
unless such classes or resources are covered by one of the rules above.

* [#50581519_pgfId-1065671]##Other classes or resources in the
application package. For example, the application client should not have
access to the classes in other application client jar files in the same
ear file, nor should it have access to the classes in web applications
or ejb jar files in the same ear file.

======= [#50581519_pgfId-1065678]##Applet Container Class Loading Requirements

[#50581519_pgfId-1065680]##The requirements for the applet container are
completely specified by the Java SE 8 specification. This specification
adds no new requirements for the applet container.

==== [#50581519_pgfId-1065477]##Application Assembly

[#50581519_pgfId-1001134]##This section specifies the sequence of steps
that are typically followed when composing a Java EE application.

======= [#50581519_pgfId-17877]##[#50581519_25462]##Assembling a Java EE Application

. [#50581519_pgfId-14377]##Select the Java EE modules that will be used
by the application.
. [#50581519_pgfId-14378]##Create an application directory structure.

[#50581519_pgfId-14379]##The directory structure of an application is
arbitrary, but by following some simple conventions a deployment
descriptor may not be needed. The structure should be designed around
the requirements of the contained components.

. [#50581519_pgfId-14383]##Reconcile Java EE module deployment
descriptors.

[#50581519_pgfId-14387]##The deployment descriptors for the Java EE
modules must be edited to link internally satisfied dependencies and
eliminate any redundant security role names. An optional element
_alt-dd_ (described in link:JavaEE_Platform_Spec.htm#50581519_14579[See
Java EE Application XML Schema]”) may be used when it is desirable to
preserve the original deployment descriptor. The element _alt-dd_
specifies an alternate deployment descriptor to use at deployment time.
The edited copy of the deployment descriptor file may be saved in the
application directory tree in a location determined by the Application
Assembler. If the _alt-dd_ element is not present, the Deployer must
read the deployment descriptor directly from the module package.

. [#50581519_pgfId-14388]##Choose unique names for the modules contained
in the application. If two modules specify conflicting names in their
deployment descriptors, create an alternate deployment descriptor for at
least one of the modules and change its name. If two modules in the same
directory of the ear file have the same base name (e.g., _foo.jar_ and
_foo.war_ ), rename one of the modules or create an alternate deployment
descriptor to specify a unique name for one of the modules.
. [#50581519_pgfId-1066492]##Link the internally satisfied dependencies
of all components in every module contained in the application. For each
component dependency, there must only be one corresponding component
that fulfills that dependency in the scope of the application.
. [#50581519_pgfId-14389]##For each _ejb-link_ , there must be only one
matching _ejb-name_ in the scope of the entire application (see
link:JavaEE_Platform_Spec.htm#50581511_15618[See Enterprise JavaBeans™
(EJB) References]”).
. [#50581519_pgfId-14390]##Dependencies that are not linked to internal
components must be handled by the Deployer as external dependencies that
must be met by resources previously installed on the platform. External
dependencies must be linked to the resources on the platform during
deployment.
. [#50581519_pgfId-14391]##Synchronize security role-names across the
application. Rename unique role-names with redundant meaning to a common
name. Rename role-names with common names but different meanings to
unique names. Descriptions of role-names that are used by many
components of the application can be included in the application-level
deployment descriptor.
. [#50581519_pgfId-18818]##Assign a context root for each web module
included in the Java EE application. The context root is a relative name
in the web namespace for the application. Each web module must be given
a distinct and non-overlapping name for its context root. The web
modules will be assigned a complete name in the namespace of the web
server at deployment time. If there is only one web module in the Java
EE application, the context root may be the empty string. If no
deployment descriptor is included in the application package, it will
use the default-context-path in the web module. Otherwise, it will use
the module name as the context root of the web module. See the Servlet
specification for detailed requirements of context root naming.
. [#50581519_pgfId-18830]##Make sure that each component in the
application properly describes any dependencies it may have on other
components in the application. A Java EE application should not assume
that all components in the application will be available on the class
path of the application at run time. Each component might be loaded into
a separate class loader with a separate namespace. If the classes in a
JAR file depend on classes in another JAR file, the first JAR file
should reference the second JAR file using the _Class-Path_ mechanism. A
notable exception to this rule is JAR files located in the _WEB-INF/lib_
directory of a web application. All such JAR files are included in the
class path of the web application at runtime; explicit references to
them using the _Class-Path_ mechanism are not needed. Another exception
to this rule is JAR files located in the library directory (usually
named _lib_ ) in the application package. Note that the presence of
component-declaring annotations in shared artifacts, such as libraries
in the library directory and libraries referenced by more than one
module through _Class-Path_ references, can have unintended and
undesirable consequences and is not recommended.
. [#50581519_pgfId-18834]##There must be only one version of each class
in an application. If one component depends on one version of a library,
and another component depends on another version, it may not be possible
to deploy an application containing both components. With the exception
of application clients, a Java EE application should not assume that
each component is loaded in a separate class loader and has a separate
namespace. All components in a single application may be loaded in a
single class loader and share a single namespace. Note, however, that it
must be possible to deploy an application such that all components of
the application are in a namespace (or namespaces) separate from that of
other applications. Typically, this will be the normal method of
deployment. By default, application clients are each deployed into their
own Java virtual machine instance, and thus each application client has
its own class namespace, and the classes from application clients are
not visible in the class namespace of other components.
. [#50581519_pgfId-14392]##(Optional) Create an XML deployment
descriptor for the application.

[#50581519_pgfId-14393]##The deployment descriptor must be named
_application.xml_ and must reside in the top level of the _META-INF_
directory of the application _.ear_ file. The deployment descriptor must
be a valid XML document according to the XML schema for a Java EE
application XML document. (Alternatively, the deployment descriptor may
meet the requirements of previous versions of Java EE.)

[#50581519_pgfId-1059320]##Many applications that follow the conventions
described below will not need a deployment descriptor for the
application. The deployment tool will determine the components of the
application using some simple rules.

. [#50581519_pgfId-14397]##Package the application.
. [#50581519_pgfId-16275]##Place the Java EE modules and the deployment
descriptor in the appropriate directories.
. [#50581519_pgfId-16276]##Package the application directory hierarchy
in a file using the JAR file format. The file should be named with a
_.ear_ filename extension.
. [#50581519_pgfId-1076125]##(Optional) Create an alternate deployment
descriptor (“alt-dd”) for the application, external to the packaged
application.

======= [#50581519_pgfId-17548]##Adding and Removing Modules

[#50581519_pgfId-14402]##After the application is created, Java EE
modules may be added or removed before deployment. When adding or
removing a module the following steps must be performed:

. [#50581519_pgfId-14403]##Decide on a location in the application
package for the new module. Optionally create new directories in the
application package hierarchy to contain any Java EE modules that are
being added to the application.
. [#50581519_pgfId-1066525]##Ensure that the name of the new module does
not conflict with any of the existing modules, either by choosing an
appropriate default filename for the module or by explicitly specifying
the module name in the module’s deployment descriptor or in an alternate
deployment descriptor.
. [#50581519_pgfId-14410]##Copy the new Java EE modules to the desired
location in the application package. The packaged modules are inserted
directly in the desired location; the modules are not unpackaged.
. [#50581519_pgfId-14414]##Edit the deployment descriptors for the Java
EE modules to link the dependencies which are internally satisfied by
the Java EE modules included in the application.
. [#50581519_pgfId-14421]##Edit the Java EE application deployment
descriptor (if included) to meet the content requirements of the Java EE
platform and the validity requirements of the Java EE application XML
DTD or schema.

==== [#50581519_pgfId-14430]##[#50581519_94977]##Deployment

[#50581519_pgfId-14434]##The Java EE platform supports three types of
deployment units:

* [#50581519_pgfId-14441]##Stand-alone Java EE modules.
* [#50581519_pgfId-14448]##Java EE applications, consisting of one or
more Java EE modules.
* [#50581519_pgfId-1010779]##Class libraries packaged as _.jar_ files
according to the _Extension Mechanism Architecture_ . These class
libraries then become installed libraries.

[#50581519_pgfId-1080492]##Any Java EE product must be able to accept a
Java EE application delivered as a _.ear_ file or a stand-alone Java EE
module delivered as a _.jar_ , _.war_ , or _.rar_ file (as appropriate
to its type), together with an optional alternate deployment descriptor
external to the application or standalone Java EE module. If the
application is delivered as a _.ear_ , an enterprise bean module
delivered as a _.jar_ file, a web application delivered as a _.war_
file, or an application client delivered as a _.jar_ file, the
deployment tool must be able to deploy the application such that the
Java classes in the application are in a separate namespace from classes
in other Java applications. Typically this will require the use of a
separate class loader for each application. Standalone resource adapters
delivered in _.rar_ files and standalone class libraries delivered in
_.jar_ files that become installed libraries will of necessity appear in
the class namespaces of applications that use them, and may appear in
the class namespace of any application depending on the level of
isolation supported by the Java EE product.

[#50581519_pgfId-1080615]##As described in
link:JavaEE_Platform_Spec.htm#50581512_65413[See Java EE Product
Packaging]”, the Java EE product might depend on external services to
meet the requirements of this specification. While the Java EE product
is not required to assure the availability of these services, it is
required to ensure that these services have been configured for use.
Deployment of applications must fail if such required services have not
been configured for use.

[#50581519_pgfId-1080501]##Deployment may provide an option that
controls whether or not an application is attempted to be started during
deployment. If no such option is provided or if the option to start the
application is specified, and if deployment is successful, the
application modules must be initialized as specified in section
link:JavaEE_Platform_Spec.htm#50581519_36072[See Module Initialization]
and the application must be started.

[#50581519_pgfId-1080503]##If the application is attempted to be started
during deployment, the Servlet and EJB containers must be initialized
during deployment. Such initialization must include CDI initialization.
If initialization fails, deployment must fail.

[#50581519_pgfId-1080505]##If the application is not attempted to be
started during deployment, these containers must not be initialized
during deployment.

[#50581519_pgfId-1080496]##In all cases, the deployment and
initialization of a Java EE application must be complete before the
container delivers client requests to any of the application’s
components. The container must first initialize all startup-time
singleton session bean components before delivering any requests to
enterprise bean components. Containers must deliver requests to web
components and resource adapters only after initialization of the
component has completed.

[#50581519_pgfId-1080497]##The optional Java EE Deployment API describes
how a product-independent deployment tool accepts plugins for a specific
Java EE product, and how the tool and those plugins cooperate to deploy
Java EE applications. The requirements in this specification that refer
to a deployment tool are meant to refer to the combination of any
vendor-provided product-independent deployment tool and the
vendor-specific deployment plugin for this tool, as well as any other
vendor-specific deployment tools provided with the Java EE product.

[#50581519_pgfId-1025234]##Typically a deployment tool will copy the
deployed application or module to a product-specific location, along
with the configuration settings and customizations specified by the
Deployer. In some cases a deployment tool might include Application
Assembly functionality as well, allowing the Deployer to construct,
modify, or customize the application before deployment. Still, it must
be possible to deploy a portable Java EE application, module, or library
containing no product-specific deployment information without modifying
the original files or artifacts that the Deployer specified to the
deployment tool.

[#50581519_pgfId-1033799]##The deployment tools for Java EE containers
must validate the deployment descriptors against the Java EE deployment
descriptor schemas or DTDs that correspond to the deployment descriptors
being processed. The appropriate schema or DTD is chosen by analyzing
the deployment descriptor to determine which version it claims to
conform to. Validation errors must cause an error to be reported to the
Deployer. The deployment tool may allow the Deployer to correct the
error and continue deployment. Note that the deployment descriptor
version refers only to the version of the XML schema or DTD against
which the descriptor is to be validated. It does not provide any
information as to what version of the Java EE platform the application
is written to.

[#50581519_pgfId-1080530]##Some deployment descriptors are optional. The
required deployment information is determined by using default rules or
by annotations present on application class files. Some deployment
descriptors that are included in an application may exist in either
complete or incomplete form. A complete deployment descriptor provides a
complete description of the deployment information; a deployment tool
must not examine class files for this deployment information. An
incomplete deployment descriptor provides only a subset of the required
deployment information; a deployment tool must examine the application
class files for annotations that specify deployment information.

[#50581519_pgfId-1080532]##If annotations are being processed (as
required by link:JavaEE_Platform_Spec.htm#50581520_45158[See Deployment
Descriptor Processing Requirements], Servlet Table 8-1, and EJB Tables
16 and 17), _at least_ all of the classes specified in
link:JavaEE_Platform_Spec.htm#50581511_19779[See Component classes
supporting injection] must be scanned for annotations that specify
deployment information. As specified in section
link:JavaEE_Platform_Spec.htm#50581519_42487[See Deploying a Java EE
Application], all classes that can be used by the application may
optionally be scanned for these annotations. (These are the annotations
that specify information equivalent to what can be specified in a
deployment descriptor. This requirement says nothing about the
processing of annotations that were defined for other purposes.) These
annotations may appear on classes, methods, and fields. All resources
specified by resource definition annotations must be created. All
resource reference annotations must result in JNDI entries in the
corresponding namespace. If the corresponding namespace is not available
to the class declaring or inheriting the reference, the resulting
behavior is undefined. Future versions of this specification may alter
this behavior.

[#50581519_pgfId-1065091]##Any deployment information specified in a
deployment descriptor overrides any deployment information specified in
an application’s class files. The Java EE component specifications,
including this specification, describe when deployment descriptors are
optional and which deployment descriptors may exist in either complete
or incomplete form. The attribute _metadata-complete_ is used in the
deployment descriptor to specify whether the descriptor is complete. The
_metadata-complete_ attribute in the standard deployment descriptors
effects _only_ the scanning of annotations that specify deployment
information, including web services deployment information. It has no
impact on the scanning of other annotations.

[#50581519_pgfId-1076070]##The scope of the _metadata-complete_
attribute is the descriptor it appears in. For historical reasons, the
_webservices.xml_ deployment descriptor does not have its own
_metadata-complete_ attribute; instead, it defers to the value of the
_metadata-complete_ attribute in the module’s deployment descriptor.
Specifications that define their own additional deployment descriptors
should provide a _metadata-complete_ attribute of their own, if deemed
useful, with the appropriate semantics.

======= [#50581519_pgfId-1015864]##[#50581519_98271]##Deploying a Stand-Alone Java EE Module

[#50581519_pgfId-14469]##This section specifies the requirements for
deploying a stand-alone Java EE module.

. [#50581519_pgfId-14473]##The deployment tool must first read the Java
EE module deployment descriptor if provided externally to the package or
if present in the package. See the component specifications for the
required location and name of the deployment descriptor for each
component type.
. [#50581519_pgfId-1053166]##If the deployment descriptor is absent, or
is present and is a Java EE 5 or later version descriptor and the
_metadata-complete_ attribute is not set to _true_ , the deployment tool
must examine all the class files in the application package. Any
annotations that specify deployment information must be logically merged
with the information in the deployment descriptor (if present). The
correspondence of annotation information with deployment descriptor
information, as well as the overriding rules, are described in this and
other Java EE specifications. The result of this logical merge process
provides the deployment information used in subsequent deployment steps.
Note that there is no requirement for the merge process to produce a new
deployment descriptor, although that might be a common implementation
technique.
. [#50581519_pgfId-1066546]##When deploying a standalone module, the
module name is used as the application name. The deployment tool must
ensure that the application name is unique in the application server
instance. If the name is not unique, the deployment tool may
automatically choose a unique name or allow the Deployer to choose a
unique name, but must not fail the deployment. This ensures that
existing modules continue to be deployable.
. [#50581519_pgfId-14477]##The deployment tool must deploy all of the
components listed in the Java EE module deployment descriptor, or marked
via annotations and discovered as described in the previous requirement,
according to the deployment requirements of the respective Java EE
component specification. If the module is a type that contains JAR
format files (for example, web and Connector modules), all classes in
_.jar_ files within the module referenced from other JAR files within
the module using the _Class-Path_ manifest header must be included in
the deployment. If the module, or any JAR format files within the
module, declares a dependency on an installed library, that dependency
must be satisfied.
. [#50581519_pgfId-18722]##The deployment tool must allow the Deployer
to configure the container to provide the resources and configuration
values needed for each component. The required resources and
configuration parameters are specified in the deployment descriptor or
via annotations discovered in requirement 2.
. [#50581519_pgfId-18804]##The deployment tool must allow the Deployer
to deploy the same module multiple times, as multiple independent
applications, possibly with different configurations. For example, the
enterprise beans in an ejb-jar file might be deployed multiple times
under different JNDI names and with different configurations of their
resources.

======= [#50581519_pgfId-14484]##[#50581519_42487]##Deploying a Java EE Application

[#50581519_pgfId-14488]##This section specifies the requirements for
deploying a Java EE application.

. [#50581519_pgfId-14492]##The deployment tool must first read the Java
EE application deployment descriptor provided externally to the
application _.ear_ file or from within the application _.ear_ file (
_META-INF/application.xml_ ). If the deployment descriptor is present,
it fully specifies the modules included in the application. If no
deployment descriptor is present, the deployment tool uses the following
rules to determine the modules included in the application.
. [#50581519_pgfId-1059325]##All files in the application package with a
filename extension of _.war_ are considered web modules. The context
root of the web module is the module name (see
link:JavaEE_Platform_Spec.htm#50581519_46804[See Component Creation]”).
. [#50581519_pgfId-1059326]##All files in the application package with a
filename extension of _.rar_ are considered resource adapters.
. [#50581519_pgfId-1059327]##A directory named _lib_ is considered to be
the library directory, as described in
link:JavaEE_Platform_Spec.htm#50581519_31584[See Bundled Libraries].”
. [#50581519_pgfId-1059328]##For all files in the application package
with a filename extension of _.jar_ , but not contained in the _lib_
directory, do the following:
. [#50581519_pgfId-1059329]##If the _.jar_ file contains a
_META-INF/MANIFEST.MF_ file with a _Main-Class_ attribute, or contains a
_META-INF/application-client.xml_ file, consider the .jar file to be an
application client module.
. [#50581519_pgfId-1059330]##If the _.jar_ file contains a
_META-INF/ejb-jar.xml_ file, or contains any class with an EJB
component-defining annotation ( _Stateless_ , etc.), consider the .jar
file to be an EJB module.
. [#50581519_pgfId-1059331]##All other _.jar_ files are ignored unless
referenced by a JAR file discovered above using one of the JAR file
reference mechanisms such as the _Class-Path_ header in a manifest file.
. [#50581519_pgfId-14499]##The deployment tool must ensure that the
application name is unique in the application server instance. If the
name is not unique, the deployment tool may automatically choose a
unique name or allow the Deployer to choose a unique name, but must not
fail the deployment. This ensures that existing applications continue to
be deployable.
. [#50581519_pgfId-1076054]##The deployment tool must open each of the
Java EE modules listed in the Java EE application deployment descriptor
or discovered using the rules above and read the Java EE module
deployment descriptor, if present in the package. See the Enterprise
JavaBeans, servlet, Java EE Connector and application client
specifications for the required location and name of the deployment
descriptor for each component type. Deployment descriptors are optional
for all module types. (The application client specification is
link:JavaEE_Platform_Spec.htm#50581520_24744[See Application Clients]”.)
. [#50581519_pgfId-1053186]##If the module deployment descriptor is
absent, or is present and is a Java EE 5 or later version descriptor and
the _metadata-complete_ attribute is not set to _true_ , the deployment
tool must examine all the class files in the application package that
can be used by the module (that is, all class files that are included in
the _.ear_ file and can be referenced by the module, such as the class
files included in the module itself, class files referenced from the
module by use of a _Class-Path_ reference, class files included in the
library directory, etc.). Any annotations that specify deployment
information must be logically merged with the information in the
deployment descriptor (if present). Note that the presence of
component-declaring annotations in shared artifacts, such as libraries
in the library directory and libraries referenced by more than one
module through _Class-Path_ references, can have unintended and
undesirable consequences and is not recommended. The correspondence of
annotation information with deployment descriptor information, as well
as the overriding rules, are described in this and other Java EE
specifications. The result of this logical merge process provides the
deployment information used in subsequent deployment steps. Note that
there is no requirement for the merge process to produce a new
deployment descriptor, although that might be a common implementation
technique.
. [#50581519_pgfId-14503]##The deployment tool must install all of the
components described by each module deployment descriptor, or marked via
annotations and discovered as described in the previous requirement,
into the appropriate container according to the deployment requirements
of the respective Java EE component specification. All classes in _.jar_
files or directories referenced from other JAR files using the
_Class-Path_ manifest header must be included in the deployment. If the
_.ear_ file, or any JAR format files within the _.ear_ file, declares a
dependency on an installed library, that dependency must be satisfied.
. [#50581519_pgfId-14507]##The deployment tool must allow the Deployer
to configure the container to provide the resources and configuration
values needed for each component. The required resources and
configuration parameters are specified in the deployment descriptor or
via annotations discovered in requirement 3.
. [#50581519_pgfId-14508]##The deployment tool must allow the Deployer
to deploy the same Java EE application multiple times, as multiple
independent applications, possibly with different configurations. For
example, the enterprise beans in an ejb-jar file might be deployed
multiple times under different JNDI names and with different
configurations of their resources.
. [#50581519_pgfId-18814]##When presenting security role descriptions to
the Deployer, the deployment tool must use the descriptions in the Java
EE application deployment descriptor rather than the descriptions in any
module deployment descriptors for security roles with the same name.
However, for security roles that appear in a module deployment
descriptor but do not appear in the application deployment descriptor,
the deployment tool must use the description provided in the module
deployment descriptor.

======= [#50581519_pgfId-1010784]##Deploying a Library

[#50581519_pgfId-1010785]##This section specifies the requirements for
deploying a library.

. [#50581519_pgfId-1010909]##The deployment tool must record the
extension name and version information from the manifest file of the
library JAR file. The deployment tool must make the library available to
other Java EE deployment units that request it according to the version
matching rules described in the Optional Package Versioning
specification. Note that the library itself may include dependencies on
other libraries and these dependencies must also be satisfied.
. [#50581519_pgfId-1010967]##The deployment tool must make the library
available with at least the same security permissions as any application
or module that uses it. The library may be installed with the full
security permissions of the container.
. [#50581519_pgfId-1010984]##Not all libraries will be deployable on all
Java EE products at all times. Libraries that conflict with the
operation of the Java EE product may not be deployable. For example, an
attempt to deploy an older version of a library that has subsequently
been included in the Java EE platform specification may be rejected.
Similarly, deployment of a library that is also used in the
implementation of the Java EE product may be rejected. Deployment of a
library that is in active use by an application may be rejected.

======= [#50581519_pgfId-1067048]##[#50581519_36072]##Module Initialization

[#50581519_pgfId-1067049]##After a successful deployment, all the
modules of an application other than application client modules are
initialized. The specifications for the different module types describe
the steps required to initialize a module. By default, the order of
initialization of modules in an application is unspecified. In rare
cases it may be important that modules are initialized in a certain
order, for example, if a component in one modules uses a component in
another module during its initialization. An application can declare
that modules must be initialized in the order they’re listed in the
application deployment descriptor by including the
_<initialize-in-order>true</initialize-in-order>_ element in the
application deployment descriptor. If the application deployment
descriptor specifies a module initialization order that conflicts with
the initialization order specified by any of the modules (for example,
by the use of the EJB _DependsOn_ annotation), the deployment tool must
report an error. Application client modules are initialized on their own
schedule, typically when an end user invokes them; as such, they are
excluded from any initialization ordering requirements.

==== [#50581519_pgfId-1005616]##[#50581519_14579]##Java EE Application XML Schema

[#50581519_pgfId-17998]##The XML grammar for a Java EE application
deployment descriptor is defined by the Java EE application schema. The
root element of the deployment descriptor for a Jaav EE application is
_application_ . The granularity of composition for Java EE application
assembly is the Java EE module. A Java EE application deployment
descriptor contains a name and description for the application and the
URI of a UI icon for the application, as well a list of the Java EE
modules that comprise the application. The content of the XML elements
is in general case sensitive. This means, for example, that
_<role-name>Manager</role-name>_ is a different role than
_<role-name>manager</role-name>_ .

[#50581519_pgfId-1080219]##All valid Java EE application deployment
descriptors must conform to the XML Schema definition, or the DTD or
schema definition from a previous version of this specification. (See
link:JavaEE_Platform_Spec.htm#50581522_11629[See Previous Version
Deployment Descriptors].”) The deployment descriptor must be named
_META-INF/application.xml_ in the _.ear_ file. Note that this name is
case-sensitive. The XML Schema located at
_http://xmlns.jcp.org/xml/ns/javaee/application_8.xsd_ defines the XML
grammar for a Java EE application deployment descriptor.

[#50581519_pgfId-1080127]##link:JavaEE_Platform_Spec.htm#50581519_54713[See
Java EE Application XML Schema Structure] shows a graphic representation
of the structure of the Java EE application XML schema.

[#50581519_pgfId-1080147]## 

======= [#50581519_pgfId-1077030]##[#50581519_54713]##Java EE Application XML Schema Structure

image:JavaEE_Platform_Spec-11.gif[image]

==== [#50581519_pgfId-1080172]##Common Java EE XML Schema Definitions

[#50581519_pgfId-1010996]##The XML Schema located at
_http://xmlns.jcp.org/xml/ns/javaee/javaee_8.xsd_ defines types that are
used by many other Java EE deployment descriptor schemas, both in this
specification and in other specifications.

======= [#50581543_pgfId-1066271]##[#50581543_32725]##CHAPTER

[#50581543_pgfId-1066273]##[#50581543_19278]##Profiles

[#50581543_pgfId-1066280]## _T_ his chapter describes the requirements
common to all Java EE profiles. It does not define any concrete
profiles, delegating this task to separate specifications.

[#50581543_pgfId-1066364]##The Java EE Web Profile Specification,
published in conjunction with the present specification, defines the
first Java EE profile, the Web Profile.

[#50581543_pgfId-1066375]##The definition of other profiles is left to
future specifications.

==== [#50581543_pgfId-14189]##[#50581543_83904]##Introduction

[#50581543_pgfId-14196]##A Java EE profile (from now on, simply “a
profile”) represents a configuration of the platform suited to a
particular class of applications.

[#50581543_pgfId-1066377]##A profile may contain a proper subset of the
technologies contained in the platform. By doing so, a profile can
effectively drop technologies which the platform supports but which are
not generally useful in a particular domain.

[#50581543_pgfId-1066934]##A profile may also add one or more
technologies which are not present in the platform itself. For example,
a hypothetical Java EE Portal Profile would likely include the Portlet
API (JSR-286).

[#50581543_pgfId-1066935]##Additionally, a profile may tag certain
technologies as optional. In this case, products implementing the
profile may or may not include the technology in question. Naturally, if
they do, they need to obey all the relevant requirements mandated by the
profile specification.

[#50581543_pgfId-1066529]##A product may implement two or more Java EE
profiles, or the full platform and one or more Java EE profiles, as long
as their combined requirements do not give rise to conflicts.

==== [#50581543_pgfId-1066306]##Profile Definition

[#50581543_pgfId-1066313]##A profile is defined in accordance with the
rules of the Java Community Process. Typically, a proposal to create a
new profile, or to revise an existing one, will be submitted as a Java
Specification Request (JSR). Once the JSR is approved, an expert group
will be formed and conduct work as dictated by the process. The JSR for
a profile must mention the version of the Java EE Platform that it
builds on. Additionally, if it builds on an existing profile, it must
mention this fact as well.

[#50581543_pgfId-1066386]##Although profiles can be created and evolved
independently of the Java EE platform, modulo the rules contained in
this specification, it is envisioned that profiles will maintain a
reasonable level of alignment with the platform itself, in order to
avoid fragmenting the development space into progressively incompatible
islands. To this end, a profile must build on the most recent version of
the Java EE platform available at the time the JSR for the profile is
approved. It is also recommended that profile expert groups go beyond
this requirement and, as much as it is practical, ensure that their
profile builds on the most recent version of the Java EE platform at the
time the profile is finalized.

==== [#50581543_pgfId-1066305]##[#50581543_10683]##General Rules for Profiles

[#50581543_pgfId-1066318]##A profile must include all technologies that
are required components of the Java EE platform or of any profiles on
which it builds. These technologies will be listed as required in the
profile.

[#50581543_pgfId-1066319]##A profile may promote to required status any
technologies that are optional components of the Java EE platform or of
any profile on which it builds.

[#50581543_pgfId-1066391]##Unless otherwise mandated by a profile, any
technologies that are optional components of the Java EE platform, or of
any profile on which the profile in question builds, must be optional
components of the profile itself.

[#50581543_pgfId-1066392]##A profile may include as a required or as an
optional component any technology outside of those included in the Java
EE platform or any profile on which it builds, as long as the
corresponding compatibility requirements are satisfied.

[#50581543_pgfId-1066393]##A profile must preserve any requirements
defined in the Java EE platform specification, or in the specification
of any profile on which it builds, as long as the preconditions for
those requirements are satisfied. Typically, the preconditions will
involve the presence of one or more technologies among those included in
the profile. Unconditional requirements must be obeyed unconditionally.

[#50581543_pgfId-1066394]##A profile may add any requirements that
pertain to one or more technologies whose inclusion it allows or
requires. Such requirements must not conflict with those set by the Java
EE platform or by any profile on which the present one builds.

[#50581543_pgfId-1066395]##The specification for individual technologies
may allow for certain features of the technology in question to be
optional. In this case, a profile may promote one or more of these
features to required status, assuming the Java EE platform or any
profile on which it builds hasn’t done so already.

[#50581543_pgfId-1066396]##A profile must not conflict with the
specifications for any technologies it includes either as required or
optional components. Therefore, unless the specification for an
individual technology explicitly allows for certain features or sets of
requirements to be optionally implementable, a profile must not itself
attempt to redefine any such features or requirements. For example, a
profile may not allow omitting a package or type or method from an API
specified elsewhere, unless the specification for that API explicitly
allows for this to happen.

[#50581543_pgfId-1066397]##Although this specification does not define
any APIs, a profile may do so. Since such an API would be available only
in profiles that build on the one that defines it, this approach limits
the reusability of the API and thus is discouraged.

==== [#50581543_pgfId-1066320]##Expression of Requirements

[#50581543_pgfId-1066325]##The present specification uses the following
conventions when expressing requirements that pertain to one or more
technologies included in the platform:

* [#50581543_pgfId-1066398]##Chapters or sections which are conditional
on the presence of a specific technology are marked as such at the very
beginning. The condition is then intended to stay in force until the
next textual unit at the same logical level (e.g. the following chapter,
or section, etc.).
* [#50581543_pgfId-1066402]##Individual paragraphs and sentences are
deemed to be conditional on any technologies they mention, unless
otherwise indicated.
* [#50581543_pgfId-1066403]##Section or paragraphs which discuss
examples, or are otherwise non-normative, do not contain any
requirements.

==== [#50581543_pgfId-1066327]##[#50581543_56596]##Requirements for All Java EE Profiles

[#50581543_pgfId-1066331]##The Java Platform, Standard Edition 8 is the
required foundation for any Java EE 8 profile.

[#50581543_pgfId-1066406]##The following technologies are required to be
present in all Java EE profiles:

* [#50581543_pgfId-1066407]##Resource and component lifecycle
annotations defined by the Common Annotations specification ( _Resource_
, _Resources_ , _PostConstruct_ , _PreDestroy_ )

[#50581543_pgfId-1066332]##The following functionality is required to be
supported in all Java EE profiles:

======= [#50581543_pgfId-1066414]##JNDI “java:” naming context (see link:JavaEE_Platform_Spec.htm#50581511_50670[See JNDI Naming Context]”)

* [#50581543_pgfId-1066418]##Java Transaction API (JTA)

==== [#50581543_pgfId-1066583]##[#50581543_26098]##Optional Features for Java EE Profiles

[#50581543_pgfId-1066584]##All the technologies listed in
link:JavaEE_Platform_Spec.htm#50581515_69518[See Required APIs]”, and
not designated as required in
link:JavaEE_Platform_Spec.htm#50581543_56596[See Requirements for All
Java EE Profiles]”, are designated as optional for use in Java EE
profiles.

[#50581543_pgfId-1066461]##The following functionality is designated as
optional for use in Java EE profiles:

* [#50581543_pgfId-1066338]##RMI/IIOP interoperability requirements (see
link:JavaEE_Platform_Spec.htm#50581517_71955[See OMG Protocols (Proposed
Optional)]”)
* [#50581543_pgfId-1066637]##Support for _java:comp/ORB_ (see
link:JavaEE_Platform_Spec.htm#50581511_72785[See ORB References]”)

==== [#50581543_pgfId-1066339]##[#50581543_34148]##Full Java EE Product Requirements

[#50581543_pgfId-1066344]##This section defines the requirements for
full Java EE platform products. These requirements correspond to the
full set of requirements in previous versions of the Java EE platform
specification and update those requirements for this new version of the
platform.

[#50581543_pgfId-1066343]##Please note that, due to the effects of the
pruning process, future versions of the Java EE specification will
likely relax the requirements given here, specifically by marking as
optional technologies that have been subject to pruning and that are
required by the present specification. The set of technologies that have
been made optional and/or identified as candidates for pruning is given
in link:JavaEE_Platform_Spec.htm#50581515_20153[See Pruned Java
Technologies]”.

[#50581543_pgfId-1066347]##The following technologies are required:

* [#50581543_pgfId-1066737]##EJB 3.2 (except for EJB entity beans and
associated EJB QL, which have been made optional)
* [#50581543_pgfId-1066754]##Servlet 4.0
* [#50581543_pgfId-1066761]##JSP 2.3
* [#50581543_pgfId-1066762]##EL 3.0
* [#50581543_pgfId-1066763]##JMS 2.0
* [#50581543_pgfId-1066764]##JTA 1.2
* [#50581543_pgfId-1066765]##JavaMail 1.6
* [#50581543_pgfId-1066766]##Connector 1.7
* [#50581543_pgfId-1066767]##Web Services 1.4
* [#50581543_pgfId-1066770]##JAX-RS 2.1
* [#50581543_pgfId-1067713]##WebSocket 1.1
* [#50581543_pgfId-1067714]##JSON-P 1.1
* [#50581543_pgfId-1067798]##JSON-B 1.0
* [#50581543_pgfId-1067741]##Concurrency Utilities 1.0
* [#50581543_pgfId-1067715]##Batch 1.0
* [#50581543_pgfId-1066774]##Java EE Management 1.1
* [#50581543_pgfId-1066776]##JACC 1.5
* [#50581543_pgfId-1066777]##JASPIC 1.1
* [#50581543_pgfId-1067827]##Java EE Security 1.0
* [#50581543_pgfId-1066778]##JSP Debugging 1.0
* [#50581543_pgfId-1066779]##JSTL 1.2
* [#50581543_pgfId-1066780]##Web Services Metadata 2.1
* [#50581543_pgfId-1066781]##JSF 2.3
* [#50581543_pgfId-1066782]##Common Annotations 1.3
* [#50581543_pgfId-1066784]##Java Persistence 2.2
* [#50581543_pgfId-1066785]##Bean Validation 2.0
* [#50581543_pgfId-1066786]##Managed Beans 1.0
* [#50581543_pgfId-1067716]##Interceptors 1.2
* [#50581543_pgfId-1066787]##Contexts and Dependency Injection for Java
EE 2.0
* [#50581543_pgfId-1066788]##Dependency Injection for Java 1.0

[#50581543_pgfId-1066432]## 

[#50581543_pgfId-1066902]##The following technologies are optional:

* [#50581543_pgfId-1066880]##EJB 3.2 and earlier entity beans and
associated EJB QL
* [#50581543_pgfId-1066887]##JAX-RPC 1.1
* [#50581543_pgfId-1066888]##JAXR 1.0
* [#50581543_pgfId-1066889]##Java EE Deployment 1.2

[#50581543_pgfId-1066878]## 

======= [#50581520_pgfId-7064]##CHApter __ [#50581520_32725]##

[#50581520_pgfId-7065]##[#50581520_24744]##Application Clients

[#50581520_pgfId-7561]## _T_ his chapter describes application clients
in the Java™ Platform, Enterprise Edition (Java EE).

[#50581520_pgfId-1029007]##A full Java EE product must support the
application client container as described in this chapter. A Java EE
profile may or may not require support for the application client
container.

==== [#50581520_pgfId-7672]##[#50581520_77151]##Overview

[#50581520_pgfId-7675]##Application clients are first tier client
programs that execute in their own Java™ virtual machines. Application
clients follow the model for Java technology-based applications: they
are invoked at their _main_ method and run until the virtual machine is
terminated. However, like other Java EE application components,
application clients depend on a container to provide system services.
The application client container may be very light-weight compared to
other Java EE containers, providing only the security and deployment
services described below

==== [#50581520_pgfId-7747]##[#50581520_91265]##Security

[#50581520_pgfId-7749]##The Java EE authentication requirements for
application clients are the same as for other Java EE components, and
the same authentication techniques may be used as for other Java EE
application components.

[#50581520_pgfId-7754]##No authentication is necessary when accessing
unprotected web resources. When accessing protected web resources, the
usual varieties of authentication may be used, namely HTTP Basic
authentication, SSL client authentication, or HTTP Login Form
authentication. Lazy authentication may be used.

[#50581520_pgfId-7755]##Authentication is required when accessing
protected enterprise beans. The authentication mechanisms for enterprise
beans include those required in the EJB specification for enterprise
bean interoperability. Lazy authentication may be used.

[#50581520_pgfId-7756]##An application client makes use of an
authentication service provided by the application client container for
authenticating its users. The container’s service may be integrated with
the native platform’s authentication system, so that a single signon
capability is employed. The container may authenticate the user when the
application is started, or it may use lazy authentication,
authenticating the user when a protected resource is accessed. This
specification does not describe the technique used to authenticate the
user, although a later version may do so.

[#50581520_pgfId-998580]##If the container interacts with the user to
gather authentication data, the container must provide an appropriate
user interface. In addition, an application client may provide a class
that implements the _javax.security.auth.callback.CallbackHandler_
interface and specify the class name in its deployment descriptor (see
link:JavaEE_Platform_Spec.htm#50581520_62711[See Java EE Application
Client XML Schema]” for details). The Deployer may override the callback
handler specified by the application and use the container’s default
authentication user interface instead.

[#50581520_pgfId-7757]##If a callback handler is configured by the
Deployer, the application client container must instantiate an object of
this class and use it for all authentication interactions with the user.
The application’s callback handler must fully support _Callback_ objects
specified in the _javax.security.auth.callback_ package.

[#50581520_pgfId-9589]##Note that when HTTP Login Form authentication is
used, the authentication user interface provided by the server (in the
form of an HTML page delivered in response to an HTTP request) must be
displayed by the application client.

[#50581520_pgfId-7759]##Application clients typically execute in an
environment with a SecurityManager installed, and have similar security
permission requirements as servlets. The security permission
requirements are described fully in
link:JavaEE_Platform_Spec.htm#50581515_98360[See Java Platform, Standard
Edition (Java SE) Requirements].”

==== [#50581520_pgfId-999845]##Transactions

[#50581520_pgfId-7783]##Application clients are not required to have
direct access to the transaction facilities of the Java EE platform. A
Java EE product is not required to provide a JTA _UserTransaction_
object for use by application clients. Application clients can invoke
enterprise beans that start transactions, and they can use the
transaction facilities of the JDBC API. If a JDBC API transaction is
open when an application client invokes an enterprise bean, the
transaction context is not required to be propagated to the EJB server.

==== [#50581520_pgfId-999827]##Resources, Naming, and Injection

[#50581520_pgfId-999828]##As with all Java EE components, application
clients use JNDI to look up enterprise beans, get access to resource
managers, reference configurable parameters set at deployment time, and
so on. Application clients use the _java:_ JNDI namespace to access
these items (see link:JavaEE_Platform_Spec.htm#50581511_16122[See
Resources, Naming, and Injection]” for details).

[#50581520_pgfId-1026965]##Injection is also supported for the
application client main class. Because the application client container
does not create instances of the application client main class, but
merely loads the class and invokes the static _main_ method, injection
into the application client class uses _static_ fields and methods,
unlike other Java EE components. Injection occurs before the _main_
method is called.

==== [#50581520_pgfId-7798]##Application Programming Interfaces

[#50581520_pgfId-7799]##Application clients have all the facilities of
the JavaTM Platform, Standard Edition (subject to security
restrictions), as well as various standard extensions, as described in
Chapter EE.6 “Application Programming Interface.” Each application
client executes in its own Java virtual machine. Application clients
start execution at the _main_ method of the class specified in the
_Main-Class_ attribute in the manifest file of the application client’s
JAR file (although note that application client container code will
typically execute before the application client itself, in order to
prepare the environment of the container, install a _SecurityManager_ ,
initialize the name service client library, and so on).

==== [#50581520_pgfId-7686]##[#50581520_91752]##Packaging and Deployment

[#50581520_pgfId-7687]##Application clients are packaged in JAR format
files with a _.jar_ extension and may include a deployment descriptor
similar to other Java EE application components. The deployment
descriptor describes the enterprise beans, web services, and other types
of external resources referenced by the application. If the deployment
descriptor is not included, or is included but not marked
_metadata-complete_ , annotations on the main class of the application
client may also be used to describe the resources needed by the
application. As with other Java EE application components, access to
resources must be configured at deployment time, names assigned for
enterprise beans and resources, and so on.

[#50581520_pgfId-1023641]##The following table describes the cases the
deployment tool must consider when deciding whether or not to process
annotations on the application client main class. Whether or not to
process annotations depends on the presence and version of the
deployment descriptor and the setting of the _metadata-complete_
attribute.

======= [#50581520_pgfId-1023577]##[#50581520_45158]##Deployment Descriptor Processing Requirements

[#50581520_pgfId-1023583]##Deployment descriptor

[#50581520_pgfId-1023585]##metadata-complete?

[#50581520_pgfId-1023587]##process annotations?

[#50581520_pgfId-1023589]##application-client_1_2

[#50581520_pgfId-1023591]##N/A

[#50581520_pgfId-1023593]##No

[#50581520_pgfId-1023595]##application-client_1_3

[#50581520_pgfId-1023597]##N/A

[#50581520_pgfId-1023599]##No

[#50581520_pgfId-1023601]##application-client_1_4

[#50581520_pgfId-1023603]##N/A

[#50581520_pgfId-1023605]##No

[#50581520_pgfId-1023607]##application-client_5

[#50581520_pgfId-1023609]##Yes

[#50581520_pgfId-1023611]##No

[#50581520_pgfId-1023613]##application-client_5

[#50581520_pgfId-1023615]##No

[#50581520_pgfId-1023617]##Yes

[#50581520_pgfId-1041087]##application-client_6

[#50581520_pgfId-1041089]##Yes

[#50581520_pgfId-1041091]##No

[#50581520_pgfId-1036686]##application-client_6

[#50581520_pgfId-1036688]##No

[#50581520_pgfId-1036690]##Yes

[#50581520_pgfId-1041105]##application-client_7

[#50581520_pgfId-1041107]##Yes

[#50581520_pgfId-1041109]##No

[#50581520_pgfId-1036680]##application-client_7

[#50581520_pgfId-1036682]##No

[#50581520_pgfId-1036684]##Yes

[#50581520_pgfId-1042362]##application-client_8

[#50581520_pgfId-1042364]##Yes

[#50581520_pgfId-1042366]##No

[#50581520_pgfId-1042356]##application-client_8

[#50581520_pgfId-1042358]##No

[#50581520_pgfId-1042360]##Yes

[#50581520_pgfId-1023619]##none

[#50581520_pgfId-1023621]##N/A

[#50581520_pgfId-1023623]##Yes

[#50581520_pgfId-1042378]##The _metadata-complete_ attribute defines
whether the application client deployment descriptor is complete, or
whether the class files available to the application client module
should be examined for annotations that specify deployment information.
Deployment information, in this sense, refers to any information that
could have been specified by the application client deployment
descriptor for the module.

[#50581520_pgfId-1042380]##If the value of the _metadata-complete_
attribute is specified as _“true”_ , the deployment tool must ignore any
annotations that specify such deployment information in the class files
packaged in the application client jar file. Such annotations must also
be ignored when processing the class files that are available to the
application client module for the deployment of this module according to
link:JavaEE_Platform_Spec.htm#50581519_42487[See Deploying a Java EE
Application]”.

[#50581520_pgfId-1042382]##Note that a _"true"_ value for the
_metadata-complete_ attribute does _not_ preempt the processing of _all_
annotations, only those that specify deployment information.

[#50581520_pgfId-1042475]##The list of annotations to which the
_metadata-complete_ attribute applies currently includes the following:

[#50581520_pgfId-1042476]## 

* [#50581520_pgfId-1042578]## _javax.annotation.PostConstruct_
* [#50581520_pgfId-1042387]## _javax.annotation.PreDestroy_
* [#50581520_pgfId-1042388]## _javax.annotation.Resource_
* [#50581520_pgfId-1042389]## _javax.annotation.Resources_
* [#50581520_pgfId-1042390]##
_javax.annotation.sql.DataSourceDefinition_
* [#50581520_pgfId-1042391]##
_javax.annotation.sql.DataSourceDefinitions_

[#50581520_pgfId-1042392]## __  

* [#50581520_pgfId-1042393]## _javax.ejb.EJB_
* [#50581520_pgfId-1042394]## _javax.ejb.EJBs_

[#50581520_pgfId-1042395]## __  

* [#50581520_pgfId-1042396]## _javax.jms.JMSConnectionFactoryDefinition_
* [#50581520_pgfId-1042397]##
_javax.jms.JMSConnectionFactoryDefinitions_
* [#50581520_pgfId-1042398]## _javax.jms.JMSDestinationDefinition_
* [#50581520_pgfId-1042399]## _javax.jms.JMSDestinationDefinitions_

[#50581520_pgfId-1042400]## __  

* [#50581520_pgfId-1042401]## _javax.mail.MailSessionDefinition_
* [#50581520_pgfId-1042402]## _javax.mail.MailSessionDefinitions_

[#50581520_pgfId-1042403]## __  

* [#50581520_pgfId-1042404]## _javax.persistence.PersistenceUnit_
* [#50581520_pgfId-1042405]## _javax.persistence.PersistenceUnits_

[#50581520_pgfId-1042406]## __  

* [#50581520_pgfId-1042407]##
_javax.resource.AdministeredObjectDefinition_
* [#50581520_pgfId-1042408]##
_javax.resource.AdministeredObjectDefinitions_
* [#50581520_pgfId-1042409]##
_javax.resource.ConnectionFactoryDefinition_
* [#50581520_pgfId-1042410]##
_javax.resource.ConnectionFactoryDefinitions_

[#50581520_pgfId-1042411]## __  

* [#50581520_pgfId-1042412]##All annotations in the following packages:
* [#50581520_pgfId-1042413]## _javax.jws_
* [#50581520_pgfId-1042694]##javax.jws.soap
* [#50581520_pgfId-1042695]##javax.xml.ws
* [#50581520_pgfId-1042696]##javax.xml.ws.soap
* [#50581520_pgfId-1042697]##javax.xml.ws.spi

[#50581520_pgfId-1042414]## __  

[#50581520_pgfId-1042415]##If the _metadata-complete_ attribute is not
specified or its value is _"false"_ , the deployment tool must examine
the class files for all such annotations.

[#50581520_pgfId-1042376]##The tool used to deploy an application client
to the client machine, and the mechanism used to install the application
client, is not specified. Very sophisticated Java EE products may allow
the application client to be deployed on a Java EE server and
automatically made available to some set of (usually intranet) clients.
Other Java EE products may require the Java EE application bundle
containing the application client to be manually deployed and installed
on each client machine. And yet another approach would be for the
deployment tool on the Java EE server to produce an installation package
that could be used by each client to install the application client.
There are many possibilities here and this specification doesn’t
prescribe any one. It only defines the package format for the
application client and the things that must be possible during the
deployment process.

[#50581520_pgfId-7694]##How an application client is invoked by an end
user is unspecified. Typically a Java EE Product Provider will provide
an application launcher that integrates with the application client
machine’s native operating system, but the level of such integration is
unspecified.

==== [#50581520_pgfId-1001328]##[#50581520_62711]##Java EE Application Client XML Schema

[#50581520_pgfId-8144]##The XML grammar for a Java EE application client
deployment descriptor is defined by the Java EE application-client
schema. The root element of the deployment descriptor for an application
client is _application-client_ . The content of the XML elements is in
general case sensitive. This means, for example, that
_<res-auth>Container</res-auth>_ must be used, rather than
_<res-auth>container</res-auth>_ .

[#50581520_pgfId-8955]##All valid _application-client_ deployment
descriptors must conform to the XML Schema definition, or to a DTD or
schema definition from a previous version of this specification. (See
link:JavaEE_Platform_Spec.htm#50581522_11629[See Previous Version
Deployment Descriptors].”) The deployment descriptor must be named
_META-INF/application-client.xml_ in the application client’s _.jar_
file. Note that this name is case-sensitive.

[#50581520_pgfId-1041759]##
_link:JavaEE_Platform_Spec.htm#50581520_54750[See Java EE Application
Client XML Schema Structure]_ shows the structure of the Java EE
application-client XML Schema. The Java EE application-client XML Schema
is located at
_http://xmlns.jcp.org/xml/ns/javaee/application-client_8.xsd_ .

[#50581520_pgfId-1042319]## 

image:JavaEE_Platform_Spec-12.gif[image]

======= [#50581520_pgfId-1041178]##[#50581520_54750]##Java EE Application Client XML Schema Structure

======= [#50581516_pgfId-874]##CHAPTER[#50581516_32725]##

[#50581516_pgfId-5529]##[#50581516_23041]##Service Provider Interface

[#50581516_pgfId-5890]## _T_ he Java™ Platform, Enterprise Edition (Java
EE) includes several technologies that are primarily intended to be used
to extend the capabilities of the Java EE containers. In addition, some
Java EE technologies include service provider interfaces along with
their application programming interfaces. A Java EE profile may include
some or all of these facilities, as described in
link:JavaEE_Platform_Spec.htm#50581543_19278[See Profiles]”.

==== [#50581516_pgfId-10572]##Java™ EE Connector Architecture

[#50581516_pgfId-10539]##The Connector API defines how resource adapters
are packaged and integrated with any Java EE product. Many types of
service providers can be provided using the Connector API and packaging,
including JDBC drivers, JMS providers, and JAXR providers. All Java EE
products must support the Connector APIs, as specified in the Connector
specification.

[#50581516_pgfId-10546]##The Connector specification is available at
_http://jcp.org/en/jsr/detail?id=322_ .

==== [#50581516_pgfId-10528]##Java™ Authorization Service Provider Contract for Containers

[#50581516_pgfId-10560]##The JACC specification defines the contract
between a Java EE container and an authorization policy provider.

[#50581516_pgfId-10567]##The JACC specification is available at
_http://jcp.org/en/jsr/detail?id=115_ .

==== [#50581516_pgfId-10549]##Java™ Transaction API

[#50581516_pgfId-10583]##The Java Transaction API defines the
_TransactionSynchronizationRegistry_ interface that is intended for use
by system level application server components such as persistence
managers, resource adapters, as well as EJB and Web application
components. This provides the ability to register synchronization
objects with special ordering semantics, associate resource objects with
the current transaction, get the transaction context of the current
transaction, get current transaction status, and mark the current
transaction for rollback.

[#50581516_pgfId-10595]##The JTA specification is available at
_http://jcp.org/en/jsr/detail?id=907_ .

==== [#50581516_pgfId-10591]##Java™ Persistence

[#50581516_pgfId-10592]##Java Persistence provides interfaces in the
_javax.persistence.spi_ package that allow a persistence provider to be
plugged into the Java Persistence framework.

[#50581516_pgfId-10602]##The Java Persistence specification is available
at _http://jcp.org/en/jsr/detail?id=338_ .

==== [#50581516_pgfId-10623]##JavaMail™

[#50581516_pgfId-10624]##The JavaMail specification describes how
JavaMail protocol providers can be packaged and distributed so that they
can be discovered and used through the JavaMail API. This allows the
JavaMail API to be extended with support for new mail protocols and
mailbox formats.

[#50581516_pgfId-10625]##The JavaMail specification is available at
_http://jcp.org/en/jsr/detail?id=919_ .

[#50581516_pgfId-10627]## 

======= [#50581541_pgfId-874]##CHAPTER[#50581541_32725]##

[#50581541_pgfId-5529]##[#50581541_23041]##Compatibility and Migration

[#50581541_pgfId-10544]## _T_ his chapter summarizes compatibility and
migration issues for the Java EE platform. The specifications for each
of the component technologies included in Java EE also describe
compatibility and migration issues for that technology in much more
detail.

==== [#50581541_pgfId-10545]## Compatibility

[#50581541_pgfId-10546]##The word compatibility covers many different
concepts. Java EE products are compatible with the Java EE specification
if they implement the APIs and behavior required by the specification.
Applications are compatible with a release of the Java EE platform if
they only depend on APIs and behavior defined by that release of the
platform. A new release of the Java EE platform is compatible with
previous releases of the platform if all portable applications written
to the previous release of the platform will also run unchanged and with
identical behavior on the new release of the platform.

[#50581541_pgfId-10547]##Compatibility is a core value of the Java EE
platform. A Java EE product is required to support portable applications
written to previous versions of the platform. Compatibility and
portability work together to provide the Write Once, Run Anywhere value
of the Java EE platform. Java EE products conform to the Java EE
specifications by providing APIs and behavior as required by the
specifications. Portable applications depend only on the APIs and
behavior required by the Java EE specifications. In general, portable
applications written to a previous version of the platform will continue
to work without change and with identical behavior on the current
version of the platform.

==== [#50581541_pgfId-10552]##Migration

[#50581541_pgfId-10553]##Migration is the act of converting an
application to use new facilities introduced in this release of the
platform. Given the strong level of compatibility in this release of the
Java EE platform, migration is largely an optional exercise. Still, an
application may be improved (better performance, simpler to develop,
more flexible, etc.) by converting it to use newer facilities of the
Java EE platform.

======= [#50581541_pgfId-10557]##Java Persistence

[#50581541_pgfId-10851]##Java Persistence provides a much richer set of
modeling capabilities and object/relational mapping capabilities than
EJB CMP entity beans and is significantly easier to use.

[#50581541_pgfId-10559]##Support for EJB CMP and BMP entity beans has
been made optional with the Java EE 7 release. Support for EJB CMP 1.1
entity beans has been deprecated since Java EE 5. Applications are
strongly encouraged to migrate applications using EJB entity beans to
the Java Persistence API.

======= [#50581541_pgfId-10560]##JAX-WS

[#50581541_pgfId-10561]##JAX-WS, along with JAXB and the Metadata for
Web Services specification, provides simpler and more complete support
for web services than is available using the JAX-RPC technology. Support
for JAX-RPC has been made optional with the Java EE 7 release.
Applications that provide web services using JAX-RPC should consider
migrating to the JAX-WS API. Note that because both technologies support
the same web service interoperability standards, clients and services
can be migrated to the new API independently.

[#50581541_pgfId-10563]## 

======= [#50581518_pgfId-874]##CHAPTER [#50581518_32725]##

[#50581518_pgfId-6957]##[#50581518_50017]##Future Directions

[#50581518_pgfId-6975]## _T_ his version of the Java™ Platform,
Enterprise Edition (Java EE) specification includes most of the
facilities needed by enterprise applications. Still, there is always
more to be done. This chapter briefly describes our plans for future
versions of this specification. Please keep in mind that all of this is
subject to change. Your feedback is encouraged.

[#50581518_pgfId-7094]##The following sections describe additional
facilities we would like to include in future versions of this
specification. Many of the APIs included in the Java EE platform will
continue to evolve on their own and we will include the latest version
of each API.

==== [#50581518_pgfId-7538]##Java EE SPI

[#50581518_pgfId-7017]##Many of the APIs that make up the Java EE
platform include an SPI layer that allows service providers or other
system level components to be plugged in. This specification does not
describe the execution environment for all such service providers, nor
the packaging and deployment requirements for all service providers.
However, the Java EE Connector Architecture does define the requirements
for certain types of service providers called resource adapters, and the
Java Authorization Contract for Containers defines requirements for
security service providers. Future versions of this specification will
more fully define the Java EE SPI.

[#50581518_pgfId-7055]## 

[#50581518_pgfId-7127]## 

======= [#50581522_pgfId-874]##[#50581522_32725]##Appendix

[#50581522_pgfId-13916]##[#50581522_11629]##Previous Version Deployment
Descriptors

[#50581522_pgfId-22700]## _T_ his appendix describes Document Type
Definitions and XML schemas for Deployment Descriptors from previous
versions of the Java EE specification. All Java EE products are required
to support these DTDs and schemas as well as the schemas specified in
this version of the specification. This ensures that applications
written to previous versions of this specification can be deployed on
products supporting the current version of this specification. In
addition, there are no restrictions on mixing versions of deployment
descriptors in a single application; any combination of valid deployment
descriptor versions must be supported.

=== [#50581522_pgfId-45747]##Java EE 7 Application XML Schema

[#50581522_pgfId-45751]##The XML grammar for a Java EE application
deployment descriptor is defined by the Java EE application schema. The
root element of the deployment descriptor for a Jaav EE application is
_application_ . The granularity of composition for Java EE application
assembly is the Java EE module. A Java EE application deployment
descriptor contains a name and description for the application and the
URI of a UI icon for the application, as well a list of the Java EE
modules that comprise the application. The content of the XML elements
is in general case sensitive. This means, for example, that
_<role-name>Manager</role-name>_ is a different role than
_<role-name>manager</role-name>_ .

[#50581522_pgfId-45761]##All valid Java EE application deployment
descriptors must conform to the XML Schema definition, or the DTD or
schema definition from a previous version of this specification. The
deployment descriptor must be named _META-INF/application.xml_ in the
_.ear_ file. Note that this name is case-sensitive.
link:JavaEE_Platform_Spec.htm#50581522_35410[See Java EE 7 Application
XML Schema Structure] shows a graphic representation of the structure of
the Java EE application 7 XML Schema.

[#50581522_pgfId-45765]## 

======= [#50581522_pgfId-46492]##[#50581522_35410]## Java EE 7 Application XML Schema Structure

image:JavaEE_Platform_Spec-13.gif[image]

[#50581522_pgfId-46493]## 

[#50581522_pgfId-46591]##
_link:JavaEE_Platform_Spec.htm#50581522_43272[See Java EE Application
XML Schema Structure]_ The XML Schema located at
_http://xmlns.jcp.org/xml/ns/javaee/application_7.xsd_ defines the XML
grammar for a Java EE 7 application deployment descriptor.

=== [#50581522_pgfId-46502]##Common Java EE XML Schema Definitions

[#50581522_pgfId-46503]##The XML Schema located at
_http://xmlns.jcp.org/xml/ns/javaee/javaee_7.xsd_ defines types that are
used by many other Java EE deployment descriptor schemas, both in this
specification and in other specifications.

=== [#50581522_pgfId-46505]##Java EE 7 Application Client XML Schema

[#50581522_pgfId-46509]##The XML grammar for a Java EE application
client deployment descriptor is defined by the Java EE
application-client schema. The root element of the deployment descriptor
for an application client is _application-client_ . The content of the
XML elements is in general case sensitive. This means, for example, that
_<res-auth>Container</res-auth>_ must be used, rather than
_<res-auth>container</res-auth>_ .

[#50581522_pgfId-46513]##All valid _application-client_ deployment
descriptors must conform to the XML Schema definition, or to a DTD or
schema definition from a previous version of this specification. The
deployment descriptor must be named _META-INF/application-client.xml_ in
the application client’s _.jar_ file. Note that this name is
case-sensitive.

[#50581522_pgfId-46520]##
_link:JavaEE_Platform_Spec.htm#50581522_38214[See Java EE 7 Application
Client XML Schema Structure]_ shows the structure of the Java EE
application-client XML Schema. The Java EE application-client XML Schema
is located at
_http://xmlns.jcp.org/xml/ns/javaee/application-client_7.xsd_ .

======= [#50581522_pgfId-46523]##[#50581522_38214]##Java EE 7 Application Client XML Schema Structure

image:JavaEE_Platform_Spec-14.gif[image]

=== [#50581522_pgfId-45741]##[#50581522_84147]##Java EE 6 Application XML Schema

[#50581522_pgfId-31163]##The XML grammar for a Java EE application
deployment descriptor is defined by the Java EE application schema. The
root element of the deployment descriptor for a Jaav EE application is
_application_ . The granularity of composition for Java EE application
assembly is the Java EE module. A Java EE application deployment
descriptor contains a name and description for the application and the
URI of a UI icon for the application, as well a list of the Java EE
modules that comprise the application. The content of the XML elements
is in general case sensitive. This means, for example, that
_<role-name>Manager</role-name>_ is a different role than
_<role-name>manager</role-name>_ .

[#50581522_pgfId-39297]##All valid Java EE application deployment
descriptors must conform to the XML Schema definition, or the DTD or
schema definition from a previous version of this specification. The
deployment descriptor must be named _META-INF/application.xml_ in the
_.ear_ file. Note that this name is case-sensitive.
link:JavaEE_Platform_Spec.htm#50581522_18482[See Java EE Application XML
Schema Structure] shows a graphic representation of the structure of the
Java EE application XML Schema.

[#50581522_pgfId-39300]## 

======= [#50581522_pgfId-39301]##[#50581522_18482]## Java EE Application XML Schema Structure

image:JavaEE_Platform_Spec-15.gif[image]

[#50581522_pgfId-42317]## 

[#50581522_pgfId-31236]##
_link:JavaEE_Platform_Spec.htm#50581522_43272[See Java EE Application
XML Schema Structure]_ The XML Schema located at
_http://java.sun.com/xml/ns/javaee/application_6.xsd_ defines the XML
grammar for a Java EE application deployment descriptor.

=== [#50581522_pgfId-31197]##[#50581522_25116]##Common Java EE XML Schema Definitions

[#50581522_pgfId-31198]##The XML Schema located at
_http://java.sun.com/xml/ns/javaee/javaee_6.xsd_ defines types that are
used by many other Java EE deployment descriptor schemas, both in this
specification and in other specifications.

=== [#50581522_pgfId-32998]##[#50581522_44613]##Java EE 6 Application Client XML Schema

[#50581522_pgfId-33002]##The XML grammar for a Java EE application
client deployment descriptor is defined by the Java EE
application-client schema. The root element of the deployment descriptor
for an application client is _application-client_ . The content of the
XML elements is in general case sensitive. This means, for example, that
_<res-auth>Container</res-auth>_ must be used, rather than
_<res-auth>container</res-auth>_ .

[#50581522_pgfId-33006]##All valid _application-client_ deployment
descriptors must conform to the XML Schema definition, or to a DTD or
schema definition from a previous version of this specification. The
deployment descriptor must be named _META-INF/application-client.xml_ in
the application client’s _.jar_ file. Note that this name is
case-sensitive.

[#50581522_pgfId-33013]##
_link:JavaEE_Platform_Spec.htm#50581522_65003[See Java EE Application
Client XML Schema Structure]_ shows the structure of the Java EE
application-client XML Schema. The Java EE application-client XML Schema
is located at
_http://java.sun.com/xml/ns/javaee/application-client_6.xsd_ .

======= [#50581522_pgfId-32996]##[#50581522_65003]##Java EE Application Client XML Schema Structure

image:JavaEE_Platform_Spec-16.gif[image]

=== [#50581522_pgfId-30990]##Java EE 5 Application XML Schema

[#50581522_pgfId-30044]##The XML grammar for a Java EE application
deployment descriptor is defined by the Java EE application schema. The
root element of the deployment descriptor for a Jaav EE application is
_application_ . The granularity of composition for Java EE application
assembly is the Java EE module. A Java EE application deployment
descriptor contains a name and description for the application and the
URI of a UI icon for the application, as well a list of the Java EE
modules that comprise the application. The content of the XML elements
is in general case sensitive. This means, for example, that
_<role-name>Manager</role-name>_ is a different role than
_<role-name>manager</role-name>_ .

[#50581522_pgfId-30054]##A valid Java EE 5 application deployment
descriptors must conform to this XML Schema definition.

[#50581522_pgfId-30056]##The deployment descriptor must be named
_META-INF/application.xml_ in the _.ear_ file. Note that this name is
case-sensitive.

[#50581522_pgfId-32983]##
_link:JavaEE_Platform_Spec.htm#50581522_43272[See Java EE Application
XML Schema Structure]_ shows a graphic representation of the structure
of the Java EE application XML Schema.

[#50581522_pgfId-32851]##.

image:JavaEE_Platform_Spec-17.gif[image]

======= [#50581522_pgfId-32960]##[#50581522_43272]##Java EE Application XML Schema Structure

[#50581522_pgfId-30172]##The XML Schema located at
_http://java.sun.com/xml/ns/javaee/application_5.xsd_ defines the XML
grammar for a Java EE application deployment descriptor.

=== [#50581522_pgfId-30176]##Common Java EE 5 XML Schema Definitions

[#50581522_pgfId-30177]##The XML Schema located at
_http://java.sun.com/xml/ns/javaee/javaee_5.xsd_ defines types that are
used by many other Java EE deployment descriptor schemas, both in this
specification and in other specifications.

=== [#50581522_pgfId-30178]##Java EE 5 Application Client XML Schema

[#50581522_pgfId-30182]##The XML grammar for a Java EE application
client deployment descriptor is defined by the Java EE
application-client schema. The root element of the deployment descriptor
for an application client is _application-client_ . The content of the
XML elements is in general case sensitive. This means, for example, that
_<res-auth>Container</res-auth>_ must be used, rather than
_<res-auth>container</res-auth>_ .

[#50581522_pgfId-30186]##All valid _application-client_ deployment
descriptors must conform to the XML Schema definition, or to a DTD or
schema definition from a previous version of this specification. The
deployment descriptor must be named _META-INF/application-client.xml_ in
the application client’s _.jar_ file. Note that this name is
case-sensitive.

[#50581522_pgfId-30196]##
_link:JavaEE_Platform_Spec.htm#50581522_49041[See Java EE Application
Client XML Schema Structure]_ shows the structure of the Java EE
application-client XML Schema. The Java EE application-client XML Schema
is located at
_http://java.sun.com/xml/ns/javaee/application-client_5.xsd_ .

[#50581522_pgfId-30690]## 

image:JavaEE_Platform_Spec-18.gif[image]

======= [#50581522_pgfId-30205]##[#50581522_49041]##Java EE Application Client XML Schema Structure

=== [#50581522_pgfId-30035]##J2EE 1.4 Application XML Schema

[#50581522_pgfId-25884]##This section provides the XML Schema for the
J2EE application deployment descriptor. The XML grammar for a J2EE
application deployment descriptor is defined by the _J2EE:application_
schema. The granularity of composition for J2EE application assembly is
the J2EE module. A _J2EE:application_ deployment descriptor contains a
name and description for the application and the URI of a UI icon for
the application, as well a list of the J2EE modules that comprise the
application. The content of the XML elements is in general case
sensitive. This means, for example, that
_<role-name>Manager</role-name>_ is a different role than
_<role-name>manager</role-name>_ .

[#50581522_pgfId-25903]##A valid J2EE application deployment descriptors
may conform to the XML Schema definition below. The deployment
descriptor must be named _META-INF/application.xml_ in the _.ear_ file.
Note that this name is case-sensitive.

[#50581522_pgfId-29419]##
_link:JavaEE_Platform_Spec.htm#50581522_98852[See J2EE:application XML
DTD Structure]_ link:JavaEE_Platform_Spec.htm#50581522_87680[See J2EE
Application XML Schema Structure] shows a graphic representation of the
structure of the J2EE application XML Schema.

[#50581522_pgfId-29521]##[#50581522_33173]## 

image:JavaEE_Platform_Spec-19.gif[image]

======= [#50581522_pgfId-29518]##[#50581522_87680]##J2EE Application XML Schema Structure

[#50581522_pgfId-26020]##The XML Schema that defines the XML grammar for
a J2EE 1.4 application deployment descriptor is located at
_http://java.sun.com/xml/ns/j2ee/application_1_4.xsd_ .

=== [#50581522_pgfId-26246]##Common J2EE 1.4 XML Schema Definitions

[#50581522_pgfId-26247]##The XML Schema that defines types that are used
by many other J2EE 1.4 deployment descriptor schemas, both in this
specification and in other specifications, is located at
_http://java.sun.com/xml/ns/j2ee/j2ee_1_4.xsd_ .

=== [#50581522_pgfId-25505]##J2EE:application 1.3 XML DTD

[#50581522_pgfId-25506]##This section provides the XML DTD for the J2EE
1.3 application deployment descriptor. The XML grammar for a J2EE
application deployment descriptor is defined by the _J2EE:application_
document type definition. The granularity of composition for J2EE
application assembly is the J2EE module. A _J2EE:application_ deployment
descriptor contains a name and description for the application and the
URI of a UI icon for the application, as well as a list of the J2EE
modules that comprise the application. The content of the XML elements
is in general case sensitive. This means, for example, that
_<role-name>Manager</role-name>_ is a different role than
_<role-name>manager</role-name>_ .

[#50581522_pgfId-25525]##A valid J2EE 1.3 application deployment
descriptor may contain the following DOCTYPE declaration:

[#50581522_pgfId-25526]## <!DOCTYPE application PUBLIC "-//Sun
Microsystems, Inc.//DTD J2EE Application 1.3//EN"
"http://java.sun.com/dtd/application_1_3.dtd">

[#50581522_pgfId-25527]##The deployment descriptor must be named
_META-INF/application.xml_ in the _.ear_ file.

[#50581522_pgfId-25534]##
_link:JavaEE_Platform_Spec.htm#50581522_98852[See J2EE:application XML
DTD Structure]_ shows a graphic representation of the structure of the
_J2EE:application_ XML DTD.

[#50581522_pgfId-25635]## 

image:JavaEE_Platform_Spec-20.gif[image]

======= [#50581522_pgfId-25640]##[#50581522_98852]##J2EE:application XML DTD Structure

[#50581522_pgfId-25644]##The DTD that defines the XML grammar for a J2EE
1.3 application deployment descriptor is available at
http://java.sun.com/dtd/application_1_3.dtd.

=== [#50581522_pgfId-22711]##[#50581522_14579]##J2EE:application 1.2 XML DTD

[#50581522_pgfId-22712]##This section provides the XML DTD for the J2EE
1.2 version of the application deployment descriptor. A valid J2EE 1.2
application deployment descriptor may contain the following DOCTYPE
declaration:

[#50581522_pgfId-17522]##<!DOCTYPE application PUBLIC "-//Sun
Microsystems, Inc.//DTD J2EE Application 1.2//EN"
"http://java.sun.com/j2ee/dtds/application_1_2.dtd">

[#50581522_pgfId-14539]##
_link:JavaEE_Platform_Spec.htm#50581522_92411[See J2EE:application XML
DTD Structure]_ shows a graphic representation of the structure of the
_J2EE:application_ XML DTD.

[#50581522_pgfId-29526]## 

image:JavaEE_Platform_Spec-21.gif[image]

======= [#50581522_pgfId-14607]##[#50581522_92411]##J2EE:application XML DTD Structure

[#50581522_pgfId-16415]##The DTD that defines the XML grammar for a J2EE
1.2 application deployment descriptor is available at
http://java.sun.com/j2ee/dtds/application_1_2.dtd.

=== [#50581522_pgfId-27702]##J2EE 1.4 Application Client XML Schema

[#50581522_pgfId-27721]##The XML grammar for a J2EE application client
deployment descriptor is defined by the J2EE application-client schema.
The root element of the deployment descriptor for an application client
is _application-client_ . The content of the XML elements is in general
case sensitive. This means, for example, that
_<res-auth>Container</res-auth>_ must be used, rather than
_<res-auth>container</res-auth>_ .

[#50581522_pgfId-29138]##A valid _application-client_ deployment
descriptors may conform to the following XML Schema definition. The
deployment descriptor must be named _META-INF/application-client.xml_ in
the application client’s _.jar_ file. Note that this name is
case-sensitive.

[#50581522_pgfId-29406]##link:JavaEE_Platform_Spec.htm#50581522_34404[See
J2EE Application Client XML Schema Structure] shows the structure of the
J2EE 1.4 application-client XML Schema, which is available at
_http://java.sun.com/xml/ns/j2ee/application-client_1_4.xsd_ .

[#50581522_pgfId-29527]## 

image:JavaEE_Platform_Spec-22.gif[image]

======= [#50581522_pgfId-29399]##[#50581522_34404]##J2EE Application Client XML Schema Structure

=== [#50581522_pgfId-24230]##J2EE:application-client 1.3 XML DTD

[#50581522_pgfId-24234]##This section describes the XML DTD for the J2EE
1.3 version of the application client deployment descriptor. The XML
grammar for a J2EE application client deployment descriptor is defined
by the _J2EE:application-client_ document type definition. The root
element of the deployment descriptor for an application client is
_application-client_ . The content of the XML elements is in general
case sensitive. This means, for example, that
_<res-auth>Container</res-auth>_ must be used, rather than
_<res-auth>container</res-auth>_ .

[#50581522_pgfId-24238]##A valid _application-client_ deployment
descriptor may contain the following DOCTYPE declaration:

[#50581522_pgfId-24239]##<!DOCTYPE application-client PUBLIC "-//Sun
Microsystems, Inc.//DTD J2EE Application Client 1.3//EN" "
_http://java.sun.com/dtd/application-client_1_3.dtd_ ">

[#50581522_pgfId-24240]##The deployment descriptor must be named
_META-INF/application-client.xml_ in the application client’s _.jar_
file.

[#50581522_pgfId-29532]##
_link:JavaEE_Platform_Spec.htm#50581522_58101[See
J2EE:application-client XML DTD Structure]_ shows the structure of the
_J2EE:application-client_ XML DTD, which is available at
http://java.sun.com/dtd/application-client_1_3.dtd.

image:JavaEE_Platform_Spec-23.gif[image]

======= [#50581522_pgfId-29736]##[#50581522_58101]##J2EE:application-client XML DTD Structure

=== [#50581522_pgfId-18100]##[#50581522_62711]##J2EE:application-client 1.2 XML DTD

[#50581522_pgfId-18108]##This section describes the XML DTD for the J2EE
1.2 version of the application client deployment descriptor. A valid
application client deployment descriptor may contain the following
DOCTYPE declaration:

[#50581522_pgfId-18109]##<!DOCTYPE application-client PUBLIC "-//Sun
Microsystems, Inc.//DTD J2EE Application Client 1.2//EN"
"http://java.sun.com/j2ee/dtds/application-client_1_2.dtd">

[#50581522_pgfId-18490]##
_link:JavaEE_Platform_Spec.htm#50581522_37581[See
J2EE:application-client XML DTD Structure]_ shows the structure of the
_J2EE:application-client_ XML DTD, which is available at
http://java.sun.com/j2ee/dtds/application-client_1_2.dtd.

[#50581522_pgfId-29741]## 

image:JavaEE_Platform_Spec-24.gif[image]

======= [#50581522_pgfId-18273]##[#50581522_37581]##J2EE:application-client XML DTD Structure

======= [#50581508_pgfId-6947]## aPPENDIX

[#50581508_pgfId-9484]##Revision History

=== [#50581508_pgfId-6948]##Changes in Early Draft

======= [#50581508_pgfId-22025]##Additional Requirements

* [#50581508_pgfId-22029]##Java EE 8 requires Java SE 8.
* [#50581508_pgfId-22047]##Added
link:JavaEE_Platform_Spec.htm#50581515_58030[See Java API for JSON
Binding 1.0 (JSON-B) Requirements].”
* [#50581508_pgfId-22081]##Added link:api.htm#50581515_19200[].”
* [#50581508_pgfId-22085]##Added
link:JavaEE_Platform_Spec.htm#50581512_65413[See Java EE Product
Packaging]”; updated link:JavaEE_Platform_Spec.htm#50581519_94977[See
Deployment].”
* [#50581508_pgfId-22106]##Clarified semantics of _metadata-complete_
for application clients.

======= [#50581508_pgfId-22086]##Editorial Changes

* [#50581508_pgfId-22034]##Updated
link:JavaEE_Platform_Spec.htm#50581511_19779[See Component classes
supporting injection],
link:JavaEE_Platform_Spec.htm#50581515_TABLE%206-1[See Java EE
Technologies], and Section
link:JavaEE_Platform_Spec.htm#50581543_34148[See Full Java EE Product
Requirements] to reflect requirements for JSON-B and MVC.
* [#50581508_pgfId-22090]##Updated URLs for many referenced documents.
* [#50581508_pgfId-22089]##Updated version numbers for component
technologies.

=== [#50581508_pgfId-22118]##Changes in Early Draft 2

======= [#50581508_pgfId-22125]##Additional Requirements

======= [#50581508_pgfId-22129]##Added CORBA, including RMI/IIOP and Java IDL, to list of “Proposed Optional” technologies.

======= [#50581508_pgfId-22141]##Removed Requirements

======= [#50581508_pgfId-22145]##Removed MVC 1.0 from required APIs in link:JavaEE_Platform_Spec.htm#50581511_19779[See Component classes supporting injection] and link:JavaEE_Platform_Spec.htm#50581515_TABLE%206-1[See Java EE Technologies];
removed section on “Model-View-Controller (MVC) 1.0 Requirements” from Chapter link:JavaEE_Platform_Spec.htm#50581515_32725[See CHAPTER].

======= [#50581508_pgfId-22169]##Editorial Changes

======= [#50581508_pgfId-22173]##Changed version of Bean Validation from 1.1 to 2.0.

* [#50581508_pgfId-22184]##Changed version of JMS from 2.1 to 2.0.
* [#50581508_pgfId-22211]##Removed section on JNLP from
link:JavaEE_Platform_Spec.htm#50581518_50017[See Future Directions].”

=== [#50581508_pgfId-22220]##Changes in Public Review Draft

======= [#50581508_pgfId-22261]##Additional Requirements

* [#50581508_pgfId-22259]##Added
link:JavaEE_Platform_Spec.htm#50581515_39392[See Java EE Security API
1.0 Requirements].”
* [#50581508_pgfId-22297]##Updated
link:JavaEE_Platform_Spec.htm#50581519_25462[See Assembling a Java EE
Application],” to reflect Servlet requirements of context root naming.
* [#50581508_pgfId-22304]##Updated version of TLS that must be supported
to 1.2 in link:JavaEE_Platform_Spec.htm#50581515_12091[See Networking].”
* [#50581508_pgfId-22308]##Updated version of HTML that Java EE web
clients must be able to display to 4.01 in
link:JavaEE_Platform_Spec.htm#50581517_24910[See Data Formats].”

======= [#50581508_pgfId-22227]##Editorial Changes

======= [#50581508_pgfId-22231]##Added acknowledgements for Java EE 8 work.

* [#50581508_pgfId-22270]##Added
link:JavaEE_Platform_Spec.htm#50581512_96204[See Changes in Java EE 8].”
* [#50581508_pgfId-22283]##Updated
link:JavaEE_Platform_Spec.htm#50581515_TABLE%206-1[See Java EE
Technologies] and Section
link:JavaEE_Platform_Spec.htm#50581543_34148[See Full Java EE Product
Requirements] to reflect requirements for Java EE Security API.
* [#50581508_pgfId-22235]##Corrected version of Web Socket to 1.1.
* [#50581508_pgfId-22239]##Removed references to JAX-WS and JAXB from
link:JavaEE_Platform_Spec.htm#50581515_TABLE%206-1[See Java EE
Technologies] as they are included as part of Java SE.
* [#50581508_pgfId-22243]##Removed section on JAXB from
link:JavaEE_Platform_Spec.htm#50581515_32725[See CHAPTER].
* [#50581508_pgfId-22247]##Moved contents of previous section on JAX-WS
to Section link:JavaEE_Platform_Spec.htm#50581515_47538[See Java™ API
for XML Web Services (JAX-WS) Requirements].
* [#50581508_pgfId-22251]##Removed section on JAX-WS from
link:spi.htm#50581516_43638[See CHAPTeR].
* [#50581508_pgfId-22342]##Removed requirement inconsistent with Bean
Validation specification from
link:JavaEE_Platform_Spec.htm#50581511_72918[See Validator and Validator
Factory References].”
* [#50581508_pgfId-22340]##Clarified requirements for JASPIC Servlet
Container Profile and JASPIC SOAP Profile in
link:JavaEE_Platform_Spec.htm#50581515_45801[See Java™ Authentication
Service Provider Interface for Containers (JASPIC) 1.1 Requirements].”

=== [#50581508_pgfId-22360]##Changes in Proposed Final Draft

======= [#50581508_pgfId-22386]##Additional Requirements

* [#50581508_pgfId-22389]##Updated
link:JavaEE_Platform_Spec.htm#50581514_20029[See Security],” to reflect
requirements of the Java EE Security API.

======= [#50581508_pgfId-22366]##Editorial Changes

* [#50581508_pgfId-22358]##Corrected version of Batch to 1.0.
* [#50581508_pgfId-22378]##Added clarification regarding TLS support in
“link:JavaEE_Platform_Spec.htm#50581517_63291[See Internet and Web
Protocols].
* [#50581508_pgfId-22369]##Updated “Related Documents.”
* [#50581508_pgfId-22370]##Added reference to
_https:javaee.github.io/javaee-spec[]http:javaee.github.io/javaee-spec[]https:javaee.github.io/javaee-spec
project._

=== [#50581508_pgfId-22412]##Changes in Final Release Draft

======= [#50581508_pgfId-22427]##Additional Requirements

* [#50581508_pgfId-22431]##Updated
link:JavaEE_Platform_Spec.htm#50581514_91016[See SSL Mutual
Authentication],” to reflect requirements for support of TLS 1.2 and
related cipher suites.
* [#50581508_pgfId-22438]##Updated
link:JavaEE_Platform_Spec.htm#50581514_20029[See Security],” to reflect
Java EE Security API specification requirement to support default
mapping from user groups to roles.

======= [#50581508_pgfId-22418]##Editorial Changes

* [#50581508_pgfId-22410]##Made clarifications to list of annotations
and requirements in link:JavaEE_Platform_Spec.htm#50581520_91752[See
Packaging and Deployment].”

======= [#50581521_pgfId-6947]##APPENDIX [#50581521_55242]##

[#50581521_pgfId-14963]##[#50581521_53633]##Related Documents

[#50581521_pgfId-14964]## _T_ his specification refers to the following
documents. The terms used to refer to the documents in this
specification are included in parentheses.

[#50581521_pgfId-8155]## _Java™ Platform, Enterprise Edition
Specification Version 8_ (this specification). Available at
_http://jcp.org/en/jsr/detail?id=366_ .

[#50581521_pgfId-8190]## _Java™ Platform, Standard Edition, v8 API
Specification_ (Java SE specification). Available at
_http://docs.oracle.com/javase/8/docs/[]http://docs.oracle.com/javase/8/docs/._

[#50581521_pgfId-8186]## _Enterprise JavaBeans™ Specification, Version
3.2_ (EJB specification). Available at
_http://jcp.org/en/jsr/detail?id=345_ .

[#50581521_pgfId-13527]## _JavaServer Pages™ Specification, Version 2.3_
(JSP specification). Available at _http://jcp.org/en/jsr/detail?id=245_
.

[#50581521_pgfId-13528]## _Expression Language Specification, Version
3.0_ (EL specification). Available at
_http://jcp.org/en/jsr/detail?id=341_ .

[#50581521_pgfId-13532]## _Common Annotations for the Java Platform
Specification 1.3_ . Available at _http://jcp.org/en/jsr/detail?id=250_
.

[#50581521_pgfId-8009]## _Java™ Servlet Specification, Version 4.0_
(Servlet specification). Available at
_http://jcp.org/en/jsr/detail?id=369_ .

[#50581521_pgfId-8011]## _JDBC™ 4.2 API_ (JDBC specification). Available
at _http://jcp.org/en/jsr/detail?id=221_ .

[#50581521_pgfId-8015]## _Java™ Naming and Directory Interface 1.2
Specification_ (JNDI specification). Available at
_http://docs.oracle.com/javase/8/docs/technotes/guides/jndi/index.html[]http://docs.oracle.com/javase/8/docs/technotes/guides/jndi/index.html._

[#50581521_pgfId-8017]## _Java™ Message Service, Version 2.0_ (JMS
specification). Available at _http://jcp.org/en/jsr/detail?id=343_ .

[#50581521_pgfId-12920]## _Java™ Transaction API, Version 1.2_ (JTA
specification). Available at _http://jcp.org/en/jsr/detail?id=907_ .

[#50581521_pgfId-12921]## _Java™ Transaction Service, Version 1.0_ (JTS
specification). Available at
_http://www.oracle.com/technetwork/java/javaee/jts-spec095-1508547.pdf_
.

[#50581521_pgfId-8029]## _JavaMail™ API Specification Version 1.6_
(JavaMail specification). Available at
_http://jcp.org/en/jsr/detail?id=919_ .

[#50581521_pgfId-8169]## _JavaBeans™ Activation Framework Specification
Version 1.1_ (JAF specification). Available at
_http://www.oracle.com/technetwork/java/javase/tech/index-jsp-138795.html_
.

[#50581521_pgfId-8301]## _Java EE™ Connector Architecture 1.7_
(Connector specification). Available at
_http://jcp.org/en/jsr/detail?id=322_ .

[#50581521_pgfId-13513]##Web Services for Java EE 1.4 (Web Services
specification). Available at _http://jcp.org/en/jsr/detail?id=109_ .

[#50581521_pgfId-12948]##Java™ API for XML-based RPC 1.1 (JAX-RPC
specification). Available at _http://jcp.org/en/jsr/detail?id=101_ .

[#50581521_pgfId-12429]##SOAP with Attachments API for Java™ 1.3 (SAAJ
specification). Available at
_http://download.oracle.com/otndocs/jcp/jaxm-1.3-mrel-spec-oth-JSpec/_ .

[#50581521_pgfId-12261]##Java™ API for XML Registries 1.0 (JAXR
specification). Available at _http://jcp.org/en/jsr/detail?id=93_ .

[#50581521_pgfId-13132]## _JAX-RS: The JavaTM API for RESTful Web
Services 2.1_ (JAX-RS specification). Available at
_http://jcp.org/en/jsr/summary?id=370_ .

[#50581521_pgfId-12271]##Java™ Platform, Enterprise Edition Management
Specification 1.1 (Java EE Management specification). Available at
_http://jcp.org/en/jsr/detail?id=77_ .

[#50581521_pgfId-12281]##Java™ Platform, Enterprise Edition Deployment
Specification 1.2 (Java EE Deployment specification). Available at
_http://jcp.org/en/jsr/detail?id=88_ .

[#50581521_pgfId-12259]##Java™ Authorization Service Provider Contract
for Containers 1.5 (JACC specification). Available at
_http://jcp.org/en/jsr/detail?id=115_ .

[#50581521_pgfId-13162]##Java™ Authentication Service Provider Interface
for Containers 1.1 (JASPIC specification). Available at
_http://jcp.org/en/jsr/detail?id=196_ .

[#50581521_pgfId-15019]##Java™ EE Security API 1.0. Available at
_http://jcp.org/en/jsr/detail?id=375_ .

[#50581521_pgfId-12777]##Debugging Support for Other Languages 1.0.
Available at _http://jcp.org/en/jsr/detail?id=45_ .

[#50581521_pgfId-12778]##Standard Tag Library for JavaServer Pages 1.2
(JSTL specification). Available at _http://jcp.org/en/jsr/detail?id=52_
.

[#50581521_pgfId-12791]##Web Services Metadata for the Java Platform
2.1. Available at _http://jcp.org/en/jsr/detail?id=181_ .

[#50581521_pgfId-12796]##JavaServer Faces 2.3 (JSF specification).
Available at _http://jcp.org/en/jsr/detail?id=372_ .

[#50581521_pgfId-12806]##Java Persistence 2.2 (Java Persistence
specification). Available at _http://jcp.org/en/jsr/detail?id=338_ .

[#50581521_pgfId-13325]##Bean Validation 2.0 (Bean Validation
specification). Available at _http://jcp.org/en/jsr/detail?id=380_ .

[#50581521_pgfId-13367]##Managed Beans 1.0 (Managed Beans
specification). Available at _http://jcp.org/en/jsr/detail?id=316_ .

[#50581521_pgfId-13410]##Interceptors 1.2 _rev A_ (Interceptors
specification). Available at _http://jcp.org/en/jsr/detail?id=318_ .

[#50581521_pgfId-13193]##Contexts and Dependency Injection for the Java
EE Platform 2.0 (CDI specification). Available at
_http://jcp.org/en/jsr/detail?id=365_ .

[#50581521_pgfId-13471]##Dependency Injection for Java 1.0 (DI
specification). Available at _http://jcp.org/en/jsr/detail?id=330_ .

[#50581521_pgfId-14746]## _Java API for WebSocket 1.1_ (WebSocket
specification). Available at _http://jcp.org/en/jsr/detail?id=356_ .

[#50581521_pgfId-14761]## _Java API for JSON Processing 1.1_ (JSON-P
specification). Available at _http://jcp.org/en/jsr/detail?id=374_ .

[#50581521_pgfId-14949]## _Java API for JSON Binding 1.0_ (JSON-B
specification). Available at _http://jcp.org/en/jsr/detail?id=367_ .

[#50581521_pgfId-14831]## _Concurrency Utilities for Java EE 1.0_
(Concurrency Utilities specification). Available at
_http://jcp.org/en/jsr/detail?id=236_ .

[#50581521_pgfId-14771]## _Batch Applications for the Java Platform 1.0
rev A_ (Batch specification). Available at
_http://jcp.org/en/jsr/detail?id=352_ .

[#50581521_pgfId-13462]##Extension Mechanism Architecture, Available at
_http://docs.oracle.com/javase/8/docs/technotes/guides/extensions/index.html_
.

[#50581521_pgfId-13304]##Optional Package Versioning, Available at
_http://docs.oracle.com/javase/8/docs/technotes/guides/extensions/index.html_
.

[#50581521_pgfId-13305]##JAR File Specification, Available at
_http://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html_ .

[#50581521_pgfId-8367]## _The Common Object Request Broker: Architecture
and Specification_ (CORBA 2.3.1 specification), Available at
_http://www.omg.org/cgi-bin/doc?formal/99-10-07_ .

[#50581521_pgfId-12240]##CORBA 2.6 - Chapter 26 - Secure
Interoperability, Available at
_http://www.omg.org/cgi-bin/doc?formal/01-12-30_ .

[#50581521_pgfId-8318]## _IDL To Java™ Language Mapping Specification_ ,
Available at _http://www.omg.org/cgi-bin/doc?ptc/2000-01-08_ .

[#50581521_pgfId-8031]## _Java™ Language To IDL Mapping Specification_ ,
Available at _http://www.omg.org/cgi-bin/doc?ptc/2000-01-06_ .

[#50581521_pgfId-8340]## _Interoperable Naming Service,_ Available at
_http://www.omg.org/cgi-bin/doc?ptc/00-08-07_ .

[#50581521_pgfId-12395]## _Transaction Service Specification_ (OTS
specification), Available at
_http://www.omg.org/cgi-bin/doc?formal/2001-11-03_ .

[#50581521_pgfId-8037]## _The SSL Protocol, Version 3.0._ Available at
_http://tools.ietf.org/html/rfc6101_ .

[#50581521_pgfId-13235]##Architectural Styles and the Design of
Network-based Software Architectures (REST), R. Fielding, Ph.d
dissertation, University of California, Irvine, 2000. Available at
_http://roy.gbiv.com/pubs/dissertation/top.htm_ .

[#50581521_pgfId-13236]##[#50581521_76170]##Java _™_ Community Process
_SM_ 2: Process Document, Version 2.10 (March 21, 2016). Available at
_http://jcp.org/en/procedures/jcp2_ .

[#50581521_pgfId-13222]## 

[#50581521_pgfId-8038]## 

[#50581521_pgfId-8039]## 

'''''

[.footnoteNumber]# 1.# [#50581514_pgfId-12877]##While the client is
stateless with respect to authentication, the client requires that the
server act as its proxy and maintain its login context. A reference to
the login session state is made available to the client through cookies
or URL re-writing. If SSL mutual authentication is used as the
authentication protocol, the client can manage its own authentication
context, and need not depend on references to the login session state.

[.footnoteNumber]# 2.# [#50581513_pgfId-25428]##A product instance
corresponds to a single installation of a Java EE product. A single
product instance might use multiple operating system processes, or might
support multiple host machines as part of a distributed container. In
contrast, it might be possible to run multiple instances of a product on
a single host machine, or possibly even in a single Java virtual
machine, for example, as part of a virtual hosting solution. The
transaction propagation requirement applies within a single product
instance and is independent of the number of Java virtual machines,
operating system processes, or host machines used by the product
instance.

[.footnoteNumber]# 3.# [#50581513_pgfId-28071]##For a JSP page, this
requirement applies to the _service_ method of the equivalent JSP page
Implementation Class.

[.footnoteNumber]# 4.# [#50581511_pgfId-1000473]##Note that Java EE
Managed Beans are required to have access to the JNDI naming environment
of their calling component.

[.footnoteNumber]# 5.# [#50581511_pgfId-1006927]##Note that the use of
interceptors defined by means of the Interceptors annotation is
supported in the absence of CDI for EJB and Managed Bean components.

[.footnoteNumber]# 6.# [#50581511_pgfId-1008094]##See the JSF
specification section “JSF Managed Classes and Java EE Annotations” for
a list of these managed classes.

[.footnoteNumber]# 7.# [#50581511_pgfId-1008172]##Resource and CDI
injection is supported only in JAX-RS components managed by CDI.

[.footnoteNumber]# 8.# [#50581511_pgfId-1008123]##Interceptors cannot be
bound to other interceptors.

[.footnoteNumber]# 9.# [#50581511_pgfId-1008142]##See the CDI
specification for requirements related to resource injection in CDI
managed beans.

[.footnoteNumber]# 10.# [#50581511_pgfId-1008148]##We use this term to
refer to classes that become managed beans per the rules in the CDI
specification, thus excluding managed beans declared using the
_ManagedBean_ annotation as well as EJB session beans, both of which
would be managed beans even in the absence of CDI.

[.footnoteNumber]# 11.# [#50581511_pgfId-1008152]##Interceptors cannot
be bound to decorators.

[.footnoteNumber]# 12.# [#50581511_pgfId-14923]##Connections obtained
from the same resource manager connection factory through a different
resource manager connection factory reference may be shareable.

[.footnoteNumber]# 13.# [#50581511_pgfId-1003842]##Note that the
Deployer is not prohibited from overriding the resource address.

[.footnoteNumber]# 14.# [#50581515_pgfId-1022529]##Client APIs only.

[.footnoteNumber]# 15.# [#50581515_pgfId-1022538]##EJB entity beans and
associated EJB QL only.

[.footnoteNumber]# 16.# [#50581515_pgfId-1027175]##IIOP
interoperability, including EJB 2.x and 1.x client view.

[.footnoteNumber]# 17.# [#50581515_pgfId-1022686]##See
link:JavaEE_Platform_Spec.htm#50581515_35657[See Java™ Platform,
Enterprise Edition Deployment API 1.2 Requirements (Optional)] for
details.

[.footnoteNumber]# 18.# [#50581515_pgfId-1024346]##Note that a component
specification is permitted to specify an exception to this in order to
accommodate interface type dependencies—for example, the EJB
SessionContext dependency on the javax.xml.rpc.handler.MessageContext
type.

[.footnoteNumber]# 19.# [#50581515_pgfId-1024756]##The FilePermission *
specifically refers to all files under the current directory.

[.footnoteNumber]# 20.# [#50581515_pgfId-1024771]##(For Web components
only.) It must be possible to grant FilePermission for the tempdir
provided to web components through the ServletContext regardless of its
physical location. In addition, it must be possible to grant
FilePermission for the tempdir without granting it for all files under
the current directory.

[.footnoteNumber]# 21.# [#50581515_pgfId-1025010]##It must be possible
to deploy an application module such that no instances of
java.lang.RuntimePermission are granted to the components in the
application module except those with a target of loadlibrary.* for any
specific library or a target of queuePrintJob. Ideally a container would
be capable of restricting those as well, but that is not a requirement.

[.footnoteNumber]# 22.# [#50581515_pgfId-1025028]##It must be possible
to deploy an application module such that no instances of
java.util.PropertyPermission are granted that allow writing any
property.
